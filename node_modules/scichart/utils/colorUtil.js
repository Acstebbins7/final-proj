"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uintArgbColorIsTransparent = exports.uintArgbColorOverrideOpacity = exports.uintArgbColorMultiplyOpacity = exports.uintArgbColorToAbgr = exports.linearColorMapLerp = exports.uintArgbColorLerp = void 0;
const TLinearColorMap_1 = require("../types/TLinearColorMap");
const parseColor_1 = require("./parseColor");
/**
 * Linearly interpolates between two colors based on the ratio passed in. E.g. Ratio = 0.0f returns From color,
 * ratio = 1.0f returns To Color. Ratio = 0.5f returns a mix of the two
 * @param from
 * @param to
 * @param ratio
 * @constructor
 */
function uintArgbColorLerp(from, to, ratio) {
    const mask1 = 0x00ff00ff;
    const mask2 = 0xff00ff00;
    const f2 = 256 * ratio;
    const f1 = 256 - f2;
    return (((((from & mask1) * f1 + (to & mask1) * f2) >> 8) & mask1) |
        ((((from & mask2) * f1 + (to & mask2) * f2) >> 8) & mask2));
}
exports.uintArgbColorLerp = uintArgbColorLerp;
/**
 * Linearly interpolates a data-value in a TLinearColorMap, which specifies Gradient Stops, Data Minimum
 * and Maximum and color stepping mode
 * @param colorMap
 * @param dataValue
 * @constructor
 */
function linearColorMapLerp(colorMap, dataValue) {
    // Value is outside of range, return Minimum color
    if (dataValue < colorMap.Minimum) {
        return parseColor_1.parseColorToUIntArgb(colorMap.GradientStops[0].color);
    }
    // Scale the value from 0.0 -> 1.0
    const scaleFactor = 1 / (colorMap.Maximum - colorMap.Minimum);
    const scaledValue = (dataValue - colorMap.Minimum) * scaleFactor;
    const stops = colorMap.GradientStops;
    // Calculate scale factors for gradient stops
    const stopScaleFactors = [];
    let i;
    for (i = 1; i < stops.length; i++) {
        stopScaleFactors.push(1 / (stops[i].offset - stops[i - 1].offset));
    }
    for (i = 0; i < stops.length - 1; i++) {
        const stop = stops[i];
        const nextStop = stops[i + 1];
        // If between two stops
        if (scaledValue >= stop.offset && scaledValue < nextStop.offset) {
            // Simple step? Just return the current stop color
            if (colorMap.Mode === TLinearColorMap_1.EColorMapMode.Stepped) {
                return parseColor_1.parseColorToUIntArgb(stop.color);
            }
            // Compute the ratio to interpolate between two stops
            const localRatio = (scaledValue - stop.offset) * stopScaleFactors[i];
            return uintArgbColorLerp(parseColor_1.parseColorToUIntArgb(stop.color), parseColor_1.parseColorToUIntArgb(nextStop.color), localRatio);
        }
    }
    return parseColor_1.parseColorToUIntArgb(colorMap.GradientStops[i].color);
}
exports.linearColorMapLerp = linearColorMapLerp;
function uintArgbColorToAbgr(argbColor) {
    const r = (argbColor & 0x00ff0000) >> 16;
    const g = (argbColor & 0x0000ff00) >> 8;
    const b = argbColor & 0x000000ff;
    let retval = argbColor - (argbColor & 0x00ffffff);
    retval += b << 16;
    retval += g << 8;
    retval += r;
    return retval;
}
exports.uintArgbColorToAbgr = uintArgbColorToAbgr;
function uintArgbColorMultiplyOpacity(argbColor, opacity) {
    let alpha = argbColor - (argbColor & 0x00ffffff);
    alpha = alpha >>> 24;
    alpha *= opacity;
    alpha = Math.floor(alpha);
    alpha = alpha * 0x1000000; // ( 24 bitwise right shift simply doesn't work, as it generates a negative values )
    const rgb = argbColor & 0x00ffffff; // RGB
    return alpha + rgb;
}
exports.uintArgbColorMultiplyOpacity = uintArgbColorMultiplyOpacity;
function uintArgbColorOverrideOpacity(argbColor, opacity) {
    let alpha = opacity * 255;
    alpha = Math.floor(alpha);
    alpha = alpha * 0x1000000; // ( 24 bitwise right shift simply doesn't work, as it generates a negative values )
    const rgb = argbColor & 0x00ffffff; // RGB
    return alpha + rgb;
}
exports.uintArgbColorOverrideOpacity = uintArgbColorOverrideOpacity;
function uintArgbColorIsTransparent(argbColor) {
    const alpha = argbColor - (argbColor & 0x00ffffff);
    return alpha !== 0xff000000;
}
exports.uintArgbColorIsTransparent = uintArgbColorIsTransparent;
