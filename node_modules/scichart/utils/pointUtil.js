"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcDistanceFromLineSegment = exports.calcDotProduct = exports.testIsInXBounds = exports.testIsInBounds = exports.calcDistance = exports.calcCrossProduct = exports.calcDistanceFromLine = void 0;
exports.calcDistanceFromLine = (x, y, startX, startY, endX, endY) => {
    return Math.abs(exports.calcCrossProduct(startX, startY, endX, endY, x, y) / exports.calcDistance(startX, startY, endX, endY));
};
exports.calcCrossProduct = (xA, yA, xB, yB, xC, yC) => {
    return (xB - xA) * (yC - yA) - (yB - yA) * (xC - xA);
};
exports.calcDistance = (x1, y1, x2, y2) => {
    const diffX = x1 - x2;
    const diffY = y1 - y2;
    return Math.sqrt(diffX * diffX + diffY * diffY);
};
exports.testIsInBounds = (x, y, left, top, right, bottom) => {
    return x >= left && x <= right && y >= bottom && y <= top;
};
exports.testIsInXBounds = (xHitTestPoint, xDataPointCoord, maxDistance) => {
    const distance = Math.abs(xHitTestPoint - xDataPointCoord);
    return distance < maxDistance;
};
exports.calcDotProduct = (v1x, v1y, v2x, v2y, v3x, v3y) => (v2x - v1x) * (v3x - v2x) + (v2y - v1y) * (v3y - v2y);
exports.calcDistanceFromLineSegment = (x, y, startX, startY, endX, endY) => {
    if (exports.calcDotProduct(startX, startY, endX, endY, x, y) > 0) {
        return exports.calcDistance(endX, endY, x, y);
    }
    if (exports.calcDotProduct(endX, endY, startX, startY, x, y) > 0) {
        return exports.calcDistance(startX, startY, x, y);
    }
    return exports.calcDistanceFromLine(x, y, startX, startY, endX, endY);
};
