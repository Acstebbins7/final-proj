"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNextRandomPriceBarFactory = exports.getStocksDataFactory = void 0;
const random_1 = require("./random");
/**
 * Creates function to generate stock data
 * @param STEP
 * @param RANDOM_MIN
 * @param RANDOM_MAX
 */
exports.getStocksDataFactory = (STEP, RANDOM_MIN, RANDOM_MAX) => (unixTimestamp, close) => {
    const DEVIATION = 0.7;
    const newTimeStamp = unixTimestamp + STEP;
    const newOpenValue = close;
    const newCloseValue = random_1.getRandomInRange(RANDOM_MIN, RANDOM_MAX, 3);
    const delta = Math.abs(newOpenValue - newCloseValue);
    const maxValue = Math.max(newOpenValue, newCloseValue);
    const newHighValue = random_1.getRandomInRange(maxValue, Math.min(RANDOM_MAX, maxValue + delta * DEVIATION), 3);
    const minValue = Math.min(newOpenValue, newCloseValue);
    const newLowValue = random_1.getRandomInRange(Math.max(RANDOM_MIN, minValue - delta * DEVIATION), minValue, 3);
    return {
        xValue: newTimeStamp,
        openValue: newOpenValue,
        highValue: newHighValue,
        lowValue: newLowValue,
        closeValue: newCloseValue
    };
};
class PriceBar {
    constructor(xValue, openValue, highValue, lowValue, closeValue, volume) {
        this.xValue = xValue;
        this.openValue = openValue;
        this.highValue = highValue;
        this.lowValue = lowValue;
        this.closeValue = closeValue;
        this.volume = volume;
    }
}
exports.getNextRandomPriceBarFactory = (startDateTimestamp, candleIntervalMinutes, simulateDateGap, startPrice) => {
    let currentTimestamp = startDateTimestamp;
    let lastPriceBar = new PriceBar(startDateTimestamp, startPrice, startPrice, startPrice, startPrice, 0);
    return (requestUpdate = false) => {
        const getNextData = () => {
            const open = lastPriceBar.closeValue;
            const num = ((Math.random() - 0.9) * startPrice) / 30;
            const num2 = Math.random();
            const num3 = 0.5 * startPrice +
                (startPrice / 2) * Math.sin(7.27220521664304e-6 * currentTimestamp) +
                (startPrice / 16.0) * Math.cos(7.27220521664304e-5 * currentTimestamp) +
                (startPrice / 32.0) * Math.sin(7.27220521664304e-5 * (10.0 + num2) * currentTimestamp) +
                (startPrice / 64.0) * Math.cos(7.27220521664304e-5 * (20.0 + num2) * currentTimestamp) +
                num;
            const num4 = Math.max(open, num3);
            const num5 = (Math.random() * startPrice) / 100;
            const high = num4 + num5;
            const num6 = Math.min(open, num3);
            const num7 = (Math.random() * startPrice) / 100;
            const low = num6 - num7;
            const volume = Math.random() * 30000 + 20000;
            const openTime = simulateDateGap ? emulateDateGap(lastPriceBar.xValue) : lastPriceBar.xValue;
            const closeTime = openTime + candleIntervalMinutes * 60;
            lastPriceBar = new PriceBar(closeTime, open, high, low, num3, volume);
            currentTimestamp += candleIntervalMinutes * 60;
            return lastPriceBar;
        };
        const getUpdatedData = () => {
            const num = lastPriceBar.closeValue + (Math.random() - 0.48) * (lastPriceBar.closeValue / 100.0);
            const high = num > lastPriceBar.highValue ? num : lastPriceBar.highValue;
            const low = num < lastPriceBar.lowValue ? num : lastPriceBar.lowValue;
            const volumeInc = (Math.random() * 30000 + 20000) * 0.05;
            lastPriceBar = new PriceBar(lastPriceBar.xValue, lastPriceBar.openValue, high, low, num, lastPriceBar.volume + volumeInc);
            return lastPriceBar;
        };
        if (requestUpdate) {
            return getUpdatedData();
        }
        else {
            return getNextData();
        }
    };
};
/** @ignore */
const emulateDateGap = (lastPriceBarTimestamp) => {
    return lastPriceBarTimestamp;
};
