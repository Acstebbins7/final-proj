"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinchZoomModifier = void 0;
const Point_1 = require("../../Core/Point");
const XyDirection_1 = require("../../types/XyDirection");
const ZoomState_1 = require("../../types/ZoomState");
const translate_1 = require("../../utils/translate");
const ChartModifierBase2D_1 = require("./ChartModifierBase2D");
/**
 * The PinchZoomModifier provides ability to zoom by pinch gesture on a 2D {@link SciChartSurface}
 * within SciChart - High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 *
 * To apply the PinchZoomModifier to a {@link SciChartSurface} and add pinch zoom behavior,
 * use the following code:
 *
 * ```ts
 * const sciChartSurface: SciChartSurface;
 * sciChartSurface.chartModifiers.add(new PinchZoomModifier());
 * ```
 */
class PinchZoomModifier extends ChartModifierBase2D_1.ChartModifierBase2D {
    /**
     * Creates an instance of a PinchZoomModifier
     * @param options Optional parameters used to configure the modifier
     */
    constructor(options) {
        var _a, _b;
        super(options);
        /**
         * Defines the sensitivity of zooming in horizontal direction
         */
        this.horizontalGrowFactor = 0.005;
        /**
         * Defines the sensitivity of zooming in vertical direction
         */
        this.verticalGrowFactor = 0.005;
        /**
         * Stores info about active pointerdown events
         */
        this.activeTouchEvents = new Map();
        /**
         * returns a point equidistant to the provided ones
         * @param firstPoint the X,Y location of the first active pointer
         * @param secondPoint the X,Y location of the second active pointer
         */
        this.getMiddlePoint = (firstPoint, secondPoint) => new Point_1.Point((firstPoint.x + secondPoint.x) / 2, (firstPoint.y + secondPoint.y) / 2);
        this.horizontalGrowFactor = (_a = options === null || options === void 0 ? void 0 : options.horizontalGrowFactor) !== null && _a !== void 0 ? _a : this.horizontalGrowFactor;
        this.verticalGrowFactor = (_b = options === null || options === void 0 ? void 0 : options.verticalGrowFactor) !== null && _b !== void 0 ? _b : this.verticalGrowFactor;
    }
    /**
     * @inheritDoc
     */
    modifierMouseDown(args) {
        super.modifierMouseDown(args);
        if (!this.isAttached) {
            throw new Error("Should not call PinchZoomModifier.modifierMouseDown if not attached");
        }
        this.activeTouchEvents.set(args.pointerId, args);
        args.handled = true;
        args.target.setPointerCapture(args.pointerId);
    }
    /**
     * @inheritDoc
     */
    modifierMouseMove(args) {
        super.modifierMouseMove(args);
        this.activeTouchEvents.set(args.pointerId, args);
        // check for pinch gestures if there are multiple active pointers
        if (this.activeTouchEvents.size >= 2) {
            const [{ mousePoint: firstTouchPoint }, { mousePoint: secondTouchPoint }] = Array.from(this.activeTouchEvents.values());
            // Calculate projections of distance between the touch points
            const currentHorizontalTouchPointsDistance = Math.abs(firstTouchPoint.x - secondTouchPoint.x);
            const currentVerticalTouchPointsDistance = Math.abs(firstTouchPoint.y - secondTouchPoint.y);
            this.parentSurface.setZoomState(ZoomState_1.EZoomState.UserZooming);
            const zoomCenterMousePoint = this.getMiddlePoint(firstTouchPoint, secondTouchPoint);
            const zoomPoint = translate_1.translateFromCanvasToSeriesViewRect(zoomCenterMousePoint, this.parentSurface.seriesViewRect);
            if (zoomPoint && this.previousHorizontalTouchPointsDistance !== undefined && this.previousVerticalTouchPointsDistance !== undefined) {
                const horizontalDistanceDiff = this.previousHorizontalTouchPointsDistance - currentHorizontalTouchPointsDistance;
                const verticalDistanceDiff = this.previousVerticalTouchPointsDistance - currentVerticalTouchPointsDistance;
                this.performZoom(zoomPoint, horizontalDistanceDiff, verticalDistanceDiff);
            }
            // Cache the distance for the next move event
            this.previousHorizontalTouchPointsDistance = currentHorizontalTouchPointsDistance;
            this.previousVerticalTouchPointsDistance = currentVerticalTouchPointsDistance;
        }
    }
    /**
     * @inheritDoc
     */
    modifierMouseUp(args) {
        super.modifierMouseUp(args);
        this.removeFromActiveTouchEvents(args);
    }
    /**
     * @inheritDoc
     */
    modifierPointerCancel(args) {
        super.modifierPointerCancel(args);
        this.removeFromActiveTouchEvents(args);
    }
    /**
     * Performs the zoom operation around the mouse point
     * @param mousePoint The X,Y location of the mouse at the time of the zoom
     * @param horizontalPinchDelta horizontal pinch delta
     * @param verticalPinchDelta vertical pinch delta
     */
    performZoom(mousePoint, horizontalPinchDelta, verticalPinchDelta) {
        const horizontalFraction = this.horizontalGrowFactor * horizontalPinchDelta;
        const verticalFraction = this.verticalGrowFactor * verticalPinchDelta;
        if ([XyDirection_1.EXyDirection.XDirection, XyDirection_1.EXyDirection.XyDirection].includes(this.xyDirection)) {
            this.parentSurface.xAxes.asArray().forEach(axis => {
                this.growBy(mousePoint, axis, horizontalFraction);
            });
        }
        if ([XyDirection_1.EXyDirection.YDirection, XyDirection_1.EXyDirection.XyDirection].includes(this.xyDirection)) {
            this.parentSurface.yAxes.asArray().forEach(axis => {
                this.growBy(mousePoint, axis, verticalFraction);
            });
        }
    }
    /**
     * Grows the Axis by a fraction around the mouse point
     * @param mousePoint the X,Y location of the mouse at the time of the operation
     * @param axis the Axis to grow or shrink
     * @param fraction the fraction, e.g. 0.1 grows the axis by 10%
     */
    growBy(mousePoint, axis, fraction) {
        const { isHorizontalAxis, isAxisFlipped, viewRect, flippedCoordinates } = axis;
        const size = isHorizontalAxis ? viewRect.width : viewRect.height;
        const coord = isHorizontalAxis ? mousePoint.x : mousePoint.y;
        // Compute relative fractions to expand or contract the axis VisibleRange by
        const lowFraction = (coord / size) * fraction;
        const highFraction = (1 - coord / size) * fraction;
        // We flip zoom for vertical chart or flippedCoordinates
        const flipZoom = (isAxisFlipped && !flippedCoordinates) || (!isAxisFlipped && flippedCoordinates);
        if (flipZoom) {
            axis.zoomBy(highFraction, lowFraction);
        }
        else {
            axis.zoomBy(lowFraction, highFraction);
        }
    }
    notifyPropertyChanged(propertyName) {
        super.notifyPropertyChanged(propertyName);
    }
    /**
     * Handles pointer event becoming inactive
     * @param args pointer event properties
     */
    removeFromActiveTouchEvents(args) {
        // Remove this event from the target's cache
        this.activeTouchEvents.delete(args.pointerId);
        args.target.releasePointerCapture(args.pointerId);
        // reset distance values
        if (this.activeTouchEvents.size < 2) {
            this.previousHorizontalTouchPointsDistance = undefined;
            this.previousVerticalTouchPointsDistance = undefined;
        }
    }
}
exports.PinchZoomModifier = PinchZoomModifier;
