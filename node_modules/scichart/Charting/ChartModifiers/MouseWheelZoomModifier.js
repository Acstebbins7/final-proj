"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MouseWheelZoomModifier = void 0;
const XyDirection_1 = require("../../types/XyDirection");
const translate_1 = require("../../utils/translate");
const ChartModifierBase2D_1 = require("./ChartModifierBase2D");
/**
 * The MouseWheelZoomModifier provides Mouse wheel zooming behavior on a 2D {@link SciChartSurface}
 * within SciChart - High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 *
 * To apply the MouseWheelZoomModifier to a {@link SciChartSurface} and add Mouse-wheel zoom behavior,
 * use the following code:
 *
 * ```ts
 * const sciChartSurface: SciChartSurface;
 * sciChartSurface.chartModifiers.add(new MouseWheelZoomModifier());
 * ```
 *
 * The speed of mouse-wheel zoom can be modified via the {@link MouseWheelZoomModifier.growFactor} property.
 */
class MouseWheelZoomModifier extends ChartModifierBase2D_1.ChartModifierBase2D {
    /**
     * Creates an instance of MouseWheelZoomModifier
     * @param options Optional parameters to configure the modifier via {@link IMouseWheelZoomModifierOptions}
     */
    constructor(options) {
        super(options);
        this.growFactor = (options === null || options === void 0 ? void 0 : options.growFactor) || 0.001;
    }
    /**
     * @inheritDoc
     */
    modifierMouseWheel(args) {
        super.modifierMouseWheel(args);
        args.handled = true;
        const zoomPoint = translate_1.translateFromCanvasToSeriesViewRect(args.mousePoint, this.parentSurface.seriesViewRect);
        if (zoomPoint) {
            this.performZoom(zoomPoint, args.mouseWheelDelta);
        }
    }
    /**
     * Performs the zoom operation around the mouse point
     * @param mousePoint The X,Y location of the mouse at the time of the zoom
     * @param wheelDelta the MouseWheel delta
     */
    performZoom(mousePoint, wheelDelta) {
        const fraction = this.growFactor * wheelDelta;
        if ([XyDirection_1.EXyDirection.XDirection, XyDirection_1.EXyDirection.XyDirection].includes(this.xyDirection)) {
            this.parentSurface.xAxes.asArray().forEach(axis => {
                this.growBy(mousePoint, axis, fraction);
            });
        }
        if ([XyDirection_1.EXyDirection.YDirection, XyDirection_1.EXyDirection.XyDirection].includes(this.xyDirection)) {
            this.parentSurface.yAxes.asArray().forEach(axis => {
                this.growBy(mousePoint, axis, fraction);
            });
        }
    }
    /**
     * Grows the Axis by a fraction around the mouse point
     * @param mousePoint the X,Y location of the mouse at the time of the operation
     * @param axis the Axis to grow or shrink
     * @param fraction the fraction, e.g. 0.1 grows the axis by 10%
     */
    growBy(mousePoint, axis, fraction) {
        const { isHorizontalAxis, isAxisFlipped, viewRect, flippedCoordinates } = axis;
        const size = isHorizontalAxis ? viewRect.width : viewRect.height;
        const coord = isHorizontalAxis ? mousePoint.x : mousePoint.y;
        // Compute relative fractions to expand or contract the axis VisibleRange by
        const lowFraction = (coord / size) * fraction;
        const highFraction = (1 - coord / size) * fraction;
        // We flip zoom for vertical chart or flippedCoordinates
        const flipZoom = (isAxisFlipped && !flippedCoordinates) || (!isAxisFlipped && flippedCoordinates);
        if (flipZoom) {
            axis.zoomBy(highFraction, lowFraction);
        }
        else {
            axis.zoomBy(lowFraction, highFraction);
        }
    }
}
exports.MouseWheelZoomModifier = MouseWheelZoomModifier;
