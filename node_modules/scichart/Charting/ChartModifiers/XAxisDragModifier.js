"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XAxisDragModifier = void 0;
const CursorStyle_1 = require("../../types/CursorStyle");
const DragMode_1 = require("../../types/DragMode");
const translate_1 = require("../../utils/translate");
const AxisBase2D_1 = require("../Visuals/Axis/AxisBase2D");
const ChartModifierBase2D_1 = require("./ChartModifierBase2D");
const ChartModifierBase2D_2 = require("./ChartModifierBase2D");
/**
 * The XAxisDragModifier provides scaling/panning behavior for X axis {@link AxisBase2D}
 * within SciChart - High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 *
 * To apply the XAxisDragModifier to a {@link SciChartSurface} and add scaling behavior,
 * use the following code:
 *
 * ```ts
 * sciChartSurface.chartModifiers.add(new XAxisDragModifier());
 * ```
 */
class XAxisDragModifier extends ChartModifierBase2D_1.ChartModifierBase2D {
    /**
     * Creates an instance of a XAxisDragModifier
     * @param options optional parameters to pass to the XAxisDragModifier to configure it upon construction
     */
    constructor(options) {
        var _a;
        super(options);
        this.dragMode = DragMode_1.EDragMode.Scaling;
        this.isClickedOverXAxis = false;
        this.isVerticalChart = false;
        this.dragMode = (_a = options === null || options === void 0 ? void 0 : options.dragMode) !== null && _a !== void 0 ? _a : this.dragMode;
    }
    /**
     * @inheritDoc
     */
    modifierMouseDown(args) {
        super.modifierMouseDown(args);
        if (!this.isAttached) {
            throw new Error("Should not call XAxisDragModifier.modifierMouseDown if not attached");
        }
        if (ChartModifierBase2D_1.testIsOverAxes(this.getHorizontalXAxes(), args.mousePoint)) {
            // Horizontal chart
            this.isVerticalChart = false;
            this.startDragging(this.getHorizontalXAxes(), args);
        }
        else if (ChartModifierBase2D_1.testIsOverAxes(this.getVerticalXAxes(), args.mousePoint)) {
            // Vertical chart
            this.isVerticalChart = true;
            this.startDragging(this.getVerticalXAxes(), args);
        }
    }
    /**
     * @inheritDoc
     */
    modifierMouseMove(args) {
        if (this.isClickedOverXAxis) {
            super.modifierMouseMove(args);
            if (this.pointFrom === undefined) {
                return;
            }
            if (this.dragMode === DragMode_1.EDragMode.Panning) {
                this.doPanning(args.mousePoint);
            }
            else if (this.dragMode === DragMode_1.EDragMode.Scaling) {
                this.doScaling(args.mousePoint);
            }
        }
        else {
            this.updateCursor(args.mousePoint);
        }
    }
    /**
     * @inheritDoc
     */
    modifierMouseUp(args) {
        super.modifierMouseUp(args);
        this.updateCursor(args.mousePoint);
        this.pointFrom = undefined;
        this.isClickedOverXAxis = false;
        args.target.releasePointerCapture(args.pointerId);
    }
    updateCursor(mousePoint) {
        const canvas = this.parentSurface.getMainCanvas();
        if (ChartModifierBase2D_1.testIsOverAxes(this.getHorizontalXAxes(), mousePoint)) {
            if (this.cursorStyle !== CursorStyle_1.ECursorStyle.EW) {
                canvas.style.cursor = CursorStyle_1.ECursorStyle.EW;
                this.cursorStyle = CursorStyle_1.ECursorStyle.EW;
            }
        }
        else if (ChartModifierBase2D_1.testIsOverAxes(this.getVerticalXAxes(), mousePoint)) {
            if (this.cursorStyle !== CursorStyle_1.ECursorStyle.NS) {
                canvas.style.cursor = CursorStyle_1.ECursorStyle.NS;
                this.cursorStyle = CursorStyle_1.ECursorStyle.NS;
            }
        }
        else {
            if (this.cursorStyle !== CursorStyle_1.ECursorStyle.Defalut) {
                canvas.style.cursor = CursorStyle_1.ECursorStyle.Defalut;
                this.cursorStyle = CursorStyle_1.ECursorStyle.Defalut;
            }
        }
    }
    doPanning(mousePoint) {
        const pointTo = mousePoint;
        if (this.isVerticalChart) {
            const yDelta = pointTo.y - this.pointFrom.y;
            this.activeAxes.forEach(x => {
                const delta = x.flippedCoordinates ? -yDelta : yDelta;
                x.scroll(delta, AxisBase2D_1.EClipMode.None);
            });
        }
        else {
            const xDelta = pointTo.x - this.pointFrom.x;
            this.activeAxes.forEach(x => {
                const delta = x.flippedCoordinates ? -xDelta : xDelta;
                x.scroll(delta, AxisBase2D_1.EClipMode.None);
            });
        }
        this.pointFrom = pointTo;
    }
    doScaling(pointTo) {
        const { seriesViewRect } = this.parentSurface;
        if (this.isVerticalChart) {
            const yFromTrans = translate_1.translateFromCanvasToSeriesViewRectY(this.pointFrom.y, seriesViewRect);
            const isMoreThanHalf = yFromTrans >= seriesViewRect.height / 2;
            const yDelta = (pointTo.y - this.pointFrom.y) / seriesViewRect.width;
            ChartModifierBase2D_2.scaleAxes(this.activeAxes, this.initialVisibleRanges, yDelta, isMoreThanHalf);
        }
        else {
            const xFromTrans = translate_1.translateFromCanvasToSeriesViewRectX(this.pointFrom.x, seriesViewRect);
            const isMoreThanHalf = xFromTrans >= seriesViewRect.width / 2;
            const xDelta = (pointTo.x - this.pointFrom.x) / seriesViewRect.width;
            ChartModifierBase2D_2.scaleAxes(this.activeAxes, this.initialVisibleRanges, xDelta, isMoreThanHalf);
        }
    }
    getHorizontalXAxes() {
        return this.parentSurface.xAxes.asArray().filter(el => el.isHorizontalAxis);
    }
    getVerticalXAxes() {
        return this.parentSurface.xAxes.asArray().filter(el => !el.isHorizontalAxis);
    }
    startDragging(axes, args) {
        this.isClickedOverXAxis = true;
        const activeAxes = ChartModifierBase2D_1.getActiveAxes(axes, args.mousePoint);
        const initialVisibleRanges = [];
        activeAxes.forEach(el => {
            initialVisibleRanges.push(el.visibleRange);
        });
        this.activeAxes = activeAxes;
        this.initialVisibleRanges = initialVisibleRanges;
        this.pointFrom = args.mousePoint;
        args.handled = true;
        args.target.setPointerCapture(args.pointerId);
    }
}
exports.XAxisDragModifier = XAxisDragModifier;
