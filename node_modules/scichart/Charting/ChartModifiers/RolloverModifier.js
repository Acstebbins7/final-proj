"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RolloverModifier = void 0;
const SeriesType_1 = require("../../types/SeriesType");
const translate_1 = require("../../utils/translate");
const defaultThemeColors_1 = require("../Themes/defaultThemeColors");
const AnnotationBase_1 = require("../Visuals/Annotations/AnnotationBase");
const LineAnnotation_1 = require("../Visuals/Annotations/LineAnnotation");
const MarkerSvgAnnotation_1 = require("../Visuals/Annotations/MarkerSvgAnnotation");
const TooltipSvgAnnotation_1 = require("../Visuals/Annotations/TooltipSvgAnnotation");
const BaseRenderableSeries_1 = require("../Visuals/RenderableSeries/BaseRenderableSeries");
const BaseHitTestProvider_1 = require("../Visuals/RenderableSeries/HitTest/BaseHitTestProvider");
const IHitTestProvider_1 = require("../Visuals/RenderableSeries/HitTest/IHitTestProvider");
const ChartModifierBase2D_1 = require("./ChartModifierBase2D");
const constants_1 = require("./constants");
/**
 * @ignore
 * Defines the MousePosition enum constants, used by the {@link RolloverModifier}
 */
var EMousePosition;
(function (EMousePosition) {
    /**
     * The mouse position is outside the main canvas
     */
    EMousePosition["OutOfCanvas"] = "OutOfCanvas";
    /**
     * The mouse position is in the Axis area
     */
    EMousePosition["AxisArea"] = "AxisArea";
    /**
     * The mouse position is in the Series area
     */
    EMousePosition["SeriesArea"] = "SeriesArea";
})(EMousePosition || (EMousePosition = {}));
/** @ignore */
const TOOLTIP_PADDING_TOP = 4;
/**
 * The RolloverModifier provides tooltip and cursor behavior on a 2D {@link SciChartSurface}
 * within SciChart - High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 *
 * To apply the RolloverModifier to a {@link SciChartSurface} and add tooltip behavior,
 * use the following code:
 *
 * ```ts
 * const sciChartSurface: SciChartSurface;
 * sciChartSurface.chartModifiers.add(new RolloverModifier());
 * ```
 */
class RolloverModifier extends ChartModifierBase2D_1.ChartModifierBase2D {
    /**
     * Creates an instance of the RolloverModifier
     * @param options Optional parameters {@link IRolloverModifierOptions} used to configure the modifier
     */
    constructor(options) {
        var _a, _b, _c, _d;
        super(options);
        this.mousePosition = EMousePosition.OutOfCanvas;
        this.isVerticalChart = false;
        this.isVerticalChart = (_a = options === null || options === void 0 ? void 0 : options.isVerticalChart) !== null && _a !== void 0 ? _a : this.isVerticalChart;
        this.rolloverLineAnnotation = new LineAnnotation_1.LineAnnotation({
            xCoordinateMode: AnnotationBase_1.ECoordinateMode.Pixel,
            yCoordinateMode: AnnotationBase_1.ECoordinateMode.Pixel,
            strokeThickness: (_b = options === null || options === void 0 ? void 0 : options.rolloverLineStrokeThickness) !== null && _b !== void 0 ? _b : 2,
            stroke: (_c = options === null || options === void 0 ? void 0 : options.rolloverLineStroke) !== null && _c !== void 0 ? _c : defaultThemeColors_1.defaultThemeColors.cursorLineBrush,
            isHidden: true
        });
        this.showRolloverLineProperty = (_d = options === null || options === void 0 ? void 0 : options.showRolloverLine) !== null && _d !== void 0 ? _d : true;
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        if (this.parentSurface) {
            const previousThemeProvider = this.parentSurface.previousThemeProvider;
            if (this.rolloverLineAnnotation.stroke === previousThemeProvider.cursorLineBrush) {
                this.rolloverLineAnnotation.stroke = themeProvider.cursorLineBrush;
            }
        }
    }
    get rolloverLineStroke() {
        return this.rolloverLineAnnotation.stroke;
    }
    set rolloverLineStroke(rolloverLineStroke) {
        this.rolloverLineAnnotation.stroke = rolloverLineStroke;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE);
    }
    get rolloverLineStrokeThickness() {
        return this.rolloverLineAnnotation.strokeThickness;
    }
    set rolloverLineStrokeThickness(rolloverLineStrokeThickness) {
        this.rolloverLineAnnotation.strokeThickness = rolloverLineStrokeThickness;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE_THICKNESS);
    }
    get showRolloverLine() {
        return this.showRolloverLineProperty;
    }
    set showRolloverLine(showRolloverLine) {
        this.showRolloverLineProperty = showRolloverLine;
        this.notifyPropertyChanged(constants_1.PROPERTY.SHOW_ROLLOVER_LINE);
    }
    /**
     * @inheritDoc
     */
    onAttach() {
        super.onAttach();
        this.parentSurface.modifierAnnotations.add(this.rolloverLineAnnotation);
        this.getSeriesWithRollover().forEach((rs, index) => {
            this.addSeriesAnnotationsToParentSurface(rs, index);
        });
    }
    /**
     * @inheritDoc
     */
    onDetach() {
        super.onDetach();
        this.rolloverLineAnnotation.delete();
        this.parentSurface.modifierAnnotations.remove(this.rolloverLineAnnotation);
        this.getSeriesWithRollover().forEach(rs => {
            this.removeSeriesAnnotationsFromParentSurface(rs);
        });
    }
    /**
     * @inheritDoc
     */
    onAttachSeries(rs) {
        super.onAttachSeries(rs);
        const index = this.parentSurface.renderableSeries.size() - 1;
        this.addSeriesAnnotationsToParentSurface(rs, index);
    }
    /**
     * @inheritDoc
     */
    onDetachSeries(rs) {
        super.onDetachSeries(rs);
        this.removeSeriesAnnotationsFromParentSurface(rs);
    }
    /**
     * @inheritDoc
     */
    modifierMouseMove(args) {
        super.modifierMouseMove(args);
        let translatedMousePoint;
        if (!this.mousePoint) {
            this.mousePosition = EMousePosition.OutOfCanvas;
        }
        else {
            translatedMousePoint = translate_1.translateFromCanvasToSeriesViewRect(this.mousePoint, this.parentSurface.seriesViewRect);
            if (!translatedMousePoint) {
                this.mousePosition = EMousePosition.AxisArea;
            }
            else {
                this.mousePosition = EMousePosition.SeriesArea;
            }
        }
        this.update();
    }
    /**
     * @inheritDoc
     */
    modifierMouseLeave(args) {
        super.modifierMouseLeave(args);
        this.mousePosition = EMousePosition.OutOfCanvas;
        this.update();
    }
    /**
     * @inheritDoc
     */
    modifierMouseEnter(args) {
        super.modifierMouseEnter(args);
    }
    /**
     * @inheritDoc
     */
    onParentSurfaceRendered() {
        this.update();
    }
    removeSeriesAnnotationsFromParentSurface(rs) {
        if (rs.isStacked) {
            const stackedSeries = rs;
            stackedSeries.asArray().forEach(childRs => {
                childRs.rolloverModifierProps.marker.delete();
                this.parentSurface.modifierAnnotations.remove(childRs.rolloverModifierProps.marker);
                childRs.rolloverModifierProps.tooltip.delete();
                this.parentSurface.modifierAnnotations.remove(childRs.rolloverModifierProps.tooltip);
                childRs.rolloverModifierProps.delete();
            });
        }
        else {
            rs.rolloverModifierProps.marker.delete();
            this.parentSurface.modifierAnnotations.remove(rs.rolloverModifierProps.marker);
            rs.rolloverModifierProps.tooltip.delete();
            this.parentSurface.modifierAnnotations.remove(rs.rolloverModifierProps.tooltip);
            if (rs.type === SeriesType_1.ESeriesType.BandSeries) {
                rs.rolloverModifierProps1.marker.delete();
                this.parentSurface.modifierAnnotations.remove(rs.rolloverModifierProps1.marker);
                rs.rolloverModifierProps1.tooltip.delete();
                this.parentSurface.modifierAnnotations.remove(rs.rolloverModifierProps1.tooltip);
            }
            rs.rolloverModifierProps.delete();
        }
    }
    /**
     * @param rs
     * @param index Is used for default tooltip title, e.g. "Series 1"
     */
    addSeriesAnnotationsToParentSurface(rs, index) {
        createAnnotations(rs, index);
        this.parentSurface.modifierAnnotations.add(rs.rolloverModifierProps.marker);
        this.parentSurface.modifierAnnotations.add(rs.rolloverModifierProps.tooltip);
        if (rs.type === SeriesType_1.ESeriesType.BandSeries) {
            this.parentSurface.modifierAnnotations.add(rs.rolloverModifierProps1.marker);
            this.parentSurface.modifierAnnotations.add(rs.rolloverModifierProps1.tooltip);
        }
    }
    getSeriesWithRollover() {
        const regularSeries = this.parentSurface.renderableSeries
            .asArray()
            .filter(el => { var _a; return el.isVisible && !el.isStacked && el.rolloverModifierProps.showRollover && ((_a = el.dataSeries) === null || _a === void 0 ? void 0 : _a.count()) > 0; });
        const stackedSeries = this.parentSurface.renderableSeries.asArray().filter(el => el.isStacked);
        const result = regularSeries;
        stackedSeries.forEach(rs => {
            rs.getVisibleSeries().forEach(childRs => {
                if (childRs.rolloverModifierProps.showRollover) {
                    result.push(childRs);
                }
            });
        });
        return result;
    }
    update() {
        this.updateLine();
        this.updateSeriesAnnotations();
    }
    updateLine() {
        if (this.mousePosition !== EMousePosition.SeriesArea) {
            this.rolloverLineAnnotation.isHidden = true;
            return;
        }
        this.rolloverLineAnnotation.isHidden = !this.showRolloverLineProperty;
        const translatedMousePoint = translate_1.translateFromCanvasToSeriesViewRect(this.mousePoint, this.parentSurface.seriesViewRect);
        if (translatedMousePoint) {
            if (this.isVerticalChart) {
                this.rolloverLineAnnotation.y1 = translatedMousePoint.y;
                this.rolloverLineAnnotation.y2 = translatedMousePoint.y;
                this.rolloverLineAnnotation.x1 = 0;
                this.rolloverLineAnnotation.x2 = this.parentSurface.seriesViewRect.right;
            }
            else {
                this.rolloverLineAnnotation.y1 = 0;
                this.rolloverLineAnnotation.y2 = this.parentSurface.seriesViewRect.bottom;
                this.rolloverLineAnnotation.x1 = translatedMousePoint.x;
                this.rolloverLineAnnotation.x2 = translatedMousePoint.x;
            }
        }
    }
    /**
     * @description Update Markers and Tooltips
     */
    updateSeriesAnnotations() {
        const rsList = this.getSeriesWithRollover();
        rsList.forEach((rs, index) => {
            rs.rolloverModifierProps.marker.isHidden = true;
            rs.rolloverModifierProps.tooltip.isHidden = true;
            rs.rolloverModifierProps.tooltip.x1 = undefined;
            rs.rolloverModifierProps.tooltip.y1 = undefined;
            if (rs.type === SeriesType_1.ESeriesType.BandSeries) {
                rs.rolloverModifierProps1.marker.isHidden = true;
                rs.rolloverModifierProps1.tooltip.isHidden = true;
                rs.rolloverModifierProps1.tooltip.x1 = undefined;
                rs.rolloverModifierProps1.tooltip.y1 = undefined;
            }
        });
        if (this.mousePosition !== EMousePosition.SeriesArea) {
            return;
        }
        const tooltipPositions = calcTooltipPositions(this.mousePoint, rsList, this.parentSurface.seriesViewRect, TOOLTIP_PADDING_TOP);
        tooltipPositions.forEach(el => {
            const rs = rsList[el.index];
            const isOutOfDataRange = !el.hitTestPointValues || rs.checkIsOutOfDataRange(el.hitTestPointValues.x, el.hitTestPointValues.y);
            // if mouse value is out of [xMin, xMax] hide tooltips
            // for StackedColumnSeries because of the specific we always show the tooltips
            if (!isOutOfDataRange || rs.type === SeriesType_1.ESeriesType.StackedColumnSeries) {
                if (el.isY1) {
                    updateRolloverModifierProps(rs.rolloverModifierProps1, rs, el);
                }
                else {
                    updateRolloverModifierProps(rs.rolloverModifierProps, rs, el);
                }
            }
        });
    }
}
exports.RolloverModifier = RolloverModifier;
// TODO: write tests
/** @ignore */
const calcTooltipPositions = (mousePoint, rsList, seriesViewRect, paddingTop) => {
    const res = [];
    rsList.forEach((rs, index) => {
        const hitTestInfo = rs.hitTestProvider.hitTest(mousePoint, IHitTestProvider_1.ENearestPointLogic.NearestHorizontalPoint, BaseHitTestProvider_1.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS, false);
        if (hitTestInfo) {
            const seriesInfo = BaseRenderableSeries_1.getSeriesInfo(rs, hitTestInfo);
            const width = rs.rolloverModifierProps.tooltip.width;
            const height = rs.rolloverModifierProps.tooltip.height;
            const xDeltaCoord = seriesViewRect.width - hitTestInfo.xCoord < width ? -width : 5;
            const newRecord = {
                index,
                xValue: hitTestInfo.xValue,
                yValue: hitTestInfo.yValue,
                xCoord: hitTestInfo.xCoord,
                yCoord: hitTestInfo.yCoord,
                hitTestPointValues: hitTestInfo.hitTestPointValues,
                isCategoryAxis: hitTestInfo.isCategoryAxis,
                xDeltaCoord,
                yDeltaCoord: -height / 2,
                isY1: false,
                height,
                seriesInfo
            };
            if (rs.type !== SeriesType_1.ESeriesType.StackedColumnSeries || hitTestInfo.isHit) {
                res.push(newRecord);
            }
            if (rs.type === SeriesType_1.ESeriesType.BandSeries) {
                const width1 = rs.rolloverModifierProps1.tooltip.width;
                const height1 = rs.rolloverModifierProps1.tooltip.height;
                const seriesInfo1 = BaseRenderableSeries_1.getSeriesInfo(rs, hitTestInfo);
                seriesInfo1.isFirstSeries = false;
                res.push(Object.assign(Object.assign({}, newRecord), { isY1: true, yValue: hitTestInfo.y1Value, yCoord: hitTestInfo.y1Coord, xDeltaCoord: seriesViewRect.width - hitTestInfo.xCoord < width1 ? -width1 : 5, yDeltaCoord: -height1 / 2, height: height1, seriesInfo: seriesInfo1 }));
            }
        }
    });
    const orderedRes = res.sort((a, b) => (a.yCoord > b.yCoord ? 1 : b.yCoord > a.yCoord ? -1 : 0));
    const length = res.length;
    if (length >= 2) {
        const deltaYCoord = res[length - 1].yCoord - res[0].yCoord;
        const centerY = res[0].yCoord + deltaYCoord / 2;
        let hasOverlap = false;
        for (let i = 0; i < length - 1; i++) {
            const orderedRes0 = orderedRes[i];
            const orderedResRS0 = rsList[orderedRes0.index];
            const orderedRes1 = orderedRes[i + 1];
            const orderedResRS1 = rsList[orderedRes1.index];
            const minDist = paddingTop +
                orderedResRS0.rolloverModifierProps.tooltip.height / 2 +
                orderedResRS1.rolloverModifierProps.tooltip.height / 2;
            if (orderedRes[i + 1].yCoord - orderedRes[i].yCoord < minDist) {
                hasOverlap = true;
                break;
            }
        }
        if (hasOverlap) {
            const totalHeight = orderedRes.reduce((prev, cur) => {
                let res2 = prev + cur.height;
                if (prev !== 0) {
                    res2 += paddingTop;
                }
                return res2;
            }, 0);
            const initialY = centerY - totalHeight / 2;
            let prevEl;
            let prevSum = 0;
            orderedRes.forEach((el, index) => {
                if (index === 0) {
                    prevSum = initialY;
                    el.yDeltaCoord = prevSum - el.yCoord;
                }
                else {
                    prevSum += prevEl.height + paddingTop;
                    el.yDeltaCoord = prevSum - el.yCoord;
                }
                prevEl = el;
            });
        }
    }
    return orderedRes;
};
/**
 * @ignore
 * @description Creates MarkerAnnotation and TooltipAnnotation and assigns to rolloverSeries properties
 * @param rs RenderableSeries
 * @param seriesIndex
 */
const createAnnotations = (rs, seriesIndex) => {
    var _a, _b, _c, _d, _e, _f;
    console.log(rs.rolloverModifierProps);
    if (!rs.rolloverModifierProps.marker) {
        rs.rolloverModifierProps.marker = new MarkerSvgAnnotation_1.MarkerSvgAnnotation(rs.rolloverModifierProps);
        // Rollover tooltips for multiple Y-Axes are not supported for stacked series
        if (!rs.isStacked) {
            rs.rolloverModifierProps.marker.xAxisId = rs.xAxisId;
            rs.rolloverModifierProps.marker.yAxisId = rs.yAxisId;
        }
    }
    if (!rs.rolloverModifierProps.tooltip) {
        rs.rolloverModifierProps.tooltipTitle = (_b = (_a = rs.rolloverModifierProps.tooltipTitle) !== null && _a !== void 0 ? _a : rs.getDataSeriesName()) !== null && _b !== void 0 ? _b : "";
        rs.rolloverModifierProps.tooltipColor = (_c = rs.rolloverModifierProps.tooltipColor) !== null && _c !== void 0 ? _c : rs.stroke;
        rs.rolloverModifierProps.tooltip = new TooltipSvgAnnotation_1.TooltipSvgAnnotation(rs.rolloverModifierProps, { seriesType: rs.type });
        // Rollover tooltips for multiple Y-Axes are not supported for stacked series
        if (!rs.isStacked) {
            rs.rolloverModifierProps.tooltip.xAxisId = rs.xAxisId;
            rs.rolloverModifierProps.tooltip.yAxisId = rs.yAxisId;
        }
    }
    if (rs.type === SeriesType_1.ESeriesType.BandSeries) {
        const bandRs = rs;
        if (!bandRs.rolloverModifierProps1.marker) {
            bandRs.rolloverModifierProps1.marker = new MarkerSvgAnnotation_1.MarkerSvgAnnotation(bandRs.rolloverModifierProps1);
            bandRs.rolloverModifierProps1.marker.xAxisId = bandRs.xAxisId;
            bandRs.rolloverModifierProps1.marker.yAxisId = bandRs.yAxisId;
        }
        if (!bandRs.rolloverModifierProps1.tooltip) {
            bandRs.rolloverModifierProps1.tooltipTitle = (_e = (_d = bandRs.rolloverModifierProps1.tooltipTitle) !== null && _d !== void 0 ? _d : bandRs.getDataSeriesName()) !== null && _e !== void 0 ? _e : "";
            bandRs.rolloverModifierProps1.tooltipColor = (_f = bandRs.rolloverModifierProps1.tooltipColor) !== null && _f !== void 0 ? _f : bandRs.strokeY1;
            bandRs.rolloverModifierProps1.tooltip = new TooltipSvgAnnotation_1.TooltipSvgAnnotation(bandRs.rolloverModifierProps1);
            bandRs.rolloverModifierProps1.tooltip.xAxisId = bandRs.xAxisId;
            bandRs.rolloverModifierProps1.tooltip.yAxisId = bandRs.yAxisId;
        }
    }
};
/** @ignore */
const updateRolloverModifierProps = (rolloverRSProps, rs, tooltipProps) => {
    rolloverRSProps.marker.isHidden = false;
    rolloverRSProps.marker.x1 = tooltipProps.xValue;
    rolloverRSProps.marker.y1 = tooltipProps.yValue;
    // Update tooltips
    rolloverRSProps.tooltip.isHidden = false;
    rolloverRSProps.tooltip.x1 = tooltipProps.xValue;
    rolloverRSProps.tooltip.y1 = tooltipProps.yValue;
    rolloverRSProps.tooltip.seriesInfo = tooltipProps.seriesInfo;
    rolloverRSProps.tooltip.xCoordShift = tooltipProps.xDeltaCoord;
    rolloverRSProps.tooltip.yCoordShift = tooltipProps.yDeltaCoord;
};
