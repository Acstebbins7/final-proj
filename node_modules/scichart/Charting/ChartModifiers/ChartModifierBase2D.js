"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaleAxes = exports.getActiveAxes = exports.testIsOverAxes = exports.ChartModifierBase2D = void 0;
const NumberRange_1 = require("../../Core/NumberRange");
const XyDirection_1 = require("../../types/XyDirection");
const pointUtil_1 = require("../../utils/pointUtil");
const ChartModifierBase_1 = require("./ChartModifierBase");
/**
 * Defines a base class to a ChartModifier2D - a class which provides Zoom, Pan, Tooltip or interaction behavior
 * to SciChart - High Performance Realtime {@link https://www.scichart.com/javascript-chart-features | 2D JavaScript Charts}
 */
class ChartModifierBase2D extends ChartModifierBase_1.ChartModifierBase {
    /**
     * Creates an instance of the {@link ChartModifierBase2D}
     * @param options optional parameters via {@link IChartModifierBaseOptions} which can be passed to configure the modifier
     */
    constructor(options) {
        var _a, _b, _c;
        super();
        this.xyDirection = XyDirection_1.EXyDirection.XyDirection;
        this.changedPropertiesList = [];
        this.executeOn = (_a = options === null || options === void 0 ? void 0 : options.executeOn) !== null && _a !== void 0 ? _a : this.executeOn;
        this.xyDirection = (_b = options === null || options === void 0 ? void 0 : options.xyDirection) !== null && _b !== void 0 ? _b : this.xyDirection;
        this.modifierGroup = (_c = options === null || options === void 0 ? void 0 : options.modifierGroup) !== null && _c !== void 0 ? _c : this.modifierGroup;
    }
    /**
     * @inheritDoc
     */
    get modifierType() {
        return ChartModifierBase_1.EModifierType.Chart2DModifier;
    }
    testPropertyChanged(propertyName) {
        return this.changedPropertiesList.includes(propertyName);
    }
    notifyPropertyChanged(propertyName) {
        if (!this.changedPropertiesList.includes(propertyName)) {
            this.changedPropertiesList.push(propertyName);
        }
    }
}
exports.ChartModifierBase2D = ChartModifierBase2D;
exports.testIsOverAxes = (xAxisArr, mousePoint) => {
    let result = false;
    xAxisArr.forEach(x => {
        if (x.viewRect) {
            const { left, right, top, bottom } = x.viewRect;
            if (pointUtil_1.testIsInBounds(mousePoint.x, mousePoint.y, left, bottom, right, top)) {
                result = true;
            }
        }
    });
    return result;
};
exports.getActiveAxes = (xAxisArr, mousePoint) => {
    const result = [];
    xAxisArr.forEach(x => {
        if (x.viewRect) {
            const { left, right, top, bottom } = x.viewRect;
            if (pointUtil_1.testIsInBounds(mousePoint.x, mousePoint.y, left, bottom, right, top)) {
                result.push(x);
            }
        }
    });
    return result;
};
exports.scaleAxes = (axes, initialVisibleRanges, delta, isMoreThanHalf) => {
    axes.forEach((currentAxis, index) => {
        const initialRange = initialVisibleRanges[index];
        const deltaRange = initialRange.max - initialRange.min;
        let newMin, newMax;
        // Respect flippedCoordinates
        const isMoreThanHalf2 = currentAxis.flippedCoordinates ? !isMoreThanHalf : isMoreThanHalf;
        const delta2 = currentAxis.flippedCoordinates ? -delta : delta;
        if (isMoreThanHalf2) {
            newMin = initialRange.min;
            newMax = delta2 > 0 ? newMin + deltaRange / (1 + delta2) : newMin + deltaRange * (1 + Math.abs(delta2));
        }
        else {
            newMax = initialRange.max;
            newMin = delta2 > 0 ? newMax - deltaRange * (1 + delta2) : newMax - deltaRange / (1 + Math.abs(delta2));
        }
        currentAxis.visibleRange = new NumberRange_1.NumberRange(newMin, newMax);
    });
};
