"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CursorModifier = void 0;
const translate_1 = require("../../utils/translate");
const IDataSeries_1 = require("../Model/IDataSeries");
const defaultThemeColors_1 = require("../Themes/defaultThemeColors");
const AnnotationBase_1 = require("../Visuals/Annotations/AnnotationBase");
const CursorTooltipSvgAnnotation_1 = require("../Visuals/Annotations/CursorTooltipSvgAnnotation");
const LineAnnotation_1 = require("../Visuals/Annotations/LineAnnotation");
const BaseRenderableSeries_1 = require("../Visuals/RenderableSeries/BaseRenderableSeries");
const BaseHitTestProvider_1 = require("../Visuals/RenderableSeries/HitTest/BaseHitTestProvider");
const IHitTestProvider_1 = require("../Visuals/RenderableSeries/HitTest/IHitTestProvider");
const ChartModifierBase2D_1 = require("./ChartModifierBase2D");
const constants_1 = require("./constants");
/**
 * @ignore
 * Defines the MousePosition enum constants, used by the {@link CursorModifier}
 */
var EMousePosition;
(function (EMousePosition) {
    /**
     * The mouse position is outside the main canvas
     */
    EMousePosition["OutOfCanvas"] = "OutOfCanvas";
    /**
     * The mouse position is in the Axis area
     */
    EMousePosition["AxisArea"] = "AxisArea";
    /**
     * The mouse position is in the Series area
     */
    EMousePosition["SeriesArea"] = "SeriesArea";
})(EMousePosition || (EMousePosition = {}));
/**
 * The RolloverModifier provides tooltip and cursor behavior on a 2D {@link SciChartSurface}
 * within SciChart - High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 *
 * To apply the RolloverModifier to a {@link SciChartSurface} and add tooltip behavior,
 * use the following code:
 *
 * ```ts
 * const sciChartSurface: SciChartSurface;
 * sciChartSurface.chartModifiers.add(new RolloverModifier());
 * ```
 */
class CursorModifier extends ChartModifierBase2D_1.ChartModifierBase2D {
    /**
     * Creates an instance of the RolloverModifier
     * @param options Optional parameters {@link ICursorModifierOptions} used to configure the modifier
     */
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        super(options);
        this.tooltipSvgTemplate = defaultTooltipTemplate;
        /**
         * Gets or sets the crosshair line strokethickness
         */
        this.crosshairStrokeThickness = 2;
        /**
         * Gets or sets the tooltip container background color as an HTML Color code
         */
        this.tooltipContainerBackground = "#228B22";
        /**
         * Gets or sets the tooltip text color as an HTML Color code
         */
        this.tooltipTextStroke = "#fff";
        /**
         * Gets or sets whether we should display the tooltip. Default is false
         */
        this.showTooltip = false;
        /**
         * Gets or sets whether we should display axis labels. Default is true
         */
        this.showAxisLabels = true;
        /**
         * Gets or sets the axis label text color as an HTML Color code
         */
        this.axisLabelStroke = "#fff";
        /**
         * Gets or sets the axis label fill as an HTML Color code.
         */
        this.axisLabelFill = "#228B22";
        this.mousePosition = EMousePosition.OutOfCanvas;
        this.crosshairStrokeProperty = defaultThemeColors_1.defaultThemeColors.cursorLineBrush;
        this.tooltipSvgTemplate = (_a = options === null || options === void 0 ? void 0 : options.tooltipSvgTemplate) !== null && _a !== void 0 ? _a : this.tooltipSvgTemplate;
        this.crosshairStrokeThickness = (_b = options === null || options === void 0 ? void 0 : options.crosshairStrokeThickness) !== null && _b !== void 0 ? _b : this.crosshairStrokeThickness;
        this.crosshairStroke = (_c = options === null || options === void 0 ? void 0 : options.crosshairStroke) !== null && _c !== void 0 ? _c : this.crosshairStroke;
        this.tooltipContainerBackground = (_d = options === null || options === void 0 ? void 0 : options.tooltipContainerBackground) !== null && _d !== void 0 ? _d : this.tooltipContainerBackground;
        this.tooltipTextStroke = (_e = options === null || options === void 0 ? void 0 : options.tooltipTextStroke) !== null && _e !== void 0 ? _e : this.tooltipTextStroke;
        this.showTooltip = (_f = options === null || options === void 0 ? void 0 : options.showTooltip) !== null && _f !== void 0 ? _f : this.showTooltip;
        this.showAxisLabels = (_g = options === null || options === void 0 ? void 0 : options.showAxisLabels) !== null && _g !== void 0 ? _g : this.showAxisLabels;
        this.axisLabelStroke = (_h = options === null || options === void 0 ? void 0 : options.axisLabelStroke) !== null && _h !== void 0 ? _h : this.axisLabelStroke;
        this.axisLabelFill = (_j = options === null || options === void 0 ? void 0 : options.axisLabelFill) !== null && _j !== void 0 ? _j : this.axisLabelFill;
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        if (!this.testPropertyChanged(constants_1.PROPERTY.CROSSHAIR_STROKE)) {
            this.crosshairStroke = themeProvider.cursorLineBrush;
        }
    }
    /**
     * @inheritDoc
     */
    onAttach() {
        var _a;
        super.onAttach();
        this.xLineAnnotation = this.newLineAnnotation();
        this.yLineAnnotation = this.newLineAnnotation();
        this.tooltipAnnotation = new CursorTooltipSvgAnnotation_1.CursorTooltipSvgAnnotation({
            xCoordinateMode: AnnotationBase_1.ECoordinateMode.Pixel,
            yCoordinateMode: AnnotationBase_1.ECoordinateMode.Pixel,
            tooltipSvgTemplate: (_a = this.tooltipSvgTemplate) !== null && _a !== void 0 ? _a : defaultTooltipTemplate,
            containerBackground: this.tooltipContainerBackground,
            textStroke: this.tooltipTextStroke
        });
        this.parentSurface.modifierAnnotations.add(this.xLineAnnotation, this.yLineAnnotation, this.tooltipAnnotation);
    }
    /**
     * @inheritDoc
     */
    onDetach() {
        super.onDetach();
        this.xLineAnnotation.delete();
        this.parentSurface.modifierAnnotations.remove(this.xLineAnnotation);
        this.yLineAnnotation.delete();
        this.parentSurface.modifierAnnotations.remove(this.yLineAnnotation);
        this.tooltipAnnotation.delete();
        this.parentSurface.modifierAnnotations.remove(this.tooltipAnnotation);
    }
    /**
     * @inheritDoc
     */
    onAttachSeries(rs) {
        this.tooltipAnnotation.seriesInfos = this.getSeriesInfos();
    }
    /**
     * @inheritDoc
     */
    onDetachSeries(rs) {
        this.tooltipAnnotation.seriesInfos = this.getSeriesInfos();
    }
    /**
     * @inheritDoc
     */
    modifierMouseMove(args) {
        super.modifierMouseMove(args);
        let translatedMousePoint;
        if (!this.mousePoint) {
            this.mousePosition = EMousePosition.OutOfCanvas;
        }
        else {
            translatedMousePoint = translate_1.translateFromCanvasToSeriesViewRect(this.mousePoint, this.parentSurface.seriesViewRect);
            if (!translatedMousePoint) {
                this.mousePosition = EMousePosition.AxisArea;
            }
            else {
                this.mousePosition = EMousePosition.SeriesArea;
            }
        }
        this.update();
    }
    /**
     * @inheritDoc
     */
    modifierMouseLeave(args) {
        super.modifierMouseLeave(args);
        this.mousePosition = EMousePosition.OutOfCanvas;
        this.update();
    }
    /**
     * @inheritDoc
     */
    modifierMouseEnter(args) {
        super.modifierMouseEnter(args);
    }
    /**
     * @inheritDoc
     */
    onParentSurfaceRendered() {
        this.update();
    }
    /**
     * Gets or sets the crosshair line Stroke color as an HTML Color code
     */
    get crosshairStroke() {
        return this.crosshairStrokeProperty;
    }
    /**
     * Gets or sets the crosshair line Stroke color as an HTML Color code
     */
    set crosshairStroke(value) {
        this.crosshairStrokeProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.CROSSHAIR_STROKE);
    }
    notifyPropertyChanged(propertyName) {
        super.notifyPropertyChanged(propertyName);
    }
    getSeriesInfos() {
        const regularSeries = this.parentSurface.renderableSeries
            .asArray()
            .filter(el => { var _a; return el.isVisible && !el.isStacked && ((_a = el.dataSeries) === null || _a === void 0 ? void 0 : _a.count()) > 0; });
        const stackedSeries = this.parentSurface.renderableSeries.asArray().filter(el => el.isStacked);
        const allSeries = regularSeries;
        stackedSeries.forEach(rs => {
            rs.getVisibleSeries().forEach(childRs => allSeries.push(childRs));
        });
        return allSeries
            .map(rs => {
            const hitTestInfo = rs.hitTestProvider.hitTest(this.mousePoint, IHitTestProvider_1.ENearestPointLogic.NearestHorizontalPoint, BaseHitTestProvider_1.BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS, false);
            if (!hitTestInfo) {
                return undefined;
            }
            return BaseRenderableSeries_1.getSeriesInfo(rs, hitTestInfo);
        })
            .filter(rs => rs !== undefined);
    }
    update() {
        if (this.mousePosition !== EMousePosition.SeriesArea) {
            this.xLineAnnotation.isHidden = true;
            this.yLineAnnotation.isHidden = true;
            this.tooltipAnnotation.isHidden = true;
            return;
        }
        const translatedMousePoint = translate_1.translateFromCanvasToSeriesViewRect(this.mousePoint, this.parentSurface.seriesViewRect);
        this.xLineAnnotation.isHidden = false;
        this.yLineAnnotation.isHidden = false;
        if (this.showTooltip) {
            this.tooltipAnnotation.isHidden = false;
        }
        if (translatedMousePoint) {
            const { x, y } = translatedMousePoint;
            this.xLineAnnotation.y1 = 0;
            this.xLineAnnotation.y2 = this.parentSurface.seriesViewRect.bottom;
            this.xLineAnnotation.x1 = x;
            this.xLineAnnotation.x2 = x;
            this.yLineAnnotation.x1 = 0;
            this.yLineAnnotation.x2 = this.parentSurface.seriesViewRect.right;
            this.yLineAnnotation.y1 = y;
            this.yLineAnnotation.y2 = y;
            if (this.showTooltip) {
                this.tooltipAnnotation.x1 = x;
                this.tooltipAnnotation.y1 = y;
                this.tooltipAnnotation.seriesInfos = this.getSeriesInfos();
            }
        }
    }
    newLineAnnotation() {
        return new LineAnnotation_1.LineAnnotation({
            xCoordinateMode: AnnotationBase_1.ECoordinateMode.Pixel,
            yCoordinateMode: AnnotationBase_1.ECoordinateMode.Pixel,
            strokeThickness: this.crosshairStrokeThickness,
            stroke: this.crosshairStroke,
            isHidden: true,
            showLabel: this.showAxisLabels,
            axisLabelFill: this.axisLabelFill,
            axisLabelStroke: this.axisLabelStroke
        });
    }
}
exports.CursorModifier = CursorModifier;
/** @ignore */
const defaultTooltipTemplate = (seriesInfos, svgAnnotation) => {
    const id = `id_${Date.now()}`;
    const valuesWithLabels = [];
    const numberOfSeries = seriesInfos.length;
    seriesInfos.forEach((el, index) => {
        if (el.seriesName) {
            valuesWithLabels.push(el.seriesName);
        }
        else if (numberOfSeries > 1) {
            valuesWithLabels.push(`Series #${index + 1}`);
        }
        if (el.dataSeriesType === IDataSeries_1.EDataSeriesType.Ohlc) {
            const ohlcSeriesInfo = el;
            valuesWithLabels.push(`X: ${ohlcSeriesInfo.formattedXValue}`);
            valuesWithLabels.push(`Open: ${ohlcSeriesInfo.formattedOpenValue}`);
            valuesWithLabels.push(`Highest: ${ohlcSeriesInfo.formattedHighValue}`);
            valuesWithLabels.push(`Lowest: ${ohlcSeriesInfo.formattedLowValue}`);
            valuesWithLabels.push(`Close: ${ohlcSeriesInfo.formattedCloseValue}`);
        }
        else if (el.dataSeriesType === IDataSeries_1.EDataSeriesType.Xyy) {
            // Band Series
            const xyySeriesInfo = el;
            valuesWithLabels.push(`X: ${xyySeriesInfo.formattedXValue}`);
            valuesWithLabels.push(`Y: ${xyySeriesInfo.formattedYValue}`);
            valuesWithLabels.push(`Y1: ${xyySeriesInfo.formattedY1Value}`);
        }
        else if (el.dataSeriesType === IDataSeries_1.EDataSeriesType.HeatmapUniform) {
            // Heatmap Series
            const heatmapSeriesInfo = el;
            valuesWithLabels.push(`X: ${heatmapSeriesInfo.formattedXValue}`);
            valuesWithLabels.push(`Y: ${heatmapSeriesInfo.formattedYValue}`);
            if (heatmapSeriesInfo.zValue !== null && heatmapSeriesInfo.zValue !== undefined) {
                valuesWithLabels.push(`Z: ${heatmapSeriesInfo.formattedZValue}`);
            }
        }
        else {
            const xySeriesInfo = el;
            valuesWithLabels.push(`X: ${xySeriesInfo.formattedXValue} Y: ${xySeriesInfo.formattedYValue}`);
        }
    });
    let valuesBlock = "";
    const tooltipTitle = svgAnnotation.title;
    if (tooltipTitle) {
        valuesBlock += `<tspan x="8" dy="1.2em">${tooltipTitle}</tspan>`;
    }
    // tooltip width
    let tooltipLength = valuesWithLabels.reduce((prev, cur) => (cur.length > prev ? cur.length : prev), 0);
    if ((tooltipTitle === null || tooltipTitle === void 0 ? void 0 : tooltipTitle.length) > tooltipLength) {
        tooltipLength = tooltipTitle.length;
    }
    const width = calcTooltipWidth(tooltipLength);
    // tooltip height
    const tooltipLines = tooltipTitle ? valuesWithLabels.length + 1 : valuesWithLabels.length;
    const height = calcTooltipHeight(tooltipLines);
    // Positioning the tooltip
    const { seriesViewRect } = svgAnnotation.parentSurface;
    const xCoord = svgAnnotation.x1;
    const yCoord = svgAnnotation.y1;
    const xCoordShift = seriesViewRect.width - xCoord < width ? -width : 5;
    const yCoordShift = seriesViewRect.height - yCoord < height ? -height : 5;
    svgAnnotation.xCoordShift = xCoordShift;
    svgAnnotation.yCoordShift = yCoordShift;
    valuesWithLabels.forEach((val, index) => {
        valuesBlock += `<tspan x="8" dy="1.2em">${val}</tspan>`;
    });
    const tooltipFill = svgAnnotation.containerBackground;
    const tooltipStroke = svgAnnotation.textStroke;
    return `<svg width="${width}" height="${height}">
        <defs>
            <filter id="${id}" x="0" y="0" width="200%" height="200%">
                <feOffset result="offOut" in="SourceAlpha" dx="3" dy="3" />
                <feGaussianBlur result="blurOut" in="offOut" stdDeviation="3" />
                <feBlend in="SourceGraphic" in2="blurOut" mode="normal" />
            </filter>
        </defs>
        <rect rx="4" ry="4" width="95%" height="90%" fill="${tooltipFill}" filter="url(#${id})" />
        <svg width="100%">
            <text x="8" y="3" font-size="13" font-family="Verdana" dy="0" fill="${tooltipStroke}">${valuesBlock}</text>
        </svg>
    </svg>`;
};
/** @ignore */
const calcTooltipWidth = (textLength = 20, fontSize = 13) => {
    return textLength * 8 + 20;
};
/** @ignore */
const calcTooltipHeight = (lines = 2, fontSize = 13) => {
    return 17 * lines + 16;
};
