"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RubberBandXyZoomModifier = void 0;
const EasingFunctions_1 = require("../../Core/Animations/EasingFunctions");
const Deleter_1 = require("../../Core/Deleter");
const Point_1 = require("../../Core/Point");
const ZoomState_1 = require("../../types/ZoomState");
const translate_1 = require("../../utils/translate");
const RubberBandRect_1 = require("../Visuals/RubberBandRect/RubberBandRect");
const ChartModifierBase2D_1 = require("./ChartModifierBase2D");
const constants_1 = require("./constants");
/** @ignore */
const MIN_DRAG_SENSITIVITY = 5;
/**
 * The RubberBandXyZoomModifier provides drag-rectangle to zoom behavior on a 2D {@link SciChartSurface}
 * within SciChart - High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 *
 * To apply the RubberBandXyZoomModifier to a {@link SciChartSurface} and add drag to zoom behavior,
 * use the following code:
 *
 * ```ts
 * const sciChartSurface: SciChartSurface;
 * sciChartSurface.chartModifiers.add(new RubberBandXyZoomModifier());
 * ```
 *
 * Animation of the zoom may be controlled via the {@link RubberBandXyZoomModifier.isAnimated},
 * {@link RubberBandXyZoomModifier.animationDuration} and {@link RubberBandXyZoomModifier.easingFunction} properties.
 */
class RubberBandXyZoomModifier extends ChartModifierBase2D_1.ChartModifierBase2D {
    /**
     * Creates an instance of a RubberBandXyZoomModifier
     * @param options Optional parameters used to configure the modifier
     */
    constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        super(options);
        /**
         * When true, the Zoom operations are animated. See also {@link animationDuration} and {@link easingFunction}
         */
        this.isAnimated = true;
        /**
         * Defines the duration of animations when zooming in milliseconds
         */
        this.animationDuration = 400;
        /**
         * Defines the easing function for animation. See {@link TEasing} for a range of functions
         */
        this.easingFunction = EasingFunctions_1.easing.outExpo;
        this.isClicked = false;
        this.fillProperty = "#42b64933";
        this.strokeProperty = "#42b64977";
        this.strokeThicknessProperty = 2;
        this.fill = (_a = options === null || options === void 0 ? void 0 : options.fill) !== null && _a !== void 0 ? _a : this.fillProperty;
        this.stroke = (_b = options === null || options === void 0 ? void 0 : options.stroke) !== null && _b !== void 0 ? _b : this.strokeProperty;
        this.strokeThickness = (_c = options === null || options === void 0 ? void 0 : options.strokeThickness) !== null && _c !== void 0 ? _c : this.strokeThicknessProperty;
        this.isAnimated = (_d = options === null || options === void 0 ? void 0 : options.isAnimated) !== null && _d !== void 0 ? _d : true;
        this.animationDuration = (_e = options === null || options === void 0 ? void 0 : options.animationDuration) !== null && _e !== void 0 ? _e : 400;
        this.easingFunction = (_f = options === null || options === void 0 ? void 0 : options.easingFunction) !== null && _f !== void 0 ? _f : EasingFunctions_1.easing.outExpo;
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        if (!this.testPropertyChanged(constants_1.PROPERTY.FILL)) {
            this.fill = themeProvider.rubberBandFillBrush;
        }
        if (!this.testPropertyChanged(constants_1.PROPERTY.STROKE)) {
            this.stroke = themeProvider.rubberBandStrokeBrush;
        }
    }
    /**
     * @inheritDoc
     */
    onAttach() {
        super.onAttach();
        this.rubberBandRect = new RubberBandRect_1.RubberBandRect(this.parentSurface.domSvgContainer, this.fill, this.stroke, this.strokeThickness);
    }
    /**
     * @inheritDoc
     */
    onDetach() {
        super.onDetach();
        this.rubberBandRect = undefined;
    }
    /**
     * @inheritDoc
     */
    modifierMouseDown(args) {
        super.modifierMouseDown(args);
        if (this.executeOn !== args.button) {
            return;
        }
        if (!this.isAttached) {
            throw new Error("Should not call RubberBandXyZoomModifier.modifierMouseDown if not attached");
        }
        this.parentSurface.setZoomState(ZoomState_1.EZoomState.UserZooming);
        const pointFromTrans = translate_1.translateFromCanvasToSeriesViewRect(args.mousePoint, this.parentSurface.seriesViewRect);
        if (pointFromTrans) {
            this.pointFrom = pointFromTrans;
            this.isClicked = true;
        }
    }
    /**
     * @inheritDoc
     */
    modifierMouseMove(args) {
        super.modifierMouseMove(args);
        const { seriesViewRect } = this.parentSurface;
        if (this.isClicked) {
            this.pointTo = translate_1.translateFromCanvasToSeriesViewRect(limitToSeriesViewRect(args.mousePoint, seriesViewRect), seriesViewRect);
            const x1 = this.pointTo.x <= this.pointFrom.x ? this.pointTo.x : this.pointFrom.x;
            const x2 = this.pointTo.x <= this.pointFrom.x ? this.pointFrom.x : this.pointTo.x;
            const y1 = this.pointTo.y <= this.pointFrom.y ? this.pointTo.y : this.pointFrom.y;
            const y2 = this.pointTo.y <= this.pointFrom.y ? this.pointFrom.y : this.pointTo.y;
            this.rubberBandRect.isHidden = false;
            this.rubberBandRect.x1 = x1;
            this.rubberBandRect.x2 = x2;
            this.rubberBandRect.y1 = y1;
            this.rubberBandRect.y2 = y2;
        }
    }
    /**
     * @inheritDoc
     */
    modifierMouseUp(args) {
        super.modifierMouseUp(args);
        if (this.executeOn !== args.button) {
            return;
        }
        if (this.isClicked) {
            const { seriesViewRect } = this.parentSurface;
            this.pointTo = translate_1.translateFromCanvasToSeriesViewRect(limitToSeriesViewRect(args.mousePoint, seriesViewRect), seriesViewRect);
            this.isClicked = false;
            this.rubberBandRect.isHidden = true;
            if (this.calculateDraggedDistance() > MIN_DRAG_SENSITIVITY) {
                this.performZoom(this.pointFrom, this.pointTo);
            }
        }
    }
    // PROPERTIES
    /**
     * Get the stroke thickness for {@link RubberBandRect}
     */
    get strokeThickness() {
        return this.strokeThicknessProperty;
    }
    /**
     * Set the stroke thickness for {@link RubberBandRect}
     */
    set strokeThickness(value) {
        this.strokeThicknessProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE_THICKNESS);
    }
    /**
     * Get the stroke for {@link RubberBandRect}
     */
    get stroke() {
        return this.strokeProperty;
    }
    /**
     * Set the stroke for {@link RubberBandRect}
     */
    set stroke(value) {
        this.strokeProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE);
    }
    /**
     * Get the fill color for {@link RubberBandRect}
     */
    get fill() {
        return this.fillProperty;
    }
    /**
     * Set the fill color for {@link RubberBandRect}
     */
    set fill(value) {
        this.fillProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.FILL);
    }
    /**
     * Performs the zoom operation on the parent Surface, using the mouse points from & to, which
     * define the corners of the rectangle to zoom
     * @param pointFrom the first corner of the rectangle to zoom
     * @param pointTo the second corner of the rectangle to zoom
     */
    performZoom(pointFrom, pointTo) {
        this.parentSurface.xAxes.asArray().forEach(axis => {
            this.performZoomOnAxis(axis, axis.isVerticalChart ? pointFrom.y : pointFrom.x, axis.isVerticalChart ? pointTo.y : pointTo.x);
        });
        this.parentSurface.yAxes.asArray().forEach(axis => {
            this.performZoomOnAxis(axis, axis.isVerticalChart ? pointFrom.x : pointFrom.y, axis.isVerticalChart ? pointTo.x : pointTo.y);
        });
    }
    /**
     * Performs a Zoom on a specific axis
     * @param axis the Axis to zoom
     * @param fromCoord the coordinate to zoom from
     * @param toCoord the coordinate to zoom to
     */
    performZoomOnAxis(axis, fromCoord, toCoord) {
        axis.zoom(fromCoord, toCoord, this.isAnimated ? this.animationDuration : 0, this.easingFunction);
    }
    notifyPropertyChanged(propertyName) {
        super.notifyPropertyChanged(propertyName);
        this.updateRubberBandRect();
    }
    calculateDraggedDistance() {
        const diffX = Math.pow((this.pointFrom.x - this.pointTo.x), 2);
        const diffY = Math.pow((this.pointFrom.y - this.pointTo.y), 2);
        return Math.sqrt(diffX + diffY);
    }
    updateRubberBandRect() {
        if (this.parentSurface) {
            this.rubberBandRect = Deleter_1.deleteSafe(this.rubberBandRect);
            this.rubberBandRect = new RubberBandRect_1.RubberBandRect(this.parentSurface.domSvgContainer, this.fill, this.stroke, this.strokeThickness);
        }
    }
}
exports.RubberBandXyZoomModifier = RubberBandXyZoomModifier;
/**
 * @ignore
 */
const limitToSeriesViewRect = (point, seriesViewRect) => {
    const x = point.x < seriesViewRect.x
        ? seriesViewRect.x
        : point.x > seriesViewRect.x + seriesViewRect.width
            ? seriesViewRect.x + seriesViewRect.width
            : point.x;
    const y = point.y < seriesViewRect.y
        ? seriesViewRect.y
        : point.y > seriesViewRect.y + seriesViewRect.height
            ? seriesViewRect.y + seriesViewRect.height
            : point.y;
    return new Point_1.Point(x, y);
};
