"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZoomPanModifier = void 0;
const XyDirection_1 = require("../../types/XyDirection");
const ZoomState_1 = require("../../types/ZoomState");
const AxisBase2D_1 = require("../Visuals/Axis/AxisBase2D");
const ChartModifierBase2D_1 = require("./ChartModifierBase2D");
/**
 * The ZoomPanModifier provides drag to pan behavior on a 2D {@link SciChartSurface}
 * within SciChart - High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 *
 * To apply the ZoomPanModifier to a {@link SciChartSurface} and add drag to pan behavior,
 * use the following code:
 *
 * ```ts
 * const sciChartSurface: SciChartSurface;
 * sciChartSurface.chartModifiers.add(new ZoomPanModifier());
 * ```
 */
class ZoomPanModifier extends ChartModifierBase2D_1.ChartModifierBase2D {
    /**
     * Creates an instance of a ZoomPanModifier
     * @param options optional parameters to pass to the ZoomPanModifier to configure it upon construction
     */
    constructor(options) {
        super(options);
        /**
         * Stores info about active pointerdown events
         */
        this.activeTouchEvents = new Map();
    }
    /**
     * @inheritDoc
     */
    modifierMouseDown(args) {
        super.modifierMouseDown(args);
        if (this.executeOn !== args.button) {
            return;
        }
        if (!this.isAttached) {
            throw new Error("Should not call ZoomPanModifier.modifierMouseDown if not attached");
        }
        this.activeTouchEvents.set(args.pointerId, args);
        // prevent the execution of drag and pan for this event
        // if it is already being performed by another pointer
        if (this.activeTouchEvents.size > 1) {
            return;
        }
        this.parentSurface.setZoomState(ZoomState_1.EZoomState.UserZooming);
        args.handled = true;
        this.lastPoint = args.mousePoint;
        args.target.setPointerCapture(args.pointerId);
    }
    /**
     * @inheritDoc
     */
    modifierMouseMove(args) {
        super.modifierMouseMove(args);
        this.activeTouchEvents.set(args.pointerId, args);
        if (this.lastPoint === undefined || this.activeTouchEvents.size > 1) {
            return;
        }
        // allow drag and pan only for the first active pointer in order of event occurrence
        const capturedPointerEvent = this.activeTouchEvents.values().next().value;
        if (capturedPointerEvent.pointerId !== args.pointerId) {
            return;
        }
        const currentPoint = args.mousePoint;
        const xDelta = currentPoint.x - this.lastPoint.x;
        const yDelta = this.lastPoint.y - currentPoint.y;
        // Scroll the X,YAxis by the number of pixels since the last update
        // TODO: SciChartSurface.SuspendUpdates around this block
        if ([XyDirection_1.EXyDirection.XDirection, XyDirection_1.EXyDirection.XyDirection].includes(this.xyDirection)) {
            this.parentSurface.xAxes.asArray().forEach(x => {
                const delta = x.isHorizontalAxis ? xDelta : -yDelta;
                x.scroll(x.flippedCoordinates ? -delta : delta, AxisBase2D_1.EClipMode.None);
            });
        }
        if ([XyDirection_1.EXyDirection.YDirection, XyDirection_1.EXyDirection.XyDirection].includes(this.xyDirection)) {
            this.parentSurface.yAxes.asArray().forEach(y => {
                const delta = y.isHorizontalAxis ? -xDelta : yDelta;
                y.scroll(y.flippedCoordinates ? -delta : delta, AxisBase2D_1.EClipMode.None);
            });
        }
        this.lastPoint = currentPoint;
    }
    /**
     * @inheritDoc
     */
    modifierMouseUp(args) {
        super.modifierMouseUp(args);
        this.lastPoint = undefined;
        args.target.releasePointerCapture(args.pointerId);
        this.activeTouchEvents.delete(args.pointerId);
        // delegate drag and pan handling to the next active pointer in order of event occurrence
        if (this.activeTouchEvents.size > 0) {
            const nextActivePointerEvent = this.activeTouchEvents.values().next().value;
            this.lastPoint = nextActivePointerEvent.mousePoint;
            args.target.setPointerCapture(nextActivePointerEvent.pointerId);
        }
    }
    /**
     * @inheritDoc
     */
    modifierPointerCancel(args) {
        super.modifierPointerCancel(args);
        this.lastPoint = undefined;
        args.target.releasePointerCapture(args.pointerId);
        this.activeTouchEvents.clear();
    }
}
exports.ZoomPanModifier = ZoomPanModifier;
