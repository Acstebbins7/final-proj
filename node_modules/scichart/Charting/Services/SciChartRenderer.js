"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SciChartRenderer = void 0;
const Dictionary_1 = require("../../Core/Dictionary");
const NumberRange_1 = require("../../Core/NumberRange");
const AutoRange_1 = require("../../types/AutoRange");
const AxisAlignment_1 = require("../../types/AxisAlignment");
const IAnnotation_1 = require("../Visuals/Annotations/IAnnotation");
const RenderPassData_1 = require("./RenderPassData");
/**
 * A class used internally in SciChart to perform layout, arrangement, data-preparation and rendering on the Cartesian 2D {@link SciChartSurface}
 */
class SciChartRenderer {
    /**
     * Creates an instance of the SciChartRenderer
     * @param sciChartSurface The {@link SciChartSurface} that we are rendering
     */
    constructor(sciChartSurface) {
        this.sciChartSurface = sciChartSurface;
    }
    /**
     * Render loop for the current {@SciChartSurface}
     * @param renderContext the {@WebGLRenderContext2D} used for drawing
     */
    render(renderContext) {
        if (this.sciChartSurface.isDeleted)
            return;
        // Step 1 validate the chart and show errors
        this.validate();
        this.sciChartSurface.updateBackground();
        // Step 2 autorange
        this.sciChartSurface.xAxes.asArray().forEach(axis => this.tryPerformAutoRangeOn(axis, this.sciChartSurface));
        this.sciChartSurface.yAxes.asArray().forEach(axis => this.tryPerformAutoRangeOn(axis, this.sciChartSurface));
        // Step 3 layout
        const seriesViewRect = this.sciChartSurface.layoutManager.layoutChart(renderContext.viewportSize);
        this.updateSvgCanvasSize(seriesViewRect);
        // Draw seriesViewRect border
        this.sciChartSurface.drawBorder(renderContext);
        // Step 4 prepare render data
        const xyAxesById = this.prepareRenderData();
        // Step 5 Draw X, Y axis and gridlines
        if (this.sciChartSurface.debugRendering) {
            this.drawDebugAxes(this.sciChartSurface, renderContext);
        }
        this.drawAxes(this.sciChartSurface, renderContext);
        // Step 6 Draw annotations below the series
        const userAnnotations = this.sciChartSurface.annotations.asArray();
        const modifierAnnotations = this.sciChartSurface.modifierAnnotations.asArray();
        const annotations = [...userAnnotations, ...modifierAnnotations];
        const renderContextAnnotations = annotations.filter(el => {
            return (el.type === IAnnotation_1.EAnnotationType.RenderContext ||
                el.type === IAnnotation_1.EAnnotationType.RenderContextBoxAnnotation ||
                el.type === IAnnotation_1.EAnnotationType.RenderContextLineAnnotation ||
                el.type === IAnnotation_1.EAnnotationType.RenderContextHorizontalLineAnnotation ||
                el.type === IAnnotation_1.EAnnotationType.RenderContextVerticalLineAnnotation ||
                el.type === IAnnotation_1.EAnnotationType.RenderContextAxisMarkerAnnotation);
        });
        this.drawRenderContextAnnotations(renderContextAnnotations, xyAxesById[0], xyAxesById[1], IAnnotation_1.EAnnotationLayer.BelowChart, renderContext, seriesViewRect);
        // Step 7 Draw series
        this.drawSeries(this.sciChartSurface, this.sciChartSurface.renderableSeries.asArray(), renderContext);
        // Step 8 Draw annotations above the series
        this.drawRenderContextAnnotations(renderContextAnnotations, xyAxesById[0], xyAxesById[1], IAnnotation_1.EAnnotationLayer.AboveChart, renderContext, seriesViewRect);
        // Step 9 Draw SVG or Html Overlays
        const svgAnnotations = annotations.filter(el => el.type === IAnnotation_1.EAnnotationType.SVG ||
            el.type === IAnnotation_1.EAnnotationType.SVGTextAnnotation ||
            el.type === IAnnotation_1.EAnnotationType.SVGCustomAnnotation);
        this.drawSvgAnnotations(svgAnnotations, xyAxesById[0], xyAxesById[1]);
        // Update watermark
        const left = seriesViewRect.x;
        const bottom = renderContext.viewportSize.height - (seriesViewRect.top + seriesViewRect.height);
        this.sciChartSurface.updateWatermark(left, bottom);
        // Step 10 Call OnParentSurfaceRendered
        this.onParentSurfaceRendered();
    }
    drawRenderContextAnnotations(annotations, xAxisById, yAxisById, annotationLayer, renderContext, seriesViewRect) {
        annotations
            .filter(a => a.annotationLayer === annotationLayer)
            .forEach(a => {
            a.drawWithContext(renderContext, xAxisById.item(a.xAxisId).getCurrentCoordinateCalculator(), yAxisById.item(a.yAxisId).getCurrentCoordinateCalculator(), seriesViewRect);
        });
    }
    drawSvgAnnotations(annotations, xAxisById, yAxisById) {
        annotations.forEach(a => {
            a.update(xAxisById.item(a.xAxisId).getCurrentCoordinateCalculator(), yAxisById.item(a.yAxisId).getCurrentCoordinateCalculator());
        });
    }
    validate() {
        // TODO: Check the surface is valid and output error codes to console
        // Checks would include
        // Is XAxes and YAxes collection null or empty
        // is XAxis a CategoryAxis and renderableseries is null or empty
        // Do all renderableseries have dataseries
    }
    updateSvgCanvasSize(seriesViewRect) {
        const svgRootElement = this.sciChartSurface.domSvgContainer;
        if (svgRootElement) {
            svgRootElement.style.marginLeft = `${seriesViewRect.x}px`;
            svgRootElement.style.marginTop = `${seriesViewRect.y}px`;
            svgRootElement.setAttribute("width", seriesViewRect.width.toString());
            svgRootElement.setAttribute("height", seriesViewRect.height.toString());
        }
        const svgAdornerLayer = this.sciChartSurface.domSvgAdornerLayer;
        if (svgAdornerLayer) {
            svgAdornerLayer.style.marginLeft = `${seriesViewRect.x}px`;
            svgAdornerLayer.style.marginTop = `${seriesViewRect.y}px`;
            svgAdornerLayer.setAttribute("width", seriesViewRect.width.toString());
            svgAdornerLayer.setAttribute("height", seriesViewRect.height.toString());
        }
    }
    prepareRenderData() {
        const xAxesById = new Dictionary_1.Dictionary();
        const yAxesById = new Dictionary_1.Dictionary();
        // Prepare XAxes
        this.sciChartSurface.xAxes.asArray().forEach(xAxis => {
            xAxesById.add(xAxis.id, xAxis);
            xAxis.prepareRenderData();
        });
        // Prepare YAxes
        this.sciChartSurface.yAxes.asArray().forEach(yAxis => {
            yAxesById.add(yAxis.id, yAxis);
            yAxis.prepareRenderData();
        });
        return [xAxesById, yAxesById];
    }
    drawAxes(scs, renderContext) {
        scs.xAxes.asArray().forEach((xAxis) => {
            xAxis.draw(renderContext);
        });
        scs.yAxes.asArray().forEach((yAxis) => {
            yAxis.draw(renderContext);
        });
        // Actual axis drawing happens here
        renderContext.drawLayers();
    }
    drawSeries(scs, renderableSeries, renderContext) {
        renderableSeries
            .filter(rs => rs.isVisible)
            .forEach(series => {
            const indexRange = new NumberRange_1.NumberRange(0, 0);
            const xAxis = scs.xAxes.asArray().find(a => a.id === series.xAxisId);
            if (!xAxis) {
                throw Error("Cannot find an X Axis with ID = " + series.xAxisId);
            }
            const yAxis = scs.yAxes.asArray().find(a => a.id === series.yAxisId);
            if (!yAxis) {
                throw Error("Cannot find a Y Axis with ID = " + series.yAxisId);
            }
            if (xAxis.isVerticalChart &&
                ![AxisAlignment_1.EAxisAlignment.Top, AxisAlignment_1.EAxisAlignment.Bottom].includes(yAxis.axisAlignment)) {
                throw Error(`For vertical chart (chart with X Axis alignment Left or Right) Y Axis alignment should be Top or Bottom, X Axis ID = ${xAxis.id}`);
            }
            if (AxisAlignment_1.getIsVertical(xAxis.axisAlignment) && AxisAlignment_1.getIsVertical(yAxis.axisAlignment)) {
                throw Error("Both x and y axes can't have vertical alignment");
            }
            if (AxisAlignment_1.getIsHorizontal(xAxis.axisAlignment) && AxisAlignment_1.getIsHorizontal(yAxis.axisAlignment)) {
                throw Error("Both x and y axes can't have horizontal alignment");
            }
            const xCalc = xAxis.getCurrentCoordinateCalculator();
            const yCalc = yAxis.getCurrentCoordinateCalculator();
            try {
                const renderPassData = new RenderPassData_1.RenderPassData(indexRange, xCalc, yCalc, xAxis.isVerticalChart);
                series.draw(renderContext, renderPassData);
            }
            finally {
                // We can not delete calculators because we use them in Hit Test
                // xCalc.delete();
                // yCalc.delete();
            }
        });
    }
    drawDebugAxes(scs, renderContext) {
        scs.xAxes.asArray().forEach((xAxis) => {
            xAxis.drawDebug(renderContext);
        });
        scs.yAxes.asArray().forEach((yAxis) => {
            yAxis.drawDebug(renderContext);
        });
    }
    tryPerformAutoRangeOn(axis, sciChartSurface) {
        const shouldAutoRange = axis.autoRange === AutoRange_1.EAutoRange.Always ||
            (axis.autoRange === AutoRange_1.EAutoRange.Once && (!axis.hasValidVisibleRange || axis.hasDefaultVisibleRange));
        if (shouldAutoRange) {
            // Different implementation for YAxis and XAxis because of windowing
            const newRange = axis.getMaximumRange();
            if (!newRange.equals(axis.visibleRange)) {
                axis.visibleRange = newRange;
            }
        }
    }
    onParentSurfaceRendered() {
        this.sciChartSurface.chartModifiers.asArray().forEach(cm => {
            cm.onParentSurfaceRendered();
        });
        this.sciChartSurface.rendered.raiseEvent();
    }
}
exports.SciChartRenderer = SciChartRenderer;
