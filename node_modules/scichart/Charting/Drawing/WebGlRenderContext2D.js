"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebGlRenderContext2D = exports.ELineDrawMode = void 0;
const app_1 = require("../../constants/app");
const Guard_1 = require("../../Core/Guard");
const RenderLayer_1 = require("../../types/RenderLayer");
const parseColor_1 = require("../../utils/parseColor");
const createNativeRect_1 = require("../Visuals/Helpers/createNativeRect");
const WebGlBrush_1 = require("./WebGlBrush");
const WebGlPen_1 = require("./WebGlPen");
/**
 * Defines enumeration constants for Line Drawing modes
 */
var ELineDrawMode;
(function (ELineDrawMode) {
    /**
     * Points provided define a poly-line (continuous line)
     */
    ELineDrawMode[ELineDrawMode["PolyLine"] = 0] = "PolyLine";
    /**
     * Points provided define discontinuous lines, e.g. x1y1 x2y2  is one line, x3y3 x4y4 is the next
     */
    ELineDrawMode[ELineDrawMode["DiscontinuousLine"] = 1] = "DiscontinuousLine";
})(ELineDrawMode = exports.ELineDrawMode || (exports.ELineDrawMode = {}));
/**
 * The WebGlRenderContext2D provides methods for drawing to a WebGL2 / WebAssembly canvas powered by SciChart's Visual Xccelerator engine.
 * This context class is used in SciChart's High Performance Realtime {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * to draw shapes, lines, fills, images and more
 */
class WebGlRenderContext2D {
    /**
     * Creates an instance of the WebGlRenderContext2D
     * @param webAssemblyContext The {@link TSciChart | SciChart WebAssembly Context} containing native methods and access to our WebGL2 Engine
     * @param viewportSize The Viewport {@link Size}
     */
    constructor(webAssemblyContext, viewportSize) {
        this.layers = { first: [], second: [], third: [], fourth: [] };
        this.effects = [];
        this.webAssemblyContext = webAssemblyContext;
        this.viewportSize = viewportSize;
    }
    /**
     * Get the native {@link SCRTRenderContext} for direct access to SciChart's WebAssembly Visual Xccelerator engine
     */
    getNativeContext() {
        return this.webAssemblyContext.SCRTGetMainRenderContext2D();
    }
    /**
     * Draw lines: grid lines, etc.
     * @param vertices
     * @param pen
     * @param lineDrawMode
     * @param left - offset in pixels from left, typically used for axes
     * @param top - offset in pixels from top, typically used for axes
     */
    drawLinesNative(vertices, pen, lineDrawMode, left = 0, top = 0) {
        const isStrips = lineDrawMode === ELineDrawMode.PolyLine;
        const nativeContext = this.getNativeContext();
        nativeContext.PushMatrix();
        nativeContext.Translate(left, top);
        nativeContext.DrawLinesBatchVec(isStrips, vertices, pen);
        nativeContext.PopMatrix();
    }
    /**
     * Draw rectangles: grid bands, etc.
     * @param vertices
     * @param brush
     * @param left - offset in pixels from left, typically used for axes
     * @param top - offset in pixels from top, typically used for axes
     */
    drawRects(vertices, brush, left = 0, top = 0) {
        const anchorParams = new this.webAssemblyContext.TSRVector4();
        anchorParams.x = 0;
        anchorParams.y = 0;
        const nativeContext = this.getNativeContext();
        nativeContext.PushMatrix();
        nativeContext.Translate(left, top);
        nativeContext.DrawRectsBatchVec(vertices, brush, anchorParams);
        nativeContext.PopMatrix();
        anchorParams.delete();
    }
    /**
     * Enqueues a draw operation to the specified layer. Use in combination with {@link drawLayers} to flush layered draws
     * @param drawFunction the {@link TDrawFunction | Draw Function} to enqueue
     * @param layer the {@link ERenderLayer | Layer} to draw to
     */
    enqueueLayeredDraw(drawFunction, layer) {
        switch (layer) {
            case RenderLayer_1.ERenderLayer.First:
                this.layers.first.push(drawFunction);
                break;
            case RenderLayer_1.ERenderLayer.Second:
                this.layers.second.push(drawFunction);
                break;
            case RenderLayer_1.ERenderLayer.Third:
                this.layers.third.push(drawFunction);
                break;
            default:
                this.layers.fourth.push(drawFunction);
        }
    }
    /**
     * Flushes the {@link layers} which have been enqueued with drawing operations in order.
     * Use this in combination with {@link enqueueLayeredDraw} to draw in layers
     */
    drawLayers() {
        this.layers.first.forEach(drawFunc => drawFunc());
        this.layers.second.forEach(drawFunc => drawFunc());
        this.layers.third.forEach(drawFunc => drawFunc());
        this.layers.fourth.forEach(drawFunc => drawFunc());
    }
    /**
     * Applies a {@link ShaderEffect} to the rendering pipeline. Calling {@link WebGL2RenderingContext.popShaderEffect} pops the effect from the stack
     * reverting to normal drawing
     * @param effect the {@link ShaderEffect} to apply to subsequent draw operations
     */
    pushShaderEffect(effect) {
        if (effect) {
            this.effects.push(effect);
            if (!app_1.IS_TEST_ENV) {
                this.getNativeContext().AddSeriesEffect(effect.getNativeEffect());
            }
        }
    }
    /**
     * Pops a {@link ShaderEffect} from the rendering pipeline. Call {@link WebGL2RenderingContext.pushShaderEffect} to apply an effect
     */
    popShaderEffect() {
        const effect = this.effects.pop();
        if (effect && !app_1.IS_TEST_ENV) {
            this.getNativeContext().RemoveSeriesEffect(effect.getNativeEffect());
        }
    }
    /**
     * @inheritDoc
     */
    createPen(stroke, strokeThickness, strokeDashArray = [], antiAliased = true) {
        throw new Error("Use Pen2DCache for creating pens instead!");
        if (app_1.IS_TEST_ENV || !stroke) {
            return undefined;
        }
        const colorInt = parseColor_1.parseColorToUIntArgb(stroke);
        if (isNaN(colorInt)) {
            throw new Error(`Color code ${stroke} cannot be converted to an ARGB integer`);
        }
        const strokeDashFloatVector = new this.webAssemblyContext.FloatVector();
        if (strokeDashArray.length) {
            strokeDashArray.forEach(item => strokeDashFloatVector.push_back(item));
        }
        return new WebGlPen_1.WebGlPen(this.webAssemblyContext.SCRTCreateDahedPen(colorInt, strokeThickness, antiAliased, strokeDashFloatVector));
    }
    /**
     * @inheritDoc
     */
    createSolidBrush(fill, opacity) {
        throw new Error("Use BrushCache for creating brushes instead!");
        if (app_1.IS_TEST_ENV || !fill) {
            return undefined;
        }
        const colorInt = parseColor_1.parseColorToUIntArgb(fill, opacity);
        const isTransparent = true;
        if (isNaN(colorInt)) {
            throw new Error(`Color code ${fill} cannot be converted to an ARGB integer`);
        }
        return new WebGlBrush_1.WebGlBrush(new this.webAssemblyContext.SCRTSolidBrush(colorInt, isTransparent));
    }
    /**
     * @inheritDoc
     */
    delete() {
        // Todo: Any cached items delete here
    }
    /**
     * @inheritDoc
     */
    drawLine(x1, y1, x2, y2, pen, viewRect) {
        if (!x1 && !y1 && !x2 && !y2) {
            return;
        }
        // TODO: pass left and top from seriesViewRect
        const left = 0;
        const top = 0;
        Guard_1.Guard.notNull(pen, "pen");
        Guard_1.Guard.isTrue(pen.getPenType() === "WasmPen", "pen must be an instance of WasmPen to be used with the WasmRenderContext");
        const scrtPen = pen.scrtPen;
        Guard_1.Guard.notNull(scrtPen, "WasmPen.scrtPen");
        const isStrips = false;
        const nativeContext = this.getNativeContext();
        const vertices = new this.webAssemblyContext.VectorColorVertex();
        try {
            const vertex0 = new this.webAssemblyContext.SCRTColorVertex(x1, y1);
            vertices.push_back(vertex0);
            vertex0.delete();
            const vertex1 = new this.webAssemblyContext.SCRTColorVertex(x2, y2);
            vertices.push_back(vertex1);
            vertex1.delete();
            nativeContext.PushMatrix();
            nativeContext.PushState();
            nativeContext.Translate(viewRect.x, viewRect.y);
            nativeContext.SetClipRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
            nativeContext.DrawLinesBatchVec(isStrips, vertices, scrtPen);
            nativeContext.PopMatrix();
            nativeContext.PopState();
        }
        finally {
            vertices.delete();
        }
    }
    /**
     * @inheritDoc
     */
    drawLines(xyValues, strokePen, viewRect, lineDrawMode = ELineDrawMode.PolyLine) {
        Guard_1.Guard.notNull(strokePen, "pen");
        Guard_1.Guard.notNull(xyValues, "xyValues");
        Guard_1.Guard.isTrue(strokePen.getPenType() === "WasmPen", "pen must be an instance of WasmPen to be used with the WasmRenderContext");
        Guard_1.Guard.isTrue(xyValues.length > 0 && xyValues.length % 2 === 0, "xyValues length must be a multiple of 2, values arranged as x0y0 x1y1 x2y2...");
        const scrtPen = strokePen.scrtPen;
        Guard_1.Guard.notNull(scrtPen, "WebGlPen.scrtPen");
        const isStrips = lineDrawMode === ELineDrawMode.PolyLine;
        const nativeContext = this.getNativeContext();
        const vertices = new this.webAssemblyContext.VectorColorVertex();
        try {
            for (let i = 0; i < xyValues.length; i += 2) {
                const vertex = new this.webAssemblyContext.SCRTColorVertex();
                vertex.m_vPosition = new this.webAssemblyContext.TSRVector3(xyValues[i], xyValues[i + 1], 0);
                vertices.push_back(vertex);
            }
            nativeContext.PushMatrix();
            nativeContext.PushState();
            nativeContext.Translate(viewRect.x, viewRect.y);
            nativeContext.SetClipRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
            nativeContext.DrawLinesBatchVec(isStrips, vertices, scrtPen);
            nativeContext.PopMatrix();
            nativeContext.PopState();
        }
        finally {
            vertices.delete();
        }
    }
    /**
     * @inheritDoc
     */
    drawRect(rect, viewRect, strokePen, fillBrush) {
        if (fillBrush) {
            const nativeContext = this.getNativeContext();
            const scrtBrush = fillBrush.scrtBrush;
            Guard_1.Guard.notNull(scrtBrush, "WebGlBrush.scrtBrush");
            const vertices = new this.webAssemblyContext.VectorRectVertex();
            const anchorParams = new this.webAssemblyContext.TSRVector4();
            try {
                anchorParams.x = 0;
                anchorParams.y = 0;
                vertices.push_back(createNativeRect_1.createNativeRect(this.webAssemblyContext, rect.x, rect.y, rect.right, rect.bottom));
                nativeContext.PushMatrix();
                nativeContext.PushState();
                nativeContext.Translate(viewRect.x, viewRect.y);
                nativeContext.SetClipRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
                nativeContext.DrawRectsBatchVec(vertices, scrtBrush, anchorParams);
                nativeContext.PopMatrix();
                nativeContext.PopState();
            }
            finally {
                anchorParams.delete();
                vertices.delete();
            }
        }
        if (strokePen) {
            this.drawLines([
                rect.right,
                rect.top,
                rect.right,
                rect.bottom,
                rect.left,
                rect.bottom,
                rect.left,
                rect.top,
                rect.right,
                rect.top
            ], strokePen, viewRect, ELineDrawMode.PolyLine);
        }
    }
}
exports.WebGlRenderContext2D = WebGlRenderContext2D;
/**
 * Should store Stores references to all cached WebGlResources {@link ICacheable}
 * Is used to invalidate the resources when the WebGL context is lost.
 */
WebGlRenderContext2D.webGlResourcesRefs = new Set();
