"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBrushInCache = exports.getScrtBrushFromCache = exports.getWebGlBrushFromCache = exports.BrushCache = void 0;
const Deleter_1 = require("../../Core/Deleter");
const Guard_1 = require("../../Core/Guard");
const createSolidBrush_1 = require("../Visuals/Helpers/createSolidBrush");
const CanvasTexture_1 = require("../Visuals/TextureManager/CanvasTexture");
const BaseCache_1 = require("./BaseCache");
const WebGlBrush_1 = require("./WebGlBrush");
/** @ignore */
const TEXTURE_SIZE = 256;
/**
 * @ignore
 */
class BrushCache extends BaseCache_1.BaseCache {
    get value() {
        if (!this.cachedEntity && (this.fill || this.fillLinearGradient)) {
            this.cachedEntity = this.create(this.fill, this.opacity, this.fillLinearGradient);
        }
        return this.cachedEntity;
    }
    /**
     * Creates or fetches a new brush with the specified params
     * @param fill
     * @param opacity
     * @param fillLinearGradient
     */
    create(fill, opacity, fillLinearGradient) {
        if (this.cachedEntity
            && fill === this.fill
            && opacity === this.opacity
            && fillLinearGradient === this.fillLinearGradient) {
            return this.cachedEntity;
        }
        this.invalidateCache();
        this.fill = fill;
        this.opacity = opacity;
        this.fillLinearGradient = fillLinearGradient;
        const brush = fillLinearGradient
            ? this.createGradientBrush()
            : this.createSolidBrush(fill, opacity);
        return this.cachedEntity = new WebGlBrush_1.WebGlBrush(brush);
    }
    invalidateCache() {
        super.invalidateCache();
        this.canvasTexture = Deleter_1.deleteSafe(this.canvasTexture);
    }
    reset() {
        this.invalidateCache();
        this.fill = undefined;
        this.opacity = undefined;
        this.fillLinearGradient = undefined;
    }
    delete() {
        this.invalidateCache();
    }
    createSolidBrush(htmlColorCode, opacity) {
        return createSolidBrush_1.createSolidBrush(this.webAssemblyContext, htmlColorCode, opacity);
    }
    createGradientBrush() {
        const gradientTexture = this.createGradientTexture().getTexture();
        return new this.webAssemblyContext.SCRTTextureBrush(gradientTexture, this.webAssemblyContext.eSCRTBrushMappingMode.PerPrimitive, 1);
    }
    createGradientTexture() {
        Guard_1.Guard.notNull(this.fillLinearGradient, "fillLinearGradient");
        const { startPoint, endPoint, gradientStops } = this.fillLinearGradient;
        this.canvasTexture = new CanvasTexture_1.CanvasTexture(this.webAssemblyContext, TEXTURE_SIZE, TEXTURE_SIZE);
        this.canvasTexture.clear();
        const ctx = this.canvasTexture.getContext();
        // BEGIN: Drawing gradient rectangle on canvas2D
        const x1 = convertRelativeToAbsolute(startPoint.x, TEXTURE_SIZE);
        const y1 = convertRelativeToAbsolute(startPoint.y, TEXTURE_SIZE);
        const x2 = convertRelativeToAbsolute(endPoint.x, TEXTURE_SIZE);
        const y2 = convertRelativeToAbsolute(endPoint.y, TEXTURE_SIZE);
        const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        gradientStops.forEach(el => {
            gradient.addColorStop(el.offset, el.color);
        });
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);
        // END: Drawing gradient rectangle on canvas2D
        this.canvasTexture.copyTexture();
        return this.canvasTexture;
    }
}
exports.BrushCache = BrushCache;
/**
 * Retrieves a native {@link WebGlBrush} Brush from the provided {@link BrushCache} cache object
 * @param BrushCache The object that stores a brush
 * @returns new or existing instance of {@link WebGlPen}}
 */
exports.getWebGlBrushFromCache = (cache) => {
    Guard_1.Guard.notNull(cache, "cache");
    return cache.value;
};
// TODO: probably we should consider some approach to be consistent in using one of SCRTBrush or WebGlBrush
/**
 * Retrieves a native {@link SCRTBrush} Brush from the provided {@link BrushCache} cache object.
 * The retrieved entity is a wrapper around {@link SCRTPen}
 * @param cache The object that stores a brush
 * @returns new or existing instance of {@link SCRTBrush}}
 */
exports.getScrtBrushFromCache = (cache) => {
    const webGlBrush = exports.getWebGlBrushFromCache(cache);
    return webGlBrush === null || webGlBrush === void 0 ? void 0 : webGlBrush.scrtBrush;
};
/**
 * Creates a native {@link SCRTBrush} brush from html color code string passed in and caches it
 * @param cache The object that will store a brush
 * @param fill The HTML Color code
 * @param opacity The opacity factor.
 * @param fillGradientLinear The gradient params.
 * @returns new or existing instance of {@link SCRTBrush}}
 */
exports.createBrushInCache = (cache, fill, opacity, fillGradientLinear) => {
    Guard_1.Guard.notNull(cache, "brushCache");
    const brush = cache.create(fill, opacity, fillGradientLinear);
    return brush.scrtBrush;
};
/** @ignore */
const convertRelativeToAbsolute = (relativeValue, size) => {
    return relativeValue * size;
};
