"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RubberBandRect = void 0;
const constants_1 = require("./constants");
/**
 * Used by the {@link RubberBandXyZoomModifier} to draw an {@link SVGSVGElement | SVGElement} rectangle over the chart.
 */
class RubberBandRect {
    constructor(svgRoot, fill, stroke, strokeThickness) {
        this.x1Property = 0;
        this.x2Property = 0;
        this.y1Property = 0;
        this.y2Property = 0;
        this.isHiddenProperty = true;
        this.svgRoot = svgRoot;
        this.create(fill, stroke, strokeThickness);
    }
    // PROPERTY
    get x1() {
        return this.x1Property;
    }
    set x1(value) {
        this.x1Property = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.X1);
    }
    get x2() {
        return this.x2Property;
    }
    set x2(value) {
        this.x2Property = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.X2);
    }
    get y1() {
        return this.y1Property;
    }
    set y1(value) {
        this.y1Property = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.Y1);
    }
    get y2() {
        return this.y2Property;
    }
    set y2(value) {
        this.y2Property = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.Y2);
    }
    get isHidden() {
        return this.isHiddenProperty;
    }
    set isHidden(value) {
        this.isHiddenProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_HIDDEN);
    }
    delete() {
        this.svgRoot.removeChild(this.svg);
    }
    // PRIVATE
    create(fill, stroke, strokeThickness) {
        if (this.svg) {
            this.delete();
        }
        const svgString = svgTemplate(fill, stroke, strokeThickness);
        const svgNode = document.createRange().createContextualFragment(svgString);
        this.svgRoot.appendChild(svgNode);
        this.svg = this.svgRoot.lastChild;
        this.svg.setAttribute("x", "100px");
        this.svg.setAttribute("y", "100px");
    }
    update(propertyName) {
        if (propertyName === constants_1.PROPERTY.IS_HIDDEN) {
            this.svg.style.display = this.isHidden ? "none" : "block";
        }
        if (propertyName === constants_1.PROPERTY.X1 || propertyName === constants_1.PROPERTY.X2) {
            const width = Math.abs(this.x2 - this.x1);
            this.svg.setAttribute("x", this.x1.toString());
            this.svg.setAttribute("width", `${width}px`);
        }
        if (propertyName === constants_1.PROPERTY.Y1 || propertyName === constants_1.PROPERTY.Y2) {
            const height = Math.abs(this.y2 - this.y1);
            this.svg.setAttribute("y", this.y1.toString());
            this.svg.setAttribute("height", `${height}px`);
        }
    }
    notifyPropertyChanged(propertyName) {
        this.update(propertyName);
    }
}
exports.RubberBandRect = RubberBandRect;
/**
 * @ignore
 */
const svgTemplate = (fill, stroke, strokeThickness, width = 0, height = 0) => {
    return `<svg width="${width}" height="${height}" style="display: none">
        <rect width="100%" height="100%" fill="${fill}" stroke="${stroke}" stroke-width="${strokeThickness}"/>
    </svg>`;
};
