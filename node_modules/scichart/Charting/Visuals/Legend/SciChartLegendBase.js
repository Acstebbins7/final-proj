"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcLegendPosition = exports.SciChartLegendBase = exports.ELegendPlacement = exports.ELegendOrientation = void 0;
const app_1 = require("../../../constants/app");
const Rect_1 = require("../../../Core/Rect");
/**
 * Enumeration constants to define legend orientation
 */
var ELegendOrientation;
(function (ELegendOrientation) {
    ELegendOrientation[ELegendOrientation["Vertical"] = 0] = "Vertical";
    ELegendOrientation[ELegendOrientation["Horizontal"] = 1] = "Horizontal";
})(ELegendOrientation = exports.ELegendOrientation || (exports.ELegendOrientation = {}));
/**
 * Enumeration constants to define legend placement
 */
var ELegendPlacement;
(function (ELegendPlacement) {
    ELegendPlacement[ELegendPlacement["TopLeft"] = 0] = "TopLeft";
    ELegendPlacement[ELegendPlacement["TopRight"] = 1] = "TopRight";
    ELegendPlacement[ELegendPlacement["BottomLeft"] = 2] = "BottomLeft";
    ELegendPlacement[ELegendPlacement["BottomRight"] = 3] = "BottomRight";
    // ManualPlacement
})(ELegendPlacement = exports.ELegendPlacement || (exports.ELegendPlacement = {}));
/**
 * Base class for legends in the SciChart library
 */
class SciChartLegendBase {
    constructor() {
        this.orientationProperty = ELegendOrientation.Vertical;
        this.showLegendProperty = true;
        this.placementProperty = ELegendPlacement.TopLeft;
        this.marginProperty = 10;
        this.isDirty = true;
    }
    setInvalidateParentSurface(value) {
        this.invalidateParentSurface = value;
    }
    /**
     * Set the root div in HTML where the legend will be placed
     * @param rootDivProperty
     */
    setRootDiv(rootDivProperty) {
        this.rootDiv = rootDivProperty;
    }
    /**
     * Set the series view rect - a rectangle defining where on the parent chart the legend is shown
     * @param seriesViewRect
     */
    setSeriesViewRect(seriesViewRect) {
        if (this.seriesViewRect !== seriesViewRect) {
            this.seriesViewRect = seriesViewRect;
            this.notifyPropertyChanged();
        }
    }
    /**
     * Sets the parent {@link ISciChartSurfaceBase}
     */
    setParentSurface(scs) {
        this.parentSurfaceProperty = scs;
    }
    /**
     * Update the legend
     */
    update() {
        if (!this.isDirty && this.div) {
            return;
        }
        if (this.div) {
            this.delete();
        }
        if (this.showLegend) {
            this.create();
        }
        this.isDirty = false;
    }
    /**
     * Invalidate the legend, hinting a redraw is needed
     */
    invalidateLegend() {
        this.isDirty = true;
    }
    /**
     * Gets and sets the legend orientation. See {@link ELegendOrientation} for a list of values
     */
    get orientation() {
        return this.orientationProperty;
    }
    /**
     * Gets and sets the legend orientation. See {@link ELegendOrientation} for a list of values
     */
    set orientation(orientation) {
        this.orientationProperty = orientation;
        this.notifyPropertyChanged();
    }
    /**
     * When true, the legend is shown, else it is hidden
     */
    get showLegend() {
        return this.showLegendProperty;
    }
    /**
     * When true, the legend is shown, else it is hidden
     */
    set showLegend(value) {
        this.showLegendProperty = value;
        this.notifyPropertyChanged();
    }
    /**
     * Gets or sets the legend placement. See {@link ELegendPlacement} for a list of values
     */
    get placement() {
        return this.placementProperty;
    }
    /**
     * Gets or sets the legend placement. See {@link ELegendPlacement} for a list of values
     */
    set placement(value) {
        this.placementProperty = value;
        this.notifyPropertyChanged();
    }
    /**
     * Gets or sets the margin in pixels
     */
    get margin() {
        return this.marginProperty;
    }
    /**
     * Gets or sets the margin in pixels
     */
    set margin(value) {
        this.marginProperty = value;
        this.notifyPropertyChanged();
    }
    /**
     * @inheritDoc
     */
    delete() {
        // TODO: remove listeners from renderable series to prevent memory leaks in older browsers
        this.rootDiv.removeChild(this.div);
        this.div = undefined;
    }
    /**
     * Notifies listeners of {@link invalidateParentSurface} that a property has changed
     */
    notifyPropertyChanged() {
        this.isDirty = true;
        if (this.invalidateParentSurface) {
            this.invalidateParentSurface();
        }
    }
    /**
     * Creates the legend in the DOM
     */
    create() {
        const div = document.createElement("div");
        div.style.position = "absolute";
        div.style.pointerEvents = "auto";
        div.style.padding = "5px";
        div.style.borderRadius = "3px";
        div.style.backgroundColor = this.parentSurfaceProperty.themeProvider.legendBackgroundBrush;
        div.style.color = this.parentSurfaceProperty.themeProvider.labelForegroundBrush;
        div.style.display = this.orientationProperty === ELegendOrientation.Vertical ? "block" : "flex";
        div.innerHTML = this.getLegendHtml();
        this.rootDiv.appendChild(div);
        const divWidth = div.offsetWidth;
        const divHeight = div.offsetHeight;
        const position = exports.calcLegendPosition(this.seriesViewRect, Rect_1.Rect.create(0, 0, divWidth, divHeight), this.margin, this.placement);
        div.style.left = `${position.left}px`;
        div.style.top = `${position.top}px`;
        this.div = div;
        if (!app_1.IS_TEST_ENV) {
            this.addEventListeners();
        }
    }
}
exports.SciChartLegendBase = SciChartLegendBase;
exports.calcLegendPosition = (seriesViewRect, div, margin, placement) => {
    switch (placement) {
        case ELegendPlacement.TopLeft: {
            const left = seriesViewRect.left + margin;
            const top = seriesViewRect.top + margin;
            return { left, top };
        }
        case ELegendPlacement.TopRight: {
            const left = seriesViewRect.right - (margin + div.width);
            const top = seriesViewRect.top + margin;
            return { left, top };
        }
        case ELegendPlacement.BottomLeft: {
            const left = seriesViewRect.left + margin;
            const top = seriesViewRect.bottom - (margin + div.height);
            return { left, top };
        }
        case ELegendPlacement.BottomRight: {
            const left = seriesViewRect.right - (margin + div.width);
            const top = seriesViewRect.bottom - (margin + div.height);
            return { left, top };
        }
    }
};
