"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLocateFile = exports.copyToCanvas = exports.getMasterCanvas = exports.createChartDestination = exports.SciChartSurfaceBase = exports.ESurfaceType = void 0;
const licenseManager2D_1 = require("../../Charting/Visuals/licenseManager2D");
const app_1 = require("../../constants/app");
const EventHandler_1 = require("../../Core/EventHandler");
const Guard_1 = require("../../Core/Guard");
const MouseManager_1 = require("../../Core/Mouse/MouseManager");
const ObservableArray_1 = require("../../Core/ObservableArray");
const PropertyChangedEventArgs_1 = require("../../Core/PropertyChangedEventArgs");
const guid_1 = require("../../utils/guid");
const SciChartJSDarkTheme_1 = require("../Themes/SciChartJSDarkTheme");
const UpdateSuspender_1 = require("./UpdateSuspender");
/**
 * Enum constants to specify SciChartSurface type
 */
var ESurfaceType;
(function (ESurfaceType) {
    /**
     * A 2D Cartesian {@link SciChartSurface}
     */
    ESurfaceType["SciChartSurfaceType"] = "SciChartSurfaceType";
    /**
     * A 3D Cartesian {@link SciChart3DSurface}
     */
    ESurfaceType["SciChart3DSurfaceType"] = "SciChart3DSurfaceType";
})(ESurfaceType = exports.ESurfaceType || (exports.ESurfaceType = {}));
/**
 * @summary The base class for a 2D Cartesian {@link SciChartSurface} or 3D Cartesian {@link SciChart3DSurface} within SciChart -
 * High Performance Realtime {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 * See derived types {@link SciChartSurface} (2D Charts) and {@link SciChart3DSurface} (3D Charts) for more specific instructions on how
 * to use the SciChartSurface and create a 2D or 3D {@link https://www.scichart.com/javascript-chart-features | JavaScript Chart}
 */
class SciChartSurfaceBase {
    /**
     * Creates an instance of a SciChartSurfaceBase
     * @param webAssemblyContext  The {@link TSciChart | SciChart 2D WebAssembly Context} or {@link TSciChart | SciChart 3D WebAssembly Context}
     * containing native methods and access to our WebGL2 WebAssembly Rendering Engine
     * @param canvases A list of {@link TSciChartSurfaceCanvases} to draw to
     * @param masterCanvasId The master canvas id
     */
    constructor(webAssemblyContext, canvases = {}, masterCanvasId) {
        this.themeProviderProperty = new SciChartJSDarkTheme_1.SciChartJSDarkTheme();
        this.previousThemeProviderProperty = new SciChartJSDarkTheme_1.SciChartJSDarkTheme();
        this.isInitializedProperty = false;
        this.isDeletedProperty = false;
        this.suspendableIdProperty = guid_1.generateGuid();
        this.isAlphaEnabledProperty = true;
        Guard_1.Guard.notNull(webAssemblyContext, "webAssemblyContext");
        this.domChartRoot = canvases.domChartRoot;
        this.domCanvasWebGL = canvases.domCanvasWebGL;
        this.domCanvas2D = canvases.domCanvas2D;
        this.domSvgContainer = canvases.domSvgContainer;
        this.domSvgAdornerLayer = canvases.domSvgAdornerLayer;
        this.domDivContainer = canvases.domDivContainer;
        if (!app_1.IS_TEST_ENV && masterCanvasId) {
            this.domMasterCanvas = document.getElementById(masterCanvasId);
        }
        this.sharedWasmContext = webAssemblyContext;
        this.propertyChanged = new EventHandler_1.EventHandler();
        // Flag which ensures Typescript side drives emscripten rendering (one render per draw request)
        webAssemblyContext.TSRSetDrawRequestsEnabled(true);
        // Setup chart modifiers
        this.detachChartModifier = this.detachChartModifier.bind(this);
        this.attachChartModifier = this.attachChartModifier.bind(this);
        this.chartModifiers = new ObservableArray_1.ObservableArray();
        this.chartModifiers.collectionChanged.subscribe(arg => {
            var _a, _b;
            (_a = arg.getOldItems()) === null || _a === void 0 ? void 0 : _a.forEach(cm => this.detachChartModifier(cm));
            (_b = arg.getNewItems()) === null || _b === void 0 ? void 0 : _b.forEach(cm => this.attachChartModifier(cm));
        });
        // Setup mouse manager
        this.mouseManager = new MouseManager_1.MouseManager(this);
        if (canvases.domCanvasWebGL) {
            this.mouseManager.subscribe(canvases.domCanvasWebGL);
        }
        else if (canvases.domCanvas2D) {
            this.mouseManager.subscribe(canvases.domCanvas2D);
        }
    }
    /**
     * Sets the runtime license key.  Use for full licenses or trials only, not developer licenses.
     * @param keyCode
     */
    static setRuntimeLicenseKey(keyCode) {
        licenseManager2D_1.licenseManager.setRuntimeLicenseKey(keyCode);
    }
    /**
     * Sets the endpoint for validating a runtime license key with the server.  Must be a relative path.
     * @default api/license
     * @param endpoint
     */
    static setServerLicenseEndpoint(endpoint) {
        licenseManager2D_1.licenseManager.setServerLicenseEndpoint(endpoint);
    }
    /**
     * Sets function that will be called by the framework to validate a runtime license from the server,
     * if you need to add additional handling, such as custom authentication.
     * The request sent to the server must include the queryString section passed in, which does not come with a leading ?
     * @param callback
     */
    static setLicenseCallback(callback) {
        licenseManager2D_1.licenseManager.setLicenseCallback(callback);
    }
    /**
     * Gets or sets the SciChartSurface Background as an HTML color code
     */
    get background() {
        return this.backgroundProperty;
    }
    /**
     * Gets or sets the SciChartSurface Background as an HTML color code
     */
    set background(background) {
        this.backgroundProperty = background;
        this.applySciChartBackground(background, this.isAlphaEnabledProperty);
        this.notifyPropertyChanged("Background");
    }
    /**
     * Used internally, updates background ater switching beetween different SciChartSurfaces
     */
    updateBackground() {
        this.applySciChartBackground(this.backgroundProperty, this.isAlphaEnabledProperty);
    }
    /**
     * Gets or sets the SciChartSurface Chart Background with Alpha value
     */
    get backgroundCompletelyTransparentEnabled() {
        return this.isAlphaEnabledProperty;
    }
    /**
     * Gets or sets the SciChartSurface Chart Background with Alpha value
     */
    set backgroundCompletelyTransparentEnabled(alphaEnabled) {
        this.isAlphaEnabledProperty = alphaEnabled;
        this.applySciChartBackground(this.backgroundProperty, alphaEnabled);
        this.notifyPropertyChanged("Background");
    }
    get isCopyCanvasSurface() {
        return !this.domCanvasWebGL && this.domCanvas2D;
    }
    /**
     * Gets the Series View {@link Rect}, a rectangle relative to the entire size of the {@link SciChartSurfaceBase}
     */
    get seriesViewRect() {
        return this.seriesViewRectProperty;
    }
    /**
     * Used internally - gets other SciChartSurfaces
     */
    get otherSurfaces() {
        if (!this.destinations) {
            return [];
        }
        return this.destinations.map(el => el.sciChartSurface).filter(el2 => el2 !== this);
    }
    /**
     * Used internally - gets isInitialized flag
     */
    get isInitialized() {
        return this.isInitializedProperty;
    }
    /**
     * Used internally - gets isDeleted flag
     */
    get isDeleted() {
        return this.isDeletedProperty;
    }
    /**
     * @inheritDoc
     */
    get isSuspended() {
        return UpdateSuspender_1.UpdateSuspender.getIsSuspended(this);
    }
    /**
     * @inheritDoc
     */
    get suspendableId() {
        return this.suspendableIdProperty;
    }
    /**
     * @inheritDoc
     */
    decrementSuspend() { }
    /**
     * @inheritDoc
     */
    resumeUpdates(suspender) {
        if (suspender.shouldResumeTarget) {
            this.invalidateElement();
        }
    }
    /**
     * @inheritDoc
     */
    suspendUpdates() {
        return new UpdateSuspender_1.UpdateSuspender(this);
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        this.previousThemeProviderProperty = this.themeProviderProperty;
        this.themeProviderProperty = themeProvider;
        this.applySciChartBackground(themeProvider.sciChartBackground);
        this.chartModifiers.asArray().forEach(el => el.applyTheme(themeProvider));
        this.invalidateElement();
    }
    /**
     * Used internally - gets the previous {@link IThemeProvider}
     */
    get themeProvider() {
        return this.themeProviderProperty;
    }
    /**
     * Used internally - gets the previous {@link IThemeProvider}
     */
    get previousThemeProvider() {
        return this.previousThemeProviderProperty;
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.isDeletedProperty = true;
        // Todo: override in derived classes to delete webassembly objects
    }
    getMainCanvas() {
        return this.domCanvasWebGL || this.domCanvas2D;
    }
    /**
     * Sets the Series View {@link Rect}, a rectangle relative to the entire size of the {@link SciChartSurfaceBase}
     * @param seriesViewRect a {@link Rect} which defines the portion of the view for drawing series
     */
    setSeriesViewRect(seriesViewRect) {
        this.seriesViewRectProperty = seriesViewRect;
    }
    /**
     * Used internally - sets destinations
     */
    setDestinations(destinations) {
        this.destinations = destinations;
    }
    /**
     * Used internally, the flag is set after {@link SciChartSurfaceBase} is initialized
     */
    setIsInitialized() {
        this.isInitializedProperty = true;
    }
    /**
     * Detaches a {@link ChartModifierBase2D} from the {@link SciChartSurfaceBase}
     * @param chartModifier
     */
    detachChartModifier(chartModifier) {
        chartModifier.invalidateParentCallback = undefined;
        chartModifier.onDetach();
        chartModifier.setParentSurface(undefined);
        this.invalidateElement();
    }
    /**
     * Attaches a {@link ChartModifierBase2D} to the {@link SciChartSurfaceBase}
     * @param chartModifier
     */
    attachChartModifier(chartModifier) {
        if (chartModifier.invalidateParentCallback) {
            throw new Error("Invalid operation in sciChartSurface.attachChartModifier, this chartModifier has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another");
        }
        if (this.themeProviderProperty) {
            chartModifier.applyTheme(this.themeProviderProperty);
        }
    }
    /**
     * @summary Notifies subscribers of {@link SciChartSurfaceBase.propertyChanged} that a property has changed and the chart requires redrawing
     * @description SciChart provides fully reactive components, changing any property or changing data will cause the {@link SciChartSurfaceBase} to
     * redraw where necessary. This method notifies subscribers of the {@link SciChartSurfaceBase.propertyChanged} {@link EventHandler}
     * that a property has changed.
     * @param propertyName The name of the property which has changed
     */
    notifyPropertyChanged(propertyName) {
        var _a;
        (_a = this.propertyChanged) === null || _a === void 0 ? void 0 : _a.raiseEvent(new PropertyChangedEventArgs_1.PropertyChangedEventArgs(propertyName));
        this.invalidateElement();
    }
    /**
     * Changes the size of the DOM element where the {@link SciChartSurfaceBase} resides.
     * @param width
     * @param height
     */
    changeDomViewportSize(width, height) {
        this.changeMasterCanvasViewportSize(width, height);
        if (this.domCanvasWebGL) {
            this.domCanvasWebGL.width = width;
            this.domCanvasWebGL.height = height;
        }
        if (this.domCanvas2D) {
            this.domCanvas2D.width = width;
            this.domCanvas2D.height = height;
        }
        // if (this.domSvgContainer) {
        //     this.domSvgContainer.setAttribute("width", width.toString());
        //     this.domSvgContainer.setAttribute("height", height.toString());
        // }
        // if (this.domSvgAdornerLayer) {
        //     this.domSvgAdornerLayer.setAttribute("width", width.toString());
        //     this.domSvgAdornerLayer.setAttribute("height", height.toString());
        // }
        if (this.domDivContainer) {
            this.domDivContainer.style.height = `${height}px`;
        }
    }
    changeMasterCanvasViewportSize(width, height) {
        if (this.domMasterCanvas) {
            if (width > this.domMasterCanvas.width) {
                this.domMasterCanvas.width = width;
            }
            if (height > this.domMasterCanvas.height) {
                this.domMasterCanvas.height = height;
            }
        }
    }
}
exports.SciChartSurfaceBase = SciChartSurfaceBase;
exports.createChartDestination = (canvasId) => {
    const canvas = document.querySelector(`#${canvasId}`);
    if (!canvas)
        return undefined;
    return {
        canvas,
        GetHeight() {
            return this.canvas.height;
        },
        GetWidth() {
            return this.canvas.width;
        },
        GetID() {
            return this.canvas.id;
        }
    };
};
exports.getMasterCanvas = (canvasElementId) => {
    let element = document.querySelector(`#${canvasElementId}`);
    if (!element) {
        const canvasWebGL = document.createElement("canvas");
        canvasWebGL.id = `${canvasElementId}`;
        canvasWebGL.style.display = "none";
        document.body.appendChild(canvasWebGL);
        canvasWebGL.getContext("webgl2", {
            premultipliedAlpha: true
        });
        element = canvasWebGL;
    }
    // element.getContext("webgl2", {
    //     preserveDrawingBuffer: true
    // });
    return element;
};
exports.copyToCanvas = (masterCanasId) => (destinationId) => {
    const sourceCanvas = document.querySelector(`#${masterCanasId}`);
    // const sourceCanvasContext = sourceCanvas.getContext("webgl2", {
    //     preserveDrawingBuffer: true
    // });
    const destinationCanvas = document.querySelector(`#${destinationId}`);
    if (destinationCanvas) {
        const destinationCanvasContext = destinationCanvas.getContext("2d");
        destinationCanvasContext.clearRect(0, 0, destinationCanvasContext.canvas.width, destinationCanvasContext.canvas.height);
        // Initial fill with black
        destinationCanvasContext.fillStyle = "rgba(0,0,0,0)";
        const { clientWidth, clientHeight } = destinationCanvasContext.canvas;
        destinationCanvasContext.fillRect(0, 0, clientWidth, clientHeight);
        destinationCanvasContext.drawImage(sourceCanvas, 0, 0);
    }
};
/** @ignore */
exports.getLocateFile = (sciChartConfig) => (path, prefix) => {
    if (path.endsWith(".wasm") && sciChartConfig.wasmUrl) {
        return sciChartConfig.wasmUrl;
    }
    if (path.endsWith(".data") && sciChartConfig.dataUrl) {
        return sciChartConfig.dataUrl;
    }
    return prefix + path;
};
