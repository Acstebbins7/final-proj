"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePointMarker = void 0;
const Deleter_1 = require("../../../Core/Deleter");
const WebGlRenderContext2D_1 = require("../../Drawing/WebGlRenderContext2D");
const CanvasTexture_1 = require("../TextureManager/CanvasTexture");
const Constants_1 = require("./Constants");
/**
 * The Base class for a PointMarker in SciChart - High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}.
 * @description PointMarkers may be displayed on {@link IRenderableSeries | Renderable Series} to add scatter-points to charts.
 * For example: setting the {@link XyScatterRenderableSeries.pointMarker} property or {@link FastLineRenderableSeries.pointMarker} property
 * will render a point at each xy data-value
 * @remarks
 * See derived types of {@link BasePointMarker} for specific point-marker types.
 */
class BasePointMarker {
    /**
     * Creates an instance of the {@link BasePointMarker}
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param options Optional parameters of type {@link IPointMarkerOptions} used to configure the point-marker at instantiation time
     */
    constructor(webAssemblyContext, options) {
        var _a, _b, _c, _d, _e, _f;
        this.fillProperty = "#FF0000";
        this.heightProperty = 5;
        this.opacityProperty = 1;
        this.strokeProperty = "#0000FF";
        this.strokeThicknessProperty = 1;
        this.widthProperty = 5;
        this.webAssemblyContext = webAssemblyContext;
        this.widthProperty = (_a = options === null || options === void 0 ? void 0 : options.width) !== null && _a !== void 0 ? _a : this.widthProperty;
        this.heightProperty = (_b = options === null || options === void 0 ? void 0 : options.height) !== null && _b !== void 0 ? _b : this.heightProperty;
        this.fillProperty = (_c = options === null || options === void 0 ? void 0 : options.fill) !== null && _c !== void 0 ? _c : this.fillProperty;
        this.strokeProperty = (_d = options === null || options === void 0 ? void 0 : options.stroke) !== null && _d !== void 0 ? _d : this.strokeProperty;
        this.strokeThicknessProperty = (_e = options === null || options === void 0 ? void 0 : options.strokeThickness) !== null && _e !== void 0 ? _e : this.strokeThicknessProperty;
        this.opacityProperty = (_f = options === null || options === void 0 ? void 0 : options.opacity) !== null && _f !== void 0 ? _f : this.opacityProperty;
        // add to the list of objects that create and store WebGL resources
        WebGlRenderContext2D_1.WebGlRenderContext2D.webGlResourcesRefs.add(this);
    }
    /**
     * Gets or sets the point-marker fill as an HTML Color Code
     */
    get fill() {
        return this.fillProperty;
    }
    /**
     * Gets or sets the point-marker fill as an HTML Color Code
     */
    set fill(fill) {
        const oldValue = this.fillProperty;
        this.fillProperty = fill;
        this.notifyPropertyChanged(Constants_1.PROPERTY.FILL, fill, oldValue);
    }
    /**
     * Gets or sets the point-marker stroke as an HTML Color Code
     */
    get stroke() {
        return this.strokeProperty;
    }
    /**
     * Gets or sets the point-marker stroke as an HTML Color Code
     */
    set stroke(stroke) {
        const oldValue = this.strokeProperty;
        this.strokeProperty = stroke;
        this.notifyPropertyChanged(Constants_1.PROPERTY.STROKE, stroke, oldValue);
    }
    /**
     * Gets or sets the width of the point-marker in pixels
     */
    get width() {
        return this.widthProperty;
    }
    /**
     * Gets or sets the width of the point-marker in pixels
     */
    set width(width) {
        const oldValue = this.widthProperty;
        this.widthProperty = width;
        this.notifyPropertyChanged(Constants_1.PROPERTY.WIDTH, width, oldValue);
    }
    /**
     * Gets or sets the height of the point-marker in pixels
     */
    get height() {
        return this.heightProperty;
    }
    /**
     * Gets or sets the height of the point-marker in pixels
     */
    set height(height) {
        const oldValue = this.heightProperty;
        this.heightProperty = height;
        this.notifyPropertyChanged(Constants_1.PROPERTY.HEIGHT, height, oldValue);
    }
    /**
     * Gets or sets the stroke-thickness of the point-marker in pixels
     */
    get strokeThickness() {
        return this.strokeThicknessProperty;
    }
    /**
     * Gets or sets the stroke-thickness of the point-marker in pixels
     */
    set strokeThickness(strokeThickness) {
        const oldValue = this.strokeThicknessProperty;
        this.strokeThicknessProperty = strokeThickness;
        this.notifyPropertyChanged(Constants_1.PROPERTY.STROKE_THICKNESS, strokeThickness, oldValue);
    }
    /**
     * Gets or sets the opacity of the point-marker
     */
    get opacity() {
        return this.opacityProperty;
    }
    /**
     * Gets or sets the opacity of the point-marker
     */
    set opacity(opacity) {
        const oldValue = this.opacityProperty;
        this.opacityProperty = opacity;
        this.applyOpacity(opacity);
        this.notifyPropertyChanged(Constants_1.PROPERTY.OPACITY, opacity, oldValue);
    }
    /**
     * Gets a {@link CanvasTexture} object which represents the point-marker sprite instance to draw
     * @remarks note {@link CanvasTexture} implements {@link IDeletable} and must be deleted manually to free memory
     */
    getSprite() {
        if (this.spriteTextures === undefined) {
            this.spriteTextures = this.createCanvasTexture();
            this.applyOpacity(this.opacityProperty);
        }
        return this.spriteTextures.spriteTexture;
    }
    /**
     * Gets a {@link CanvasTexture} object which represents the stroke mask sprite instance to use for points,
     * which appearance is overridden by a Palette Provider
     * @remarks note {@link CanvasTexture} implements {@link IDeletable} and must be deleted manually to free memory
     */
    getStrokeMask() {
        if (this.spriteTextures === undefined) {
            this.spriteTextures = this.createCanvasTexture();
        }
        return this.spriteTextures.strokeMask;
    }
    /**
     * Gets a {@link CanvasTexture} object which represents the fill mask sprite instance to use for points,
     * which appearance is overridden by a Palette Provider
     * @remarks note {@link CanvasTexture} implements {@link IDeletable} and must be deleted manually to free memory
     */
    getFillMask() {
        if (this.spriteTextures === undefined) {
            this.spriteTextures = this.createCanvasTexture();
        }
        return this.spriteTextures.fillMask;
    }
    invalidateCache() {
        if (this.spriteTextures) {
            Deleter_1.deleteSafe(this.spriteTextures.spriteTexture);
            Deleter_1.deleteSafe(this.spriteTextures.strokeMask);
            Deleter_1.deleteSafe(this.spriteTextures.fillMask);
            this.spriteTextures = undefined;
        }
    }
    resetCache() {
        this.invalidateCache();
        this.widthProperty = undefined;
        this.heightProperty = undefined;
        this.fillProperty = undefined;
        this.strokeProperty = undefined;
        this.strokeThicknessProperty = undefined;
        this.opacityProperty = undefined;
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.invalidateCache();
        WebGlRenderContext2D_1.WebGlRenderContext2D.webGlResourcesRefs.delete(this);
    }
    /**
     * Called internally - creates the {@link CanvasTexture} object and calls {@link drawSprite} for creating the cached texture to draw
     */
    createCanvasTexture() {
        const widthPadded = this.width + this.strokeThickness + 1;
        const heightPadded = this.height + this.strokeThickness + 1;
        const spriteTexture = new CanvasTexture_1.CanvasTexture(this.webAssemblyContext, widthPadded, heightPadded);
        spriteTexture.clear();
        this.drawSprite(spriteTexture.getContext(), widthPadded, heightPadded, this.stroke, this.strokeThickness, this.fill);
        spriteTexture.copyTexture();
        const strokeMask = new CanvasTexture_1.CanvasTexture(this.webAssemblyContext, widthPadded, heightPadded);
        strokeMask.clear();
        this.drawSprite(strokeMask.getContext(), widthPadded, heightPadded, "#ffffffff", this.strokeThickness, "#00000000");
        strokeMask.copyTexture();
        const fillMask = new CanvasTexture_1.CanvasTexture(this.webAssemblyContext, widthPadded, heightPadded);
        fillMask.clear();
        this.drawSprite(fillMask.getContext(), widthPadded, heightPadded, "#00000000", 0, "#ffffffff");
        fillMask.copyTexture();
        return { spriteTexture, strokeMask, fillMask };
    }
    /**
     * Notifies listeners to {@link invalidateParentCallback} that a property has changed and redraw is required
     * @param propertyName the property name
     */
    notifyPropertyChanged(propertyName, newValue, oldValue) {
        var _a, _b, _c;
        if (newValue === oldValue || propertyName === Constants_1.PROPERTY.OPACITY) {
            return;
        }
        // Recreate spriteTexture
        if (this.spriteTextures) {
            (_a = this.spriteTextures.spriteTexture) === null || _a === void 0 ? void 0 : _a.delete();
            (_b = this.spriteTextures.strokeMask) === null || _b === void 0 ? void 0 : _b.delete();
            (_c = this.spriteTextures.fillMask) === null || _c === void 0 ? void 0 : _c.delete();
            this.spriteTextures = undefined;
        }
        this.spriteTextures = this.createCanvasTexture();
        if (this.invalidateParentCallback) {
            this.invalidateParentCallback();
        }
    }
    applyOpacity(opacity) {
        var _a, _b, _c;
        if (this.spriteTextures) {
            (_a = this.spriteTextures.spriteTexture) === null || _a === void 0 ? void 0 : _a.applyOpacity(opacity);
            (_b = this.spriteTextures.strokeMask) === null || _b === void 0 ? void 0 : _b.applyOpacity(opacity);
            (_c = this.spriteTextures.fillMask) === null || _c === void 0 ? void 0 : _c.applyOpacity(opacity);
        }
    }
}
exports.BasePointMarker = BasePointMarker;
