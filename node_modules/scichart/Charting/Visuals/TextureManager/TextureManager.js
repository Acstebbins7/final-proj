"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deviderForLastCoordinate = exports.deviderForCoordinate = exports.measureTextWidth = exports.measureTextHeight = exports.TextureManager = void 0;
const app_1 = require("../../../constants/app");
const AxisAlignment_1 = require("../../../types/AxisAlignment");
const convertToPixel_1 = require("../../../utils/convertToPixel");
/** @ignore */
const DEFAULT_HEIGHT = 1080;
/** @ignore */
const DEFAULT_WIDTH = 1920;
/** @ignore */
const PT_TO_PX = 96 / 72;
/** @ignore */
const PX_TO_PT = 72 / 96;
class TextureManager {
    constructor(webAssemblyContext) {
        this.webAssemblyContext = webAssemblyContext;
        if (!app_1.IS_TEST_ENV) {
            this.canvas = document.createElement("canvas");
            this.canvas.width = DEFAULT_WIDTH;
            this.canvas.height = DEFAULT_HEIGHT;
            this.ctx = this.canvas.getContext("2d");
        }
    }
    createTextTexture(text, fontStyle, fontWeight, fontSizePx, fontFamily, color, padding = 0, backgroundColor, displayVertically, displayMirrored, opacity) {
        if (app_1.IS_TEST_ENV)
            return this.createMockTexture();
        this.ctx.globalAlpha = opacity !== null && opacity !== void 0 ? opacity : 1;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        if (backgroundColor) {
            this.ctx.fillStyle = backgroundColor;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
        this.ctx.fillStyle = color;
        this.ctx.font = `${fontStyle} ${fontWeight} ${fontSizePx}px ${fontFamily}`;
        const textureWidth = exports.measureTextWidth(this.ctx, text) + 4 * padding;
        const textureHeight = exports.measureTextHeight(fontSizePx) + 2 * padding;
        const fontSizePt = Math.ceil(fontSizePx * PX_TO_PT);
        if (displayVertically) {
            this.ctx.save();
            if (displayMirrored) {
                this.ctx.rotate(Math.PI * 0.5);
                this.ctx.fillText(text, 2 * padding, -2 * padding);
            }
            else {
                this.ctx.rotate(Math.PI * 1.5);
                this.ctx.fillText(text, 2 * padding - textureWidth, fontSizePt + padding);
            }
            this.ctx.restore();
            return this.createTextureFromCtxBuffer(textureHeight, textureWidth);
        }
        this.ctx.fillText(text, 2 * padding, fontSizePt + padding);
        return this.createTextureFromCtxBuffer(textureWidth, textureHeight);
    }
    createAxisMarkerTexture(axisAlignment, text, fontStyle, fontWeight, fontSizePx, fontFamily, color, padding = 0, backgroundColor, opacity) {
        if (app_1.IS_TEST_ENV)
            return this.createMockTexture();
        this.ctx.globalAlpha = opacity !== null && opacity !== void 0 ? opacity : 1;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.font = `${fontStyle} ${fontWeight} ${fontSizePx}px ${fontFamily}`;
        const textureWidth = exports.measureTextWidth(this.ctx, text) + 4 * padding;
        const textureHeight = exports.measureTextHeight(fontSizePx) + 2 * padding;
        const halfHeight = Math.ceil(textureHeight / 2);
        const fontSizePt = Math.ceil(fontSizePx * PX_TO_PT);
        this.ctx.save();
        this.ctx.translate((textureWidth + halfHeight) / 2, textureHeight / 2);
        let angle = 0;
        let alignmentLeft = 0;
        let alignmentTop = 0;
        let finalTextureWidth = textureWidth + halfHeight;
        let finalTextureHeight = textureHeight;
        switch (axisAlignment) {
            case AxisAlignment_1.EAxisAlignment.Left:
                angle = 0;
                alignmentLeft = -(textureWidth + halfHeight) / 2;
                alignmentTop = -textureHeight / 2;
                break;
            case AxisAlignment_1.EAxisAlignment.Top:
                angle = Math.PI * 0.5;
                alignmentLeft = -textureHeight / 2;
                alignmentTop = (textureWidth + halfHeight) / 2 - textureHeight;
                finalTextureWidth = textureHeight;
                finalTextureHeight = textureWidth + halfHeight;
                break;
            case AxisAlignment_1.EAxisAlignment.Right:
                angle = Math.PI;
                alignmentLeft = -(textureWidth + halfHeight) / 2;
                alignmentTop = -textureHeight / 2;
                break;
            case AxisAlignment_1.EAxisAlignment.Bottom:
                angle = Math.PI * 1.5;
                alignmentLeft = -textureWidth;
                alignmentTop = -(textureWidth + halfHeight) / 2;
                finalTextureWidth = textureHeight;
                finalTextureHeight = textureWidth + halfHeight;
                break;
        }
        this.ctx.rotate(angle);
        this.ctx.translate(alignmentLeft, alignmentTop);
        if (backgroundColor) {
            const region = new Path2D();
            const height = textureHeight;
            const width = textureWidth;
            region.moveTo(0, 0);
            region.lineTo(width, 0);
            region.lineTo(halfHeight + width, halfHeight);
            region.lineTo(width, height);
            region.lineTo(0, height);
            region.closePath();
            this.ctx.fillStyle = backgroundColor;
            this.ctx.fill(region);
        }
        if (axisAlignment !== AxisAlignment_1.EAxisAlignment.Right) {
            this.ctx.fillStyle = color;
            this.ctx.fillText(text, 2 * padding, fontSizePt + padding);
        }
        this.ctx.restore();
        // display label in default orientation if marker is placed on the right side
        if (axisAlignment === AxisAlignment_1.EAxisAlignment.Right) {
            this.ctx.fillStyle = color;
            this.ctx.fillText(text, 2 * padding + halfHeight, fontSizePt + padding);
        }
        return this.createTextureFromCtxBuffer(finalTextureWidth, finalTextureHeight);
    }
    createAxisLabelsTexture(tickLabels, tickCoords, labelStyle, textureWidth, textureHeight, isAxisFlipped, axisAlignment, tickSize, isFlippedCoordinates) {
        var _a, _b, _c;
        const width = Math.floor(textureWidth);
        const height = Math.floor(textureHeight);
        let sum = 0;
        let devider = 1;
        let sumVertical = 0;
        let deviderVertical = 1;
        if (app_1.IS_TEST_ENV)
            return this.createMockTexture();
        if (width > this.canvas.width) {
            this.canvas.width = width;
        }
        if (height > this.canvas.height) {
            this.canvas.height = height;
        }
        const { fontStyle, fontWeight, fontFamily, color, fontSize: fontSizePx } = labelStyle;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = color;
        this.ctx.font = `${fontStyle} ${fontWeight} ${fontSizePx}px ${fontFamily}`;
        const labelTextHeight = exports.measureTextHeight(fontSizePx);
        if (AxisAlignment_1.getIsHorizontal(axisAlignment)) {
            let lastCoord = isAxisFlipped ? tickCoords[0] : tickCoords[tickLabels.length - 1];
            const lastLabelText = isAxisFlipped ? tickLabels[0] : tickLabels[tickLabels.length - 1];
            const lastLabelTextWidth = exports.measureTextWidth(this.ctx, lastLabelText);
            let preLastCoord = isAxisFlipped ? tickCoords[1] : tickCoords[tickLabels.length - 2];
            const preLastLabelText = isAxisFlipped ? tickLabels[1] : tickLabels[tickLabels.length - 2];
            const preLastLabelTextWidth = exports.measureTextWidth(this.ctx, preLastLabelText);
            const lastXCenterDelta = Math.ceil(lastLabelTextWidth / 2);
            const preLastXCenterDelta = Math.ceil(preLastLabelTextWidth / 2);
            tickLabels.map(item => {
                sum += exports.measureTextWidth(this.ctx, item) + 5;
            }); // +5px for margin
            while (width < sum / devider) {
                devider++;
            }
            if (isFlippedCoordinates) {
                lastCoord = lastCoord - lastXCenterDelta > 0 ? lastCoord - lastXCenterDelta : 0;
            }
            else {
                lastCoord =
                    lastCoord + lastXCenterDelta < width ? lastCoord - lastXCenterDelta : width - lastLabelTextWidth;
            }
            devider = exports.deviderForLastCoordinate(devider, isFlippedCoordinates, lastCoord, lastLabelTextWidth, preLastCoord, preLastXCenterDelta);
            for (let index = 0; index < tickLabels.length; index++) {
                const tickIndex = isAxisFlipped ? tickLabels.length - index - 1 : index;
                const isFirstTick = index === 0;
                const isLastTick = index === tickLabels.length - 1;
                const labelText = tickLabels[tickIndex];
                const labelTextWidth = exports.measureTextWidth(this.ctx, labelText);
                const xCenterDelta = Math.ceil(labelTextWidth / 2);
                let secondIndex;
                if (isAxisFlipped && tickLabels.length - index - 2 >= 0) {
                    secondIndex = tickLabels.length - index - 2;
                }
                else {
                    secondIndex = index + 1;
                }
                let xCoord = tickCoords[tickIndex];
                let xCoordNext = tickCoords[secondIndex];
                if (isFirstTick) {
                    if (isFlippedCoordinates) {
                        xCoord = xCoord + xCenterDelta < width ? xCoord - xCenterDelta : width - labelTextWidth;
                    }
                    else {
                        xCoord = xCoord > xCenterDelta ? xCoord - xCenterDelta : 0;
                    }
                    devider = exports.deviderForCoordinate(devider, isAxisFlipped, isFlippedCoordinates, xCoord, labelTextWidth, xCoordNext, xCenterDelta);
                }
                else if (isLastTick) {
                    if (isFlippedCoordinates) {
                        xCoord = xCoord - xCenterDelta > 0 ? xCoord - xCenterDelta : 0;
                    }
                    else {
                        xCoord = xCoord + xCenterDelta < width ? xCoord - xCenterDelta : width - labelTextWidth;
                    }
                }
                else {
                    xCoord -= xCenterDelta;
                }
                const yCoord = axisAlignment === AxisAlignment_1.EAxisAlignment.Bottom ? height : Math.ceil(fontSizePx * PX_TO_PT);
                const paddingOffset = axisAlignment === AxisAlignment_1.EAxisAlignment.Bottom ? -((_a = labelStyle.padding) === null || _a === void 0 ? void 0 : _a.bottom) : (_b = labelStyle.padding) === null || _b === void 0 ? void 0 : _b.top;
                if (index % devider === 0) {
                    this.ctx.fillText(labelText, xCoord, yCoord + paddingOffset);
                }
            }
        }
        else {
            tickLabels.map(item => {
                sumVertical += exports.measureTextHeight(fontSizePx * 1.5);
            }); // 1.5 for good looking
            while (height < sumVertical / deviderVertical) {
                deviderVertical++;
            }
            for (let index = 0; index < tickLabels.length; index++) {
                const tickIndex = isAxisFlipped ? index : tickLabels.length - index - 1;
                const isFirstTick = index === 0;
                const isLastTick = index === tickLabels.length - 1;
                const labelText = tickLabels[tickIndex];
                const yCenterDelta = Math.ceil((PX_TO_PT * labelTextHeight) / 2);
                // -1 pixel for better look
                let yCoord = tickCoords[tickIndex] - 1;
                if (isFirstTick) {
                    if (isFlippedCoordinates) {
                        yCoord = yCoord < yCenterDelta ? 2 * yCenterDelta : yCoord + yCenterDelta;
                    }
                    else {
                        yCoord = yCoord + yCenterDelta < height ? yCoord + yCenterDelta : height;
                    }
                }
                else if (isLastTick) {
                    if (isFlippedCoordinates) {
                        yCoord = yCoord + yCenterDelta < height ? yCoord + yCenterDelta : height;
                    }
                    else {
                        yCoord = yCoord < yCenterDelta ? 2 * yCenterDelta : yCoord + yCenterDelta;
                    }
                }
                else {
                    yCoord += yCenterDelta;
                }
                const xCoord = axisAlignment === AxisAlignment_1.EAxisAlignment.Left ? 0 : tickSize;
                if (index % deviderVertical === 0) {
                    this.ctx.fillText(labelText, xCoord + ((_c = labelStyle.padding) === null || _c === void 0 ? void 0 : _c.left), yCoord);
                }
            }
        }
        return this.createTextureFromCtxBuffer(width, height);
    }
    createTextureFromCtx(textureWidth, textureHeight) {
        // TODO: Michael cache the canvas, UIntVector, bitmapTexture unless size changed
        // Logger.log(`New Texture: Size is ${textureWidth}, ${textureHeight}`);
        const imageData = this.ctx.getImageData(0, 0, textureWidth, textureHeight);
        // Array of Uint8
        const imageArr = imageData.data;
        // Array of Uint32
        const size = textureWidth * textureHeight;
        const aPixels = new this.webAssemblyContext.UIntVector();
        // Set initial capacity and fill with zeros
        aPixels.resize(size, 0);
        for (let i = 0; i < size; i++) {
            const el = i * 4;
            const a = imageArr[el + 3];
            // Only set pixels that are not alpha=0
            if (a !== 0) {
                const r = imageArr[el];
                const g = imageArr[el + 1];
                const b = imageArr[el + 2];
                // tslint:disable-next-line:no-bitwise
                const pixel = (a << 24) | (b << 16) | (g << 8) | r;
                // tslint:disable-next-line:no-bitwise
                aPixels.set(i, pixel >>> 0);
            }
        }
        // TODO: Consider faster ways of transferring memory to WebAssembly
        // e.g. can we do this? https://github.com/WebAssembly/design/issues/1231
        const textureFormat = this.webAssemblyContext.eTSRTextureFormat.TSR_TEXTUREFORMAT_A8B8G8R8;
        const bitmapTexture = this.webAssemblyContext.SCRTCreateBitmapTexture(textureWidth, textureHeight, textureFormat);
        this.webAssemblyContext.SCRTFillTextureAbgr(bitmapTexture, textureWidth, textureHeight, aPixels);
        aPixels.delete();
        return {
            bitmapTexture,
            textureWidth,
            textureHeight
        };
    }
    createTextureFromCtxBuffer(textureWidth, textureHeight) {
        // TODO: Michael cache the canvas, UIntVector, bitmapTexture unless size changed
        // Logger.log(`New Texture: Size is ${textureWidth}, ${textureHeight}`);
        const textureFormat = this.webAssemblyContext.eTSRTextureFormat.TSR_TEXTUREFORMAT_A8B8G8R8;
        const bitmapTexture = this.webAssemblyContext.SCRTCreateBitmapTexture(textureWidth, textureHeight, textureFormat);
        let buffer;
        try {
            const imageData = this.ctx.getImageData(0, 0, textureWidth, textureHeight);
            const clampedCharArray = imageData.data;
            /// because plain c functions were receiving the object pointer as null, this is the way around that...
            this.webAssemblyContext.SCRTSetActiveTexture(bitmapTexture);
            // Allocate some space in the heap for the data (making sure to use the appropriate memory size)
            // @ts-ignore
            buffer = this.webAssemblyContext._malloc(clampedCharArray.length);
            // Assign the data to the heap - Keep in mind bytes per element
            // @ts-ignore
            this.webAssemblyContext.HEAP8.set(clampedCharArray, buffer);
            // Call the function with "number" parameter type for the array (the pointer), and an extra length parameter
            // @ts-ignore
            const result = this.webAssemblyContext.ccall("SCRTFillActiveTextureCharArray", null, ["number", "number", "number"], [textureWidth, textureHeight, buffer]);
        }
        catch (e) {
            console.error(e);
        }
        finally {
            // This needs to happen in finally block, otherwise thrown errors will stop code execution before
            // @ts-ignore
            this.webAssemblyContext._free(buffer);
        }
        return {
            bitmapTexture,
            textureWidth,
            textureHeight
        };
    }
    createMockTexture() {
        const aTestPixels = new this.webAssemblyContext.UIntVector();
        aTestPixels.push_back(convertToPixel_1.convertToPixel(0, 0, 0, 255));
        const textureFormat = this.webAssemblyContext.eTSRTextureFormat.TSR_TEXTUREFORMAT_A8B8G8R8;
        const testTexture = this.webAssemblyContext.SCRTCreateBitmapTexture(1, 1, textureFormat);
        aTestPixels.delete();
        return { bitmapTexture: testTexture, textureWidth: 1, textureHeight: 1 };
    }
}
exports.TextureManager = TextureManager;
exports.measureTextHeight = (fontSizePx) => fontSizePx;
exports.measureTextWidth = (ctx, text) => {
    const textMeasure = ctx.measureText(text);
    return Math.ceil(textMeasure.width);
};
exports.deviderForCoordinate = (devider, isAxisFlipped, isFlippedCoordinates, xCoord, labelTextWidth, xCoordNext, xCenterDelta) => {
    if (isAxisFlipped
        ? xCoord + labelTextWidth >= xCoordNext - xCenterDelta - 5
        : isFlippedCoordinates
            ? xCoord <= xCoordNext + xCenterDelta + 5
            : xCoord + labelTextWidth >= xCoordNext - xCenterDelta - 5) {
        devider++;
    }
    return devider;
};
exports.deviderForLastCoordinate = (devider, isFlippedCoordinates, lastCoord, lastLabelTextWidth, preLastCoord, preLastXCenterDelta) => {
    if (isFlippedCoordinates
        ? lastCoord + lastLabelTextWidth >= preLastCoord - preLastXCenterDelta - 5
        : lastCoord <= preLastCoord + preLastXCenterDelta + 5) {
        devider++;
    }
    return devider;
};
