"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CanvasTexture = void 0;
const app_1 = require("../../../constants/app");
const Deleter_1 = require("../../../Core/Deleter");
const colorUtil_1 = require("../../../utils/colorUtil");
const TextureCache_1 = require("../../Drawing/TextureCache");
/**
 * @summary The {@link CanvasTexture} is used internally to map an {@link HTMLCanvasElement} to a WebGL Texture.
 * Use this when you want to create a WebGL texture and draw on it.
 * @remarks
 * To use a canvas texture, declare one, draw on the HTML canvas, then call {@link CanvasTexture.copyTexture}.
 * Code example below
 * ```ts
 * // Create a canvasTexture
 * const canvasTexture = new CanvasTexture(wasmContext, width, height);
 * canvasTexture.clear();
 *
 * // do some drawing with html5Context
 * const html5Context = canvasTexture.getContext();
 * // todo - your drawing here
 *
 * // Copy and get the texture
 * canvasTexture.copyTexture();
 * const webAssemblyTexture: TSRTexture = canvasTexture.getTexture();
 *
 * // After use, delete the CanvasTexture
 * canvasTexture.delete();
 * ```
 */
class CanvasTexture {
    /**
     * Creates an instance of a {@link CanvasTexture}
     * @remarks
     * The {@link CanvasTexture} implements {@link IDeletable}, and must be manually deleted to free WebAssembly / native memory
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} or {@link TSciChart2D | SciChart 2D WebAssembly Context}
     * containing native methods and access to our WebGL2 Engine and WebAssembly numerical methods
     * @param textureWidth The width of the texture
     * @param textureHeight The height of the texture
     * @param useInterpolation The flat determines whether to useInterpolation when creating texture
     */
    constructor(webAssemblyContext, textureWidth, textureHeight) {
        if (!app_1.IS_TEST_ENV) {
            this.canvas = document.createElement("canvas");
            this.canvas.width = textureWidth;
            this.canvas.height = textureHeight;
            this.width = textureWidth;
            this.height = textureHeight;
            // Uncomment to see the texture on the screen
            // document.body.appendChild(this.canvas);
        }
        this.wasmContext = webAssemblyContext;
        // Create UIntVector with size once
        this.intermediateVector = new this.wasmContext.UIntVector();
        this.intermediateVector.resize(this.height * this.width, 0);
        // Create UIntVector that will store initial color values
        this.originalIntermediateVector = new this.wasmContext.UIntVector();
        this.originalIntermediateVector.resize(this.height * this.width, 0);
        const textureFormat = this.wasmContext.eTSRTextureFormat.TSR_TEXTUREFORMAT_A8B8G8R8;
        // Create TSRTexture with size once
        this.tsrTextureCache = new TextureCache_1.TextureCache(webAssemblyContext);
        this.tsrTextureCache.create(this.width, this.height, textureFormat);
    }
    /**
     * Get an HTML5 {@link CanvasRenderingContext2D} to draw on.
     */
    getContext() {
        return this.canvas.getContext("2d");
    }
    /**
     * Get the SciChart WebAssembly / WebGL {@link TSRTexture | Texture}
     */
    getTexture() {
        return this.tsrTextureCache.value;
    }
    /**
     * Clears the texture and the canvas
     */
    clear() {
        // Set canvas to clear
        this.getContext().clearRect(0, 0, this.width, this.height);
        // Set UIntVector to zeros
        this.intermediateVector.fill(0);
        this.originalIntermediateVector.fill(0);
    }
    /**
     * @inheritDoc
     */
    delete() {
        if (this.intermediateVector) {
            this.intermediateVector = Deleter_1.deleteSafe(this.intermediateVector);
            this.originalIntermediateVector = Deleter_1.deleteSafe(this.originalIntermediateVector);
            this.intermediateVector = undefined;
            this.originalIntermediateVector = undefined;
        }
        this.tsrTextureCache = Deleter_1.deleteSafe(this.tsrTextureCache);
    }
    /**
     * After you have finished drawing, copy the canvas to the destination {@link TSRTexture}
     */
    copyTexture() {
        var _a;
        const expectedSize = this.width * this.height;
        if (!this.intermediateVector || this.intermediateVector.size() !== expectedSize) {
            throw new Error(`CanvasTexture.ts: IntermediateVector size is ${(_a = this.intermediateVector) === null || _a === void 0 ? void 0 : _a.size()} and expected ${expectedSize}`);
        }
        // Get image data from the HTML5 canvas
        const imageData = this.getContext().getImageData(0, 0, this.width, this.height);
        // Array of Uint8
        const imageArr = imageData.data;
        // Copy to intermediate vector and pixel swizzle RGBA to ABGR
        const size = this.width * this.height;
        for (let i = 0; i < size; i++) {
            const el = i * 4;
            const a = imageArr[el + 3];
            // Only set pixels that are not alpha=0
            if (a !== 0) {
                const r = imageArr[el];
                const g = imageArr[el + 1];
                const b = imageArr[el + 2];
                // tslint:disable-next-line:no-bitwise
                const pixel = (a << 24) | (r << 16) | (g << 8) | b;
                // tslint:disable-next-line:no-bitwise
                this.intermediateVector.set(i, pixel >>> 0);
                this.originalIntermediateVector.set(i, pixel >>> 0);
            }
        }
        // Copy to TSRTexture ready for drawing
        const tsrTexture = this.tsrTextureCache.value;
        this.wasmContext.SCRTFillTextureAbgr(tsrTexture, this.width, this.height, this.intermediateVector);
    }
    applyOpacity(opacity) {
        const size = this.width * this.height;
        for (let i = 0; i < size; i++) {
            const oldPixel = this.originalIntermediateVector.get(i);
            const newPixel = colorUtil_1.uintArgbColorMultiplyOpacity(oldPixel, opacity);
            this.intermediateVector.set(i, newPixel);
        }
        const tsrTexture = this.tsrTextureCache.value;
        this.wasmContext.SCRTFillTextureAbgr(tsrTexture, this.width, this.height, this.intermediateVector);
    }
}
exports.CanvasTexture = CanvasTexture;
