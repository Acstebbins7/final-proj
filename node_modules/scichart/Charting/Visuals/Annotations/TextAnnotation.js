"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextAnnotation = void 0;
const AnchorPoint_1 = require("../../../types/AnchorPoint");
const IAnnotation_1 = require("./IAnnotation");
const SvgAnnotationBase_1 = require("./SvgAnnotationBase");
/**
 * A TextAnnotation presents text information over the chart at specific {@link X1}, {@link Y1} coordinates
 */
class TextAnnotation extends SvgAnnotationBase_1.SvgAnnotationBase {
    /**
     * Creates an instance of the {@link CustomAnnotation}
     * @param options The {@link ITextAnnotationOptions} which contain optional parameters
     */
    constructor(options) {
        var _a, _b, _c, _d, _e;
        super(options);
        /** @inheritDoc */
        this.type = IAnnotation_1.EAnnotationType.SVGTextAnnotation;
        this.textProperty = "DEFAULT TEXT";
        this.textColorProperty = "#ffffff";
        this.fontSizeProperty = 14;
        this.fontFamilyProperty = "Arial";
        this.fontWeightProperty = "Normal";
        this.isDirty = true;
        this.textProperty = (_a = options === null || options === void 0 ? void 0 : options.text) !== null && _a !== void 0 ? _a : this.textProperty;
        this.textColorProperty = (_b = options === null || options === void 0 ? void 0 : options.textColor) !== null && _b !== void 0 ? _b : this.textColorProperty;
        this.fontSizeProperty = (_c = options === null || options === void 0 ? void 0 : options.fontSize) !== null && _c !== void 0 ? _c : this.fontSizeProperty;
        this.fontFamilyProperty = (_d = options === null || options === void 0 ? void 0 : options.fontFamily) !== null && _d !== void 0 ? _d : this.fontFamilyProperty;
        this.fontWeight = (_e = options === null || options === void 0 ? void 0 : options.fontWeight) !== null && _e !== void 0 ? _e : this.fontWeight;
    }
    /**
     * text provided by the user
     */
    get text() {
        return this.textProperty;
    }
    set text(text) {
        this.textProperty = text;
        this.notifyPropertyChanged();
    }
    /**
     * text color provided by the user
     */
    get textColor() {
        return this.textColorProperty;
    }
    set textColor(textColor) {
        this.textColorProperty = textColor;
        this.notifyPropertyChanged();
    }
    /**
     * font size provided by the user
     */
    get fontSize() {
        return this.fontSizeProperty;
    }
    set fontSize(fontSize) {
        this.fontSizeProperty = fontSize;
        this.notifyPropertyChanged();
    }
    /**
     * font family provided by the user
     */
    get fontFamily() {
        return this.fontFamilyProperty;
    }
    set fontFamily(fontFamily) {
        this.fontFamilyProperty = fontFamily;
        this.notifyPropertyChanged();
    }
    /**
     * font weight provided by the user
     */
    get fontWeight() {
        return this.fontWeightProperty;
    }
    set fontWeight(fontWeight) {
        this.fontWeightProperty = fontWeight;
        this.notifyPropertyChanged();
    }
    /**
     * Notifies listeners of {@link invalidateParentCallback} that a property has changed
     */
    notifyPropertyChanged() {
        this.isDirty = true;
        if (this.invalidateParentCallback) {
            this.invalidateParentCallback();
        }
    }
    /**
     * @inheritDoc
     */
    create(xCalc, yCalc) {
        const isChangedCoordinate = this.prevX1Coordinate !== this.getX1Coordinate(xCalc, yCalc) ||
            this.prevY1Coordinate !== this.getY1Coordinate(xCalc, yCalc);
        if ((!this.isDirty && !this.isSelected && !isChangedCoordinate) || (this.svg && !this.isEditable))
            return;
        this.annontationBorders.x1 = this.prevX1Coordinate = this.getX1Coordinate(xCalc, yCalc);
        this.annontationBorders.y1 = this.prevY1Coordinate = this.getY1Coordinate(xCalc, yCalc);
        if (this.svg) {
            this.delete();
        }
        this.svg = createSvg(this.svgRoot, this.textProperty, this.textColorProperty, this.fontSizeProperty, this.fontFamilyProperty, this.fontWeight);
        const svgProperties = this.svg.getBoundingClientRect();
        this.annontationBorders.x2 = this.annontationBorders.x1 + svgProperties.width;
        this.annontationBorders.y2 = this.annontationBorders.y1 + svgProperties.height;
        if (this.verticalAnchorPoint === AnchorPoint_1.EVerticalAnchorPoint.Bottom) {
            this.annontationBorders.y2 = this.annontationBorders.y1 - svgProperties.height;
        }
        if (this.verticalAnchorPoint === AnchorPoint_1.EVerticalAnchorPoint.Center) {
            this.annontationBorders.y2 = this.annontationBorders.y1 + svgProperties.height / 2;
            this.annontationBorders.y1 = this.annontationBorders.y1 - svgProperties.height / 2;
        }
        if (this.horizontalAnchorPoint === AnchorPoint_1.EHorizontalAnchorPoint.Right) {
            this.annontationBorders.x2 = this.annontationBorders.x1 - svgProperties.width;
        }
        if (this.horizontalAnchorPoint === AnchorPoint_1.EHorizontalAnchorPoint.Center) {
            this.annontationBorders.x2 = this.annontationBorders.x1 + svgProperties.width / 2;
            this.annontationBorders.x1 = this.annontationBorders.x1 - svgProperties.width / 2;
        }
        this.updateAdornerInner(this.annontationBorders.x1, this.annontationBorders.y1, this.annontationBorders.x2, this.annontationBorders.y2);
        this.isDirty = false;
    }
}
exports.TextAnnotation = TextAnnotation;
/** @ignore */
/** @ignore */
const createSvg = (svgRoot, text, color, fontSize, fontFamily, fontWeight) => {
    const svgString = `<svg>
        <text x="0" y="${fontSize}" fill="${color}" font-size="${fontSize}" font-family="${fontFamily}" font-weight="${fontWeight}">${text}</text>
    </svg>`;
    const svgNode = document.createRange().createContextualFragment(svgString);
    svgRoot.appendChild(svgNode);
    return svgRoot.lastChild;
};
