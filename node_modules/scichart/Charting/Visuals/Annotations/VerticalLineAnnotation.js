"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerticalLineAnnotation = void 0;
const Guard_1 = require("../../../Core/Guard");
const AxisAlignment_1 = require("../../../types/AxisAlignment");
const pointUtil_1 = require("../../../utils/pointUtil");
const Pen2DCache_1 = require("../../Drawing/Pen2DCache");
const drawLabel_1 = require("../Helpers/drawLabel");
const constants_1 = require("./constants");
const IAnnotation_1 = require("./IAnnotation");
const LineAnnotation_1 = require("./LineAnnotation");
/**
 * @summary The {@link VerticalLineAnnotation} provides an {@link AnnotationBase | Annotation} which draws a vertical line at
 * specific x1 (or y1 for Vertical Chart) over the {@link SciChartSurface}
 * @description
 * To add a {@link VerticalLineAnnotation} to a {@link SciChartSurface}, use the following code:
 * ```ts
 * const sciChartSurface: SciChartSurface;
 * const verticalLineAnnotation = new VerticalLineAnnotation( { x1: 1, y1: 3 fill: "#FF000077", stroke: "#FF0000"});
 * sciChartSurface.annotations.add(verticalLineAnnotation);
 * ```
 * @remarks Uses the fast WebGL/WebAssembly {@link WebGL2RenderingContext} for rendering
 */
class VerticalLineAnnotation extends LineAnnotation_1.LineAnnotation {
    /**
     * Create an instance of a LineAnnotation
     * @param options Optional parameters of type {@link ILineAnnotationOptions} which configure the annotation upon construction
     */
    constructor(options) {
        super(options);
        /**@inheritDoc */
        this.type = IAnnotation_1.EAnnotationType.RenderContextVerticalLineAnnotation;
        if (options === null || options === void 0 ? void 0 : options.x2) {
            this.x2 = options.x2;
        }
        if (options === null || options === void 0 ? void 0 : options.y2) {
            this.y2 = options.y2;
        }
    }
    /**
     * y2 property is not supported for VerticalLineAnnotation
     */
    get y2() {
        throw Error("y2 property is not supported for VerticalLineAnnotation");
    }
    /**
     * y2 property is not supported for VerticalLineAnnotation
     */
    set y2(y2) {
        throw Error("y2 property is not supported for VerticalLineAnnotation");
    }
    /**
     * x2 property is not supported for VerticalLineAnnotation
     */
    get x2() {
        throw Error("x2 property is not supported for VerticalLineAnnotation");
    }
    /**
     * x2 property is not supported for VerticalLineAnnotation
     */
    set x2(x2) {
        throw Error("x2 property is not supported for VerticalLineAnnotation");
    }
    /**
     * returns axis related properties accordingly to chart configuration
     */
    getDrawConfig(xCalc, yCalc) {
        const xAxisId = this.xAxisId;
        const xAxis = this.parentSurface.getXAxisById(xAxisId);
        const yAxisId = this.yAxisId;
        const yAxis = this.parentSurface.getYAxisById(yAxisId);
        const defaultChartCoordinateConfig = {
            annotationCoord: this.x1,
            lineAnnotationEdgeCoord: this.y1,
            horizontalAxis: xAxis,
            verticalAxis: yAxis,
            horizontalAxisCoordinateMode: this.xCoordinateMode,
            verticalAxisCoordinateMode: this.yCoordinateMode,
            horizontalCoordinateCalculator: xCalc,
            verticalCoordinateCalculator: yCalc,
            isAlignmentTop: xAxis.axisAlignment === AxisAlignment_1.EAxisAlignment.Top
        };
        const verticalChartCoordinateConfig = {
            annotationCoord: this.y1,
            lineAnnotationEdgeCoord: this.x1,
            horizontalAxis: yAxis,
            verticalAxis: xAxis,
            horizontalAxisCoordinateMode: this.yCoordinateMode,
            verticalAxisCoordinateMode: this.xCoordinateMode,
            horizontalCoordinateCalculator: yCalc,
            verticalCoordinateCalculator: xCalc,
            isAlignmentTop: yAxis.axisAlignment === AxisAlignment_1.EAxisAlignment.Top
        };
        return this.isVerticalChart ? verticalChartCoordinateConfig : defaultChartCoordinateConfig;
    }
    /** @inheritDoc */
    drawWithContext(renderContext, xCalc, yCalc, viewRect) {
        if (this.isHidden) {
            return;
        }
        Guard_1.Guard.notNull(renderContext, "renderContext");
        Guard_1.Guard.notNull(xCalc, "xCalc");
        Guard_1.Guard.notNull(yCalc, "yCalc");
        const strokePen = Pen2DCache_1.getWebGlPenFromCache(this.strokePenCache);
        const { annotationCoord, lineAnnotationEdgeCoord, horizontalAxis, verticalAxis, horizontalAxisCoordinateMode, verticalAxisCoordinateMode, horizontalCoordinateCalculator, verticalCoordinateCalculator, isAlignmentTop } = this.getDrawConfig(xCalc, yCalc);
        this.annontationBorders.y1 = viewRect.height;
        this.annontationBorders.y2 = 0;
        if (isAlignmentTop) {
            this.annontationBorders.y1 = this.annontationBorders.y1 = 0;
            this.annontationBorders.y2 = this.annontationBorders.y2 = viewRect.height;
        }
        const lineAnnotationEdgeCoordValue = this.getValue(lineAnnotationEdgeCoord, horizontalCoordinateCalculator, verticalAxisCoordinateMode);
        const isPartialLine = lineAnnotationEdgeCoordValue || lineAnnotationEdgeCoordValue === 0;
        if (isPartialLine) {
            this.annontationBorders.y2 = this.annontationBorders.y2 = this.getY1Coordinate(xCalc, yCalc);
        }
        this.annontationBorders.x1 = this.getX1Coordinate(xCalc, yCalc);
        this.annontationBorders.x2 = this.annontationBorders.x1;
        const annotationCoordValue = this.getValue(annotationCoord, verticalCoordinateCalculator, horizontalAxisCoordinateMode);
        const isAxisLabelInHorizontalVisibleRange = annotationCoordValue >= horizontalAxis.visibleRange.min &&
            annotationCoordValue <= horizontalAxis.visibleRange.max;
        const isLineAnnotationInVerticalVisibleRange = isAlignmentTop
            ? lineAnnotationEdgeCoordValue <= verticalAxis.visibleRange.max
            : lineAnnotationEdgeCoordValue >= verticalAxis.visibleRange.min;
        const isLineAnnotationEdgeVisible = !isPartialLine || isLineAnnotationInVerticalVisibleRange;
        if (isAxisLabelInHorizontalVisibleRange && isLineAnnotationEdgeVisible) {
            const textStyle = Object.assign(Object.assign({}, verticalAxis.labelStyle), { color: this.axisLabelStroke, fontSize: this.axisFontSize, fontFamily: this.axisFontFamily });
            drawLabel_1.drawLineAnnotation(horizontalAxis, renderContext, this.labelPlacement, this.labelValue, this.annontationBorders.x1, this.annontationBorders.x2, this.annontationBorders.y1, this.annontationBorders.y2, textStyle, this.axisLabelFill, strokePen, viewRect, this.showLabel, this.opacity);
        }
        this.updateAdornerInner(this.annontationBorders.x1, this.annontationBorders.x2, this.annontationBorders.y1, this.annontationBorders.y2);
    }
    checkIsClickedOnAnnotation(xyPoint, x1Coord, y1Coord, x2Coord, y2Coord) {
        if (x1Coord < x2Coord) {
            x1Coord = this.annontationBorders.x2;
            x2Coord = this.annontationBorders.x1;
        }
        if (y1Coord > y2Coord) {
            y1Coord = this.annontationBorders.y2;
            y2Coord = this.annontationBorders.y1;
        }
        const distanceFromLine = pointUtil_1.calcDistanceFromLineSegment(xyPoint.x, xyPoint.y, x1Coord, y1Coord, x2Coord, y2Coord);
        return distanceFromLine <= constants_1.DISTANCE_TO_LINE;
    }
}
exports.VerticalLineAnnotation = VerticalLineAnnotation;
