"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SvgAnnotationBase = void 0;
const Point_1 = require("../../../Core/Point");
const AnchorPoint_1 = require("../../../types/AnchorPoint");
const pointUtil_1 = require("../../../utils/pointUtil");
const translate_1 = require("../../../utils/translate");
const AnnotationBase_1 = require("./AnnotationBase");
const constants_1 = require("./constants");
/**
 * The Base class for an {@link AnnotationBase | Annotation} which draws using an HTML5 SVG canvas
 */
class SvgAnnotationBase extends AnnotationBase_1.AnnotationBase {
    /**
     * Creates an instance of an SvgAnnotationbase
     * @param options Optional parameters of type {@link ISvgAnnotationBaseOptions} used to configure the annotation on construction
     */
    constructor(options) {
        var _a, _b, _c, _d;
        super(options);
        this.verticalAnchorPointProperty = AnchorPoint_1.EVerticalAnchorPoint.Top;
        this.horizontalAnchorPointProperty = AnchorPoint_1.EHorizontalAnchorPoint.Left;
        this.prevX1Coordinate = 0;
        this.prevY1Coordinate = 0;
        this.xCoordShiftProperty = (_a = options === null || options === void 0 ? void 0 : options.xCoordShift) !== null && _a !== void 0 ? _a : this.xCoordShiftProperty;
        this.yCoordShiftProperty = (_b = options === null || options === void 0 ? void 0 : options.yCoordShift) !== null && _b !== void 0 ? _b : this.yCoordShiftProperty;
        this.verticalAnchorPointProperty = (_c = options === null || options === void 0 ? void 0 : options.verticalAnchorPoint) !== null && _c !== void 0 ? _c : this.verticalAnchorPointProperty;
        this.horizontalAnchorPointProperty = (_d = options === null || options === void 0 ? void 0 : options.horizontalAnchorPoint) !== null && _d !== void 0 ? _d : this.horizontalAnchorPointProperty;
    }
    /** @inheritDoc */
    onAttach(scs) {
        super.onAttach(scs);
        this.svgRootProperty = scs.domSvgContainer;
        // Override in derived classes to be notified of attached
    }
    /** @inheritDoc */
    onDetach() {
        this.delete();
    }
    /**
     * Gets or sets an offset to shift X-coordinates
     */
    get xCoordShift() {
        return this.xCoordShiftProperty;
    }
    /**
     * Gets or sets an offset to shift X-coordinates
     */
    set xCoordShift(value) {
        this.xCoordShiftProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.X_COORD_SHIFT);
    }
    /**
     * Gets or sets an offset to shift Y-coordinates
     */
    get yCoordShift() {
        return this.yCoordShiftProperty;
    }
    /**
     * Gets or sets an offset to shift Y-coordinates
     */
    set yCoordShift(value) {
        this.yCoordShiftProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.Y_COORD_SHIFT);
    }
    /**
     * Gets or sets vertical anchor point
     */
    get verticalAnchorPoint() {
        return this.verticalAnchorPointProperty;
    }
    /**
     * Gets or sets vertical anchor point
     */
    set verticalAnchorPoint(value) {
        this.verticalAnchorPointProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.VERTICAL_ANCHOR_POINT);
    }
    /**
     * Gets or sets horizontal anchor point
     */
    get horizontalAnchorPoint() {
        return this.horizontalAnchorPointProperty;
    }
    /**
     * Gets or sets horizontal anchor point
     */
    set horizontalAnchorPoint(value) {
        this.horizontalAnchorPointProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.HORIZONTAL_ANCHOR_POINT);
    }
    /**
     * Updates the annotation position, with the {@link CoordinateCalculatorBase | Coordinate Calculators} passed in
     * @param xCalc The XAxis {@link CoordinateCalculatorBase | CoordinateCalculator} applied to this annotation
     * @param yCalc The YAxis {@link CoordinateCalculatorBase | CoordinateCalculator} applied to this annotation
     */
    update(xCalc, yCalc) {
        var _a, _b;
        this.create(xCalc, yCalc);
        let shiftX = (_a = this.xCoordShift) !== null && _a !== void 0 ? _a : 0;
        let shiftY = (_b = this.yCoordShift) !== null && _b !== void 0 ? _b : 0;
        // @ts-ignore
        const svgRect = this.svg.getBBox();
        const svgWidth = svgRect.width;
        const svgHeight = svgRect.height;
        if (this.horizontalAnchorPointProperty === AnchorPoint_1.EHorizontalAnchorPoint.Center) {
            shiftX -= svgWidth / 2;
        }
        else if (this.horizontalAnchorPointProperty === AnchorPoint_1.EHorizontalAnchorPoint.Right) {
            shiftX -= svgWidth;
        }
        if (this.verticalAnchorPointProperty === AnchorPoint_1.EVerticalAnchorPoint.Center) {
            shiftY -= svgHeight / 2;
        }
        else if (this.verticalAnchorPointProperty === AnchorPoint_1.EVerticalAnchorPoint.Bottom) {
            shiftY -= svgHeight;
        }
        this.svg.style.display = this.isHidden ? "none" : "block";
        this.svg.style.opacity = this.opacity.toString();
        const x1Coord = shiftX + this.getX1Coordinate(xCalc, yCalc);
        const y1Coord = shiftY + this.getY1Coordinate(xCalc, yCalc);
        if (isNaN(x1Coord) || isNaN(y1Coord)) {
            this.svg.style.display = "none";
        }
        else {
            this.svg.setAttribute("x", x1Coord.toString());
            this.svg.setAttribute("y", y1Coord.toString());
        }
    }
    —ÅalcDragDistance(xyValues) {
        if (this.adornerDraggingPoint === AnnotationBase_1.EDraggingGripPoint.Body) {
            if (!this.prevValue) {
                this.prevValue = xyValues;
                return;
            }
            this.annontationBorders.x1 = this.x1 - (this.prevValue.x - xyValues.x);
            this.annontationBorders.y1 = this.y1 - (this.prevValue.y - xyValues.y);
            this.x1 = this.annontationBorders.x1;
            this.y1 = this.annontationBorders.y1;
            this.annontationBorders.x2 = this.annontationBorders.x2 - (this.prevValue.x - xyValues.x);
            this.annontationBorders.y2 = this.annontationBorders.y2 - (this.prevValue.y - xyValues.y);
            this.prevValue = xyValues;
        }
        else if (this.adornerDraggingPoint === AnnotationBase_1.EDraggingGripPoint.Point1) {
            this.annontationBorders.x1 = xyValues.x;
            this.annontationBorders.y1 = xyValues.y;
            this.y1 = xyValues.y;
            this.x1 = xyValues.x;
        }
    }
    onDragStarted(args) {
        super.onDragStarted(args);
        const xyCoord1 = new Point_1.Point(this.annontationBorders.x1, this.annontationBorders.y1);
        let circleCenterX = this.annontationBorders.x1;
        let circleCenterY = this.annontationBorders.y1;
        const height = Math.abs((this.annontationBorders.y1 - this.annontationBorders.y2) / 2);
        const width = Math.abs((this.annontationBorders.x1 - this.annontationBorders.x2) / 2);
        if (this.verticalAnchorPoint === AnchorPoint_1.EVerticalAnchorPoint.Center) {
            circleCenterY = circleCenterY + height;
        }
        if (this.horizontalAnchorPoint === AnchorPoint_1.EHorizontalAnchorPoint.Center) {
            circleCenterX = circleCenterX + width;
        }
        const xyMousePoint = translate_1.translateFromCanvasToSeriesViewRect(new Point_1.Point(args.mousePoint.x, args.mousePoint.y), this.parentSurface.seriesViewRect);
        if (xyCoord1) {
            const dist = pointUtil_1.calcDistance(circleCenterX, circleCenterY, xyMousePoint.x, xyMousePoint.y);
            if (dist < constants_1.ADORNER_GRIP_RADIUS) {
                this.adornerDraggingPoint = AnnotationBase_1.EDraggingGripPoint.Point1;
                return true;
            }
        }
        if (xyMousePoint) {
            if (this.isPointWithinBounds(args)) {
                this.adornerDraggingPoint = AnnotationBase_1.EDraggingGripPoint.Body;
                return true;
            }
        }
        return false;
    }
    checkIsClickedOnAnnotation(xyPoint, x1Coord, y1Coord, x2Coord, y2Coord) {
        const isInBounds = pointUtil_1.testIsInBounds(xyPoint.x, xyPoint.y, x1Coord, y1Coord, x2Coord, y2Coord);
        return isInBounds;
    }
    /**
     * @inheritDoc
     */
    delete() {
        if (!this.parentSurface || this.parentSurface.isDeleted || !this.svg)
            return;
        this.svgRoot.removeChild(this.svg);
        this.svg = undefined;
    }
    updateAdornerInner(x1Coord, y1Coord, x2Coord, y2Coord) {
        super.updateAdorner();
        const adornerSvgRoot = this.parentSurface.domSvgAdornerLayer;
        if (this.svgAdorner) {
            this.deleteAdorner();
        }
        if (this.isSelected) {
            const svgString = svgStringTemplate(x1Coord, y1Coord, x2Coord, y2Coord, this.verticalAnchorPoint, this.horizontalAnchorPoint);
            this.svgAdorner = createSvgAdorner(svgString, adornerSvgRoot);
        }
    }
    /**
     * Gets the {@link SVGSVGElement | SVG Element} at the root of this annotation
     */
    get svgRoot() {
        return this.svgRootProperty;
    }
}
exports.SvgAnnotationBase = SvgAnnotationBase;
/** @ignore */
const svgStringTemplate = (x1, y1, x2, y2, verticalAnchorPoint, horizontalAnchorPoint) => {
    //TODO add theme
    const colorLine = "#f00e0e66";
    const adornerFill = "#CDCDCD22";
    const adornerStroke = "#CDCDCD99";
    const delta = 0;
    let circleCenterX = x1;
    let circleCenterY = y1;
    const height = Math.abs((y1 - y2) / 2);
    const width = Math.abs((x1 - x2) / 2);
    if (verticalAnchorPoint === AnchorPoint_1.EVerticalAnchorPoint.Center) {
        circleCenterY = circleCenterY + height;
    }
    if (horizontalAnchorPoint === AnchorPoint_1.EHorizontalAnchorPoint.Center) {
        circleCenterX = circleCenterX + width;
    }
    return `<svg xmlns="http://www.w3.org/2000/svg">
    <line x1="${x1 - delta}" y1="${y1}" x2="${x2 + delta}" y2="${y1}" stroke="${colorLine}" stroke-width="${2}" />
    <line x1="${x2}" y1="${y1 + delta}" x2="${x2}" y2="${y2 - delta}" stroke="${colorLine}" stroke-width="${2}" />
    <line x1="${x1 - delta}" y1="${y2}" x2="${x2 + delta}" y2="${y2}" stroke="${colorLine}" stroke-width="${2}" />
    <line x1="${x1 - delta}" y1="${y1 + delta}" x2="${x1}" y2="${y2 -
        delta}" stroke="${colorLine}" stroke-width="${2}" />
    <circle cx="${circleCenterX}" cy="${circleCenterY}" r="${constants_1.ADORNER_GRIP_RADIUS}" fill="${adornerFill}" stroke="${adornerStroke}"/>
  </svg>`;
};
/** @ignore */
const createSvgAdorner = (svgString, svgRoot) => {
    const svgNode = document.createRange().createContextualFragment(svgString);
    svgRoot.appendChild(svgNode);
    return svgRoot.lastChild;
};
