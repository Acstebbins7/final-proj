"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TooltipSvgAnnotation = void 0;
const IDataSeries_1 = require("../../Model/IDataSeries");
const AnnotationBase_1 = require("./AnnotationBase");
const constants_1 = require("./constants");
const IAnnotation_1 = require("./IAnnotation");
const SvgAnnotationBase_1 = require("./SvgAnnotationBase");
/**
 * A Tooltip Annotation which provides an SVG tooltip over the chart. Used by the {@link RolloverModifier}
 */
class TooltipSvgAnnotation extends SvgAnnotationBase_1.SvgAnnotationBase {
    /**
     * Creates an instance of the {@link TooltipSvgAnnotation}
     * @param renderableSeriesProps The {@link RolloverModifierRenderableSeriesProps | props} pass
     * @param options
     */
    constructor(renderableSeriesProps, options) {
        var _a;
        super(options);
        /** @inheritDoc */
        this.type = IAnnotation_1.EAnnotationType.SVG;
        this.width = 0;
        this.height = 0;
        this.tooltipProps = renderableSeriesProps;
        this.height = (_a = options === null || options === void 0 ? void 0 : options.height) !== null && _a !== void 0 ? _a : this.height;
        this.xCoordinateMode = AnnotationBase_1.ECoordinateMode.DataValue;
        this.yCoordinateMode = AnnotationBase_1.ECoordinateMode.DataValue;
        this.isHidden = true;
        this.updateSize = this.updateSize.bind(this);
    }
    /**
     * Gets or sets seriesInfo {@link SeriesInfo} value on the tooltip
     */
    get seriesInfo() {
        return this.seriesInfoProperty;
    }
    /**
     * Gets or sets seriesInfo {@link SeriesInfo} value on the tooltip
     */
    set seriesInfo(value) {
        this.seriesInfoProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.SERIES_INFO);
    }
    /**
     * @inheritDoc
     */
    delete() {
        if (!this.parentSurface || this.parentSurface.isDeleted)
            return;
        this.svgRoot.removeChild(this.svg);
        if (this.svgLegend) {
            this.svgRoot.removeChild(this.svgLegend);
        }
    }
    /**
     * @inheritDoc
     */
    update(xCalc, yCalc) {
        if (this.svg) {
            this.delete();
        }
        super.update(xCalc, yCalc);
        this.updateLegendTooltip();
    }
    /**
     * @inheritDoc
     */
    create(xCalc, yCalc) {
        var _a;
        let svgString;
        if (!this.seriesInfo) {
            svgString = "<svg></svg>";
        }
        else {
            const { tooltipTitle } = this.tooltipProps;
            const idTitle = ("" + tooltipTitle).replace(/\s/g, "");
            const id = `id${Math.floor(this.y1)}_${idTitle}_${Date.now()}`;
            const tooltipTemplate = (_a = this.tooltipProps.tooltipTemplate) !== null && _a !== void 0 ? _a : tooltipSvgTemplate;
            svgString = tooltipTemplate(id, this.tooltipProps, this.seriesInfo, this.updateSize);
        }
        const svgNode = document.createRange().createContextualFragment(svgString);
        this.svgRoot.appendChild(svgNode);
        this.svg = this.svgRoot.lastChild;
    }
    updateLegendTooltip() {
        if (this.tooltipProps.tooltipLegendTemplate) {
            const svgString = this.seriesInfo
                ? this.tooltipProps.tooltipLegendTemplate(this.tooltipProps, this.seriesInfo)
                : "<svg></svg>";
            const svgNode = document.createRange().createContextualFragment(svgString);
            this.svgRoot.appendChild(svgNode);
            this.svgLegend = this.svgRoot.lastChild;
            this.svgLegend.setAttribute("x", this.tooltipProps.tooltipLegendOffsetX.toString());
            this.svgLegend.setAttribute("y", this.tooltipProps.tooltipLegendOffsetY.toString());
        }
    }
    updateSize(width, height) {
        this.width = width;
        this.height = height;
    }
}
exports.TooltipSvgAnnotation = TooltipSvgAnnotation;
/** @ignore */
const tooltipSvgTemplate = (id, tooltipProps, seriesInfo, updateSize) => {
    let valuesBlock = "";
    const { tooltipTitle, tooltipColor, tooltipTextColor, tooltipLabelX, tooltipLabelY } = tooltipProps;
    const valuesWithLabels = [];
    if (seriesInfo.dataSeriesType === IDataSeries_1.EDataSeriesType.Ohlc) {
        const ohlcSeriesInfo = seriesInfo;
        if (tooltipLabelX) {
            valuesWithLabels.push(`${tooltipLabelX}: ${ohlcSeriesInfo.formattedXValue}`);
        }
        valuesWithLabels.push(`Open: ${ohlcSeriesInfo.formattedOpenValue}`);
        valuesWithLabels.push(`Highest: ${ohlcSeriesInfo.formattedHighValue}`);
        valuesWithLabels.push(`Lowest: ${ohlcSeriesInfo.formattedLowValue}`);
        valuesWithLabels.push(`Close: ${ohlcSeriesInfo.formattedCloseValue}`);
    }
    else if (seriesInfo.dataSeriesType === IDataSeries_1.EDataSeriesType.Xyy) {
        // Band Series
        const xyySeriesInfo = seriesInfo;
        if (xyySeriesInfo.isFirstSeries) {
            addValueWithLabel(valuesWithLabels, xyySeriesInfo.formattedXValue, xyySeriesInfo.formattedYValue, tooltipLabelX, tooltipLabelY);
        }
        else {
            addValueWithLabel(valuesWithLabels, xyySeriesInfo.formattedXValue, xyySeriesInfo.formattedY1Value, tooltipLabelX, tooltipLabelY);
        }
    }
    else if (seriesInfo.dataSeriesType === IDataSeries_1.EDataSeriesType.HeatmapUniform) {
        // Band Series
        const heatmapSeriesInfo = seriesInfo;
        if (tooltipLabelX) {
            valuesWithLabels.push(`${tooltipLabelX}: ${heatmapSeriesInfo.formattedXValue}`);
        }
        if (tooltipLabelY) {
            valuesWithLabels.push(`${tooltipLabelY}: ${heatmapSeriesInfo.formattedYValue}`);
        }
        valuesWithLabels.push(`Z: ${heatmapSeriesInfo.formattedZValue}`);
    }
    else {
        // Line Series
        const xySeriesInfo = seriesInfo;
        addValueWithLabel(valuesWithLabels, xySeriesInfo.formattedXValue, xySeriesInfo.formattedYValue, tooltipLabelX, tooltipLabelY);
    }
    if (tooltipTitle) {
        valuesBlock += `<tspan x="8" dy="1.2em">${tooltipTitle}</tspan>`;
    }
    // tooltip width
    let width = tooltipProps.width;
    if (!width) {
        let tooltipLength = valuesWithLabels.reduce((prev, cur) => (cur.length > prev ? cur.length : prev), 0);
        if ((tooltipTitle === null || tooltipTitle === void 0 ? void 0 : tooltipTitle.length) > tooltipLength) {
            tooltipLength = tooltipTitle.length;
        }
        width = calcTooltipWidth(tooltipLength);
    }
    // tooltip height
    let height = tooltipProps.height;
    if (!height) {
        const tooltipLines = tooltipTitle ? valuesWithLabels.length + 1 : valuesWithLabels.length;
        height = calcTooltipHeight(tooltipLines);
    }
    updateSize(width, height);
    valuesWithLabels.forEach((val, index) => {
        valuesBlock += `<tspan x="8" dy="1.2em">${val}</tspan>`;
    });
    return `<svg width="${width}" height="${height}">
        <defs>
            <filter id="${id}" x="0" y="0" width="200%" height="200%">
                <feOffset result="offOut" in="SourceAlpha" dx="3" dy="3" />
                <feGaussianBlur result="blurOut" in="offOut" stdDeviation="3" />
                <feBlend in="SourceGraphic" in2="blurOut" mode="normal" />
            </filter>
        </defs>
        <rect rx="4" ry="4" width="95%" height="90%" fill="${tooltipColor}" filter="url(#${id})" />
        <svg width="100%">
            <text x="8" y="3" font-size="13" font-family="Verdana" dy="0" fill="${tooltipTextColor}">${valuesBlock}</text>
        </svg>
    </svg>`;
};
/** @ignore */
const calcTooltipWidth = (textLength = 20, fontSize = 13) => {
    return textLength * 8 + 20;
};
/** @ignore */
const calcTooltipHeight = (lines = 2, fontSize = 13) => {
    return 17 * lines + 16;
};
/** @ignore */
const addValueWithLabel = (valuesWithLabels, xValue, yValue, xLabel, yLabel) => {
    if (xLabel) {
        const yLabel2 = yLabel !== null && yLabel !== void 0 ? yLabel : "Y";
        valuesWithLabels.push(`${xLabel}: ${xValue} ${yLabel2}: ${yValue}`);
    }
    else {
        const yLabel2 = yLabel ? `${yLabel}: ` : "";
        valuesWithLabels.push(`${yLabel2}${yValue}`);
    }
};
