"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineAnnotation = void 0;
const Deleter_1 = require("../../../Core/Deleter");
const Guard_1 = require("../../../Core/Guard");
const Point_1 = require("../../../Core/Point");
const LabelPlacement_1 = require("../../../types/LabelPlacement");
const XyDirection_1 = require("../../../types/XyDirection");
const pointUtil_1 = require("../../../utils/pointUtil");
const Pen2DCache_1 = require("../../Drawing/Pen2DCache");
const drawLabel_1 = require("../Helpers/drawLabel");
const AnnotationBase_1 = require("./AnnotationBase");
const constants_1 = require("./constants");
const IAnnotation_1 = require("./IAnnotation");
const RenderContextAnnotationBase_1 = require("./RenderContextAnnotationBase");
/**
 * @summary The {@link LineAnnotation} provides an {@link AnnotationBase | Annotation} which draws a line at
 * specific x1x2 y1y2 over the {@link SciChartSurface}
 * @description
 * To add a {@link LineAnnotation} to a {@link SciChartSurface}, use the following code:
 * ```ts
 * const sciChartSurface: SciChartSurface;
 * const lineAnnotation = new LineAnnotation( { x1: 1, x2: 2, y1: 3, y2: 4, fill: "#FF000077", stroke: "#FF0000"});
 * sciChartSurface.annotations.add(lineAnnotation);
 * ```
 * @remarks Uses the fast WebGL/WebAssembly {@link WebGL2RenderingContext} for rendering
 */
class LineAnnotation extends RenderContextAnnotationBase_1.RenderContextAnnotationBase {
    /**
     * Create an instance of a LineAnnotation
     * @param options Optional parameters of type {@link ILineAnnotationOptions} which configure the annotation upon construction
     */
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        super(options);
        /** @inheritDoc */
        this.type = IAnnotation_1.EAnnotationType.RenderContextLineAnnotation;
        this.strokeThicknessProperty = 1;
        this.strokeDashArrayProperty = [];
        this.strokeProperty = "#FFFFFF";
        this.showLabelProperty = false;
        this.axisLabelStrokeProperty = "#ffffff";
        this.axisLabelFillProperty = "#b36200";
        this.axisFontSizeProperty = 14;
        this.axisFontFamilyProperty = "Arial";
        this.labelPlacementProperty = LabelPlacement_1.ELabelPlacement.Auto;
        this.labelValueProperty = "";
        this.stroke = (_a = options === null || options === void 0 ? void 0 : options.stroke) !== null && _a !== void 0 ? _a : this.strokeProperty;
        this.strokeThickness = (_b = options === null || options === void 0 ? void 0 : options.strokeThickness) !== null && _b !== void 0 ? _b : this.strokeThicknessProperty;
        this.strokeDashArray = (_c = options === null || options === void 0 ? void 0 : options.strokeDashArray) !== null && _c !== void 0 ? _c : this.strokeDashArrayProperty;
        this.showLabelProperty = (_d = options === null || options === void 0 ? void 0 : options.showLabel) !== null && _d !== void 0 ? _d : this.showLabelProperty;
        this.axisLabelStrokeProperty = (_e = options === null || options === void 0 ? void 0 : options.axisLabelStroke) !== null && _e !== void 0 ? _e : this.axisLabelStrokeProperty;
        this.axisLabelFillProperty = (_f = options === null || options === void 0 ? void 0 : options.axisLabelFill) !== null && _f !== void 0 ? _f : this.axisLabelFillProperty;
        this.axisFontSizeProperty = (_g = options === null || options === void 0 ? void 0 : options.axisFontSize) !== null && _g !== void 0 ? _g : this.axisFontSizeProperty;
        this.axisFontFamilyProperty = (_h = options === null || options === void 0 ? void 0 : options.axisFontFamily) !== null && _h !== void 0 ? _h : this.axisFontFamilyProperty;
        this.labelPlacementProperty = (_j = options === null || options === void 0 ? void 0 : options.labelPlacement) !== null && _j !== void 0 ? _j : this.labelPlacementProperty;
        this.labelValueProperty = (_k = options === null || options === void 0 ? void 0 : options.labelValue) !== null && _k !== void 0 ? _k : this.labelValueProperty;
    }
    /**
     * Gets the stroke for the {@link LineAnnotation}
     * @remarks Acceptable values include RGB format e.g. ```#FF0000```, RGBA format e.g. ```#FF000077`` and RGBA format e.g. ```rgba(255,0,0,0.5)```
     */
    get stroke() {
        return this.strokeProperty;
    }
    /**
     * Sets the stroke for the {@link LineAnnotation}
     * @remarks Acceptable values include RGB format e.g. ```#FF0000```, RGBA format e.g. ```#FF000077`` and RGBA format e.g. ```rgba(255,0,0,0.5)```
     */
    set stroke(htmlColorCode) {
        this.strokeProperty = htmlColorCode;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE);
    }
    /**
     * Gets the strokeThickness for the {@link LineAnnotation}
     */
    get strokeThickness() {
        return this.strokeThicknessProperty;
    }
    /**
     * Sets the strokeThickness for the {@link LineAnnotation}
     */
    set strokeThickness(value) {
        this.strokeThicknessProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE_THICKNESS);
    }
    /**
     * Gets the strokeDashArray for the {@link LineAnnotation}
     */
    get strokeDashArray() {
        return this.strokeDashArrayProperty;
    }
    /**
     * Sets the strokeDashArray for the {@link LineAnnotation}
     */
    set strokeDashArray(value) {
        this.strokeDashArrayProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE_DASH_ARRAY);
    }
    /**
     * Gets the showLabel for the {@link LineAnnotation}
     */
    get showLabel() {
        return this.showLabelProperty;
    }
    /**
     * Sets the showLabel for the {@link LineAnnotation}
     */
    set showLabel(value) {
        this.showLabelProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.SHOW_LABEL);
    }
    /**
     * Gets the axisLabelStroke for the {@link LineAnnotation}
     */
    get axisLabelStroke() {
        return this.axisLabelStrokeProperty;
    }
    /**
     * Sets the axisLabelStroke for the {@link LineAnnotation}
     */
    set axisLabelStroke(value) {
        this.axisLabelStrokeProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.AXIS_LABELS_STROKE);
    }
    /**
     * Gets the axisLabelFill for the {@link LineAnnotation}
     */
    get axisLabelFill() {
        return this.axisLabelFillProperty;
    }
    /**
     * Sets the axisLabelFill for the {@link LineAnnotation}
     */
    set axisLabelFill(value) {
        this.axisLabelFillProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.AXIS_LABELS_FILL);
    }
    /**
     * Gets the axisFontSize for the {@link LineAnnotation}
     */
    get axisFontSize() {
        return this.axisFontSizeProperty;
    }
    /**
     * Sets the axisFontSize for the {@link LineAnnotation}
     */
    set axisFontSize(value) {
        this.axisFontSizeProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.AXIS_FONT_SIZE);
    }
    /**
     * Gets the axisFontSize for the {@link LineAnnotation}
     */
    get axisFontFamily() {
        return this.axisFontFamilyProperty;
    }
    /**
     * Sets the axisFontSize for the {@link LineAnnotation}
     */
    set axisFontFamily(value) {
        this.axisFontFamilyProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.AXIS_FONT_FAMILY);
    }
    /**
     * Gets the labelPlacement for the {@link LineAnnotation}
     */
    get labelPlacement() {
        return this.labelPlacementProperty;
    }
    /**
     * Sets the labelPlacement for the {@link LineAnnotation}
     */
    set labelPlacement(value) {
        this.labelPlacementProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.LABEL_PLACEMENT);
    }
    /**
     * Gets the labelValue for the {@link LineAnnotation}
     */
    get labelValue() {
        return this.labelValueProperty;
    }
    /**
     * Sets the labelValue for the {@link LineAnnotation}
     */
    set labelValue(value) {
        this.labelValueProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.LABEL_VALUE);
    }
    /** @inheritDoc */
    delete() {
        this.strokePenCache = Deleter_1.deleteSafe(this.strokePenCache);
    }
    /** @inheritDoc */
    onAttach(scs) {
        super.onAttach(scs);
        if (!this.strokePenCache) {
            this.strokePenCache = new Pen2DCache_1.Pen2DCache(scs.webAssemblyContext2D);
        }
        Pen2DCache_1.createPenInCache(this.strokePenCache, this.stroke, this.strokeThickness, this.opacity, this.strokeDashArray);
    }
    /** @inheritDoc */
    drawWithContext(renderContext, xCalc, yCalc, viewRect) {
        if (this.isHidden) {
            return;
        }
        Guard_1.Guard.notNull(renderContext, "renderContext");
        Guard_1.Guard.notNull(xCalc, "xCalc");
        Guard_1.Guard.notNull(yCalc, "yCalc");
        const strokePen = this.stroke && this.strokeThickness ? Pen2DCache_1.getWebGlPenFromCache(this.strokePenCache) : undefined;
        this.annontationBorders.x1 = this.getX1Coordinate(xCalc, yCalc);
        this.annontationBorders.x2 = this.getX2Coordinate(xCalc, yCalc);
        this.annontationBorders.y1 = this.getY1Coordinate(xCalc, yCalc);
        this.annontationBorders.y2 = this.getY2Coordinate(xCalc, yCalc);
        renderContext.drawLine(this.annontationBorders.x1, this.annontationBorders.y1, this.annontationBorders.x2, this.annontationBorders.y2, strokePen, viewRect);
        if (this.showLabel) {
            let axes = [];
            let verticalAxes = [];
            let coord;
            // Axis labels are shown only for lines perpendicular to axis
            if (this.annontationBorders.x1 === this.annontationBorders.x2) {
                axes = this.parentSurface.xAxes.asArray().filter(el => !el.isVerticalChart);
                verticalAxes = this.parentSurface.yAxes.asArray().filter(el => el.isVerticalChart);
                coord = this.annontationBorders.x1;
            }
            else if (this.annontationBorders.y1 === this.annontationBorders.y2) {
                axes = this.parentSurface.yAxes.asArray().filter(el => !el.isVerticalChart);
                verticalAxes = this.parentSurface.xAxes.asArray().filter(el => el.isVerticalChart);
                coord = this.annontationBorders.y1;
            }
            if (axes.length > 0 || verticalAxes.length > 0)
                [...axes, ...verticalAxes].forEach(el => drawLabel_1.drawModifiersAxisLabel(el, renderContext, coord, this.axisLabelFill, this.axisLabelStroke));
        }
        this.updateAdornerInner(this.annontationBorders.x1, this.annontationBorders.x2, this.annontationBorders.y1, this.annontationBorders.y2);
    }
    checkIsClickedOnAnnotation(xyPoint, x1Coord, y1Coord, x2Coord, y2Coord) {
        if (x1Coord < x2Coord) {
            x1Coord = this.annontationBorders.x2;
            x2Coord = this.annontationBorders.x1;
        }
        if (y1Coord > y2Coord) {
            y1Coord = this.annontationBorders.y2;
            y2Coord = this.annontationBorders.y1;
        }
        const distanceFromLine = pointUtil_1.calcDistanceFromLineSegment(xyPoint.x, xyPoint.y, x1Coord, y1Coord, x2Coord, y2Coord);
        return distanceFromLine <= constants_1.DISTANCE_TO_LINE;
    }
    onDragStarted(args) {
        super.onDragStarted(args);
        const x1 = this.x1;
        const x2 = this.type === IAnnotation_1.EAnnotationType.RenderContextHorizontalLineAnnotation ||
            this.type === IAnnotation_1.EAnnotationType.RenderContextVerticalLineAnnotation
            ? this.x1
            : this.x2;
        const y1 = this.y1;
        const y2 = this.type === IAnnotation_1.EAnnotationType.RenderContextHorizontalLineAnnotation ||
            this.type === IAnnotation_1.EAnnotationType.RenderContextVerticalLineAnnotation
            ? this.y1
            : this.y2;
        const xyCoord1 = this.getXYCoordinatesFromValues(new Point_1.Point(x1, y1));
        const xyCoord2 = this.getXYCoordinatesFromValues(new Point_1.Point(x2, y2));
        const xyCoordBody = new Point_1.Point(args.mousePoint.x, args.mousePoint.y);
        if (xyCoord1) {
            const dist = pointUtil_1.calcDistance(xyCoord1.x, xyCoord1.y, args.mousePoint.x, args.mousePoint.y);
            if (dist < constants_1.ADORNER_GRIP_RADIUS) {
                this.adornerDraggingPoint = AnnotationBase_1.EDraggingGripPoint.Point1;
                return true;
            }
        }
        if (xyCoord2) {
            const dist = pointUtil_1.calcDistance(xyCoord2.x, xyCoord2.y, args.mousePoint.x, args.mousePoint.y);
            if (dist < constants_1.ADORNER_GRIP_RADIUS) {
                this.adornerDraggingPoint = AnnotationBase_1.EDraggingGripPoint.Point2;
                return true;
            }
        }
        if (xyCoordBody) {
            if (this.isPointWithinBounds(args)) {
                this.adornerDraggingPoint = AnnotationBase_1.EDraggingGripPoint.Body;
                return true;
            }
        }
        return false;
    }
    ÑalcDragDistance(xyValues) {
        const isVerticalChart = this.parentSurface.getYAxisById(this.yAxisId).isVerticalChart;
        if (this.adornerDraggingPoint === AnnotationBase_1.EDraggingGripPoint.Body) {
            if (!this.prevValue) {
                this.prevValue = xyValues;
                return;
            }
            if (this.type === IAnnotation_1.EAnnotationType.RenderContextHorizontalLineAnnotation) {
                if (isVerticalChart) {
                    this.x1 = this.x1 - (this.prevValue.x - xyValues.x);
                }
                else {
                    this.y1 = this.y1 - (this.prevValue.y - xyValues.y);
                }
            }
            else if (this.type === IAnnotation_1.EAnnotationType.RenderContextVerticalLineAnnotation) {
                if (isVerticalChart) {
                    this.y1 = this.y1 - (this.prevValue.y - xyValues.y);
                }
                else {
                    this.x1 = this.x1 - (this.prevValue.x - xyValues.x);
                }
            }
            else if (this.type === IAnnotation_1.EAnnotationType.RenderContextLineAnnotation) {
                this.x1 = this.x1 - (this.prevValue.x - xyValues.x);
                this.x2 = this.x2 - (this.prevValue.x - xyValues.x);
                this.y1 = this.y1 - (this.prevValue.y - xyValues.y);
                this.y2 = this.y2 - (this.prevValue.y - xyValues.y);
            }
            this.prevValue = xyValues;
        }
        else if (this.adornerDraggingPoint === AnnotationBase_1.EDraggingGripPoint.Point1) {
            if (this.resizeDirections === XyDirection_1.EXyDirection.XDirection) {
                this.y1 = this.y1;
                this.x1 = xyValues.x;
            }
            else if (this.resizeDirections === XyDirection_1.EXyDirection.YDirection) {
                this.x1 = this.x1;
                this.y1 = xyValues.y;
            }
            else {
                this.x1 = xyValues.x;
                this.y1 = xyValues.y;
            }
        }
        else if (this.adornerDraggingPoint === AnnotationBase_1.EDraggingGripPoint.Point2) {
            if (this.resizeDirections === XyDirection_1.EXyDirection.XDirection) {
                this.y2 = this.y2;
                this.x2 = xyValues.x;
            }
            else if (this.resizeDirections === XyDirection_1.EXyDirection.YDirection) {
                this.x2 = this.x2;
                this.y2 = xyValues.y;
            }
            else {
                this.x2 = xyValues.x;
                this.y2 = xyValues.y;
            }
        }
    }
    notifyPropertyChanged(propertyName) {
        super.notifyPropertyChanged(propertyName);
        const strokePenRelatedProperties = [
            constants_1.PROPERTY.STROKE,
            constants_1.PROPERTY.STROKE_THICKNESS,
            constants_1.PROPERTY.STROKE_DASH_ARRAY,
            constants_1.PROPERTY.OPACITY
        ];
        if (strokePenRelatedProperties.includes(propertyName) && this.strokePenCache) {
            Pen2DCache_1.createPenInCache(this.strokePenCache, this.stroke, this.strokeThickness, this.opacity, this.strokeDashArray);
        }
    }
    updateAdornerInner(x1Coord, x2Coord, y1Coord, y2Coord) {
        super.updateAdorner();
        const adornerSvgRoot = this.parentSurface.domSvgAdornerLayer;
        if (this.svgAdorner) {
            this.deleteAdorner();
        }
        if (this.isSelected) {
            const svgString = svgStringTemplate(x1Coord, y1Coord, x2Coord, y2Coord);
            this.svgAdorner = createSvg(svgString, adornerSvgRoot);
        }
    }
}
exports.LineAnnotation = LineAnnotation;
/** @ignore */
const svgStringTemplate = (x1, y1, x2, y2) => {
    const colorLine = "#f00e0e66";
    const adornerFill = "#CDCDCD22";
    const adornerStroke = "#CDCDCD99";
    return `<svg xmlns="http://www.w3.org/2000/svg">
  <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${colorLine}" stroke-width="6" />
  <circle cx="${x1}" cy="${y1}" r="${constants_1.ADORNER_GRIP_RADIUS}" fill="${adornerFill}" stroke="${adornerStroke}"/>
  <circle cx="${x2}" cy="${y2}" r="${constants_1.ADORNER_GRIP_RADIUS}" fill="${adornerFill}" stroke="${adornerStroke}"/>
</svg>`;
};
/** @ignore */
const createSvg = (svgString, svgRoot) => {
    const svgNode = document.createRange().createContextualFragment(svgString);
    svgRoot.appendChild(svgNode);
    return svgRoot.lastChild;
};
