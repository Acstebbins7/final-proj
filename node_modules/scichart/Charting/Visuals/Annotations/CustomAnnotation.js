"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomAnnotation = void 0;
const AnchorPoint_1 = require("../../../types/AnchorPoint");
const IAnnotation_1 = require("./IAnnotation");
const SvgAnnotationBase_1 = require("./SvgAnnotationBase");
/**
 * A CustomAnnotation presents SVG information over the chart at specific {@link X1}, {@link Y1} coordinates
 */
class CustomAnnotation extends SvgAnnotationBase_1.SvgAnnotationBase {
    /**
     * Creates an instance of the {@link CustomAnnotation}
     * @param options The {@link ICustomAnnotationOptions} which contain optional parameters
     */
    constructor(options) {
        var _a;
        super(options);
        /** @inheritDoc */
        this.type = IAnnotation_1.EAnnotationType.SVGCustomAnnotation;
        this.svgString = (_a = options === null || options === void 0 ? void 0 : options.svgString) !== null && _a !== void 0 ? _a : undefined;
    }
    /**
     * @inheritDoc
     */
    create(xCalc, yCalc) {
        if (this.svg && !this.isEditable) {
            return;
        }
        if (!this.svg ||
            (this.svg &&
                (this.isSelected ||
                    this.prevX1Coordinate !== this.getX1Coordinate(xCalc, yCalc) ||
                    this.prevY1Coordinate !== this.getY1Coordinate(xCalc, yCalc)))) {
            this.annontationBorders.x1 = this.prevX1Coordinate = this.getX1Coordinate(xCalc, yCalc);
            this.annontationBorders.y1 = this.prevY1Coordinate = this.getY1Coordinate(xCalc, yCalc);
            if (this.svg) {
                this.delete();
            }
            this.svg = createSvg(this.svgString, this.svgRoot);
            this.svgProperties = this.svg.getBoundingClientRect();
            this.annontationBorders.x2 = this.annontationBorders.x1 + this.svgProperties.width;
            this.annontationBorders.y2 = this.annontationBorders.y1 + this.svgProperties.height;
            if (this.verticalAnchorPoint === AnchorPoint_1.EVerticalAnchorPoint.Bottom) {
                this.annontationBorders.y2 = this.annontationBorders.y1 - this.svgProperties.height;
            }
            if (this.verticalAnchorPoint === AnchorPoint_1.EVerticalAnchorPoint.Center) {
                this.annontationBorders.y2 = this.annontationBorders.y1 + this.svgProperties.height / 2;
                this.annontationBorders.y1 = this.annontationBorders.y1 - this.svgProperties.height / 2;
            }
            if (this.horizontalAnchorPoint === AnchorPoint_1.EHorizontalAnchorPoint.Right) {
                this.annontationBorders.x2 = this.annontationBorders.x1 - this.svgProperties.width;
            }
            if (this.horizontalAnchorPoint === AnchorPoint_1.EHorizontalAnchorPoint.Center) {
                this.annontationBorders.x2 = this.annontationBorders.x1 + this.svgProperties.width / 2;
                this.annontationBorders.x1 = this.annontationBorders.x1 - this.svgProperties.width / 2;
            }
            this.updateAdornerInner(this.annontationBorders.x1, this.annontationBorders.y1, this.annontationBorders.x2, this.annontationBorders.y2);
            this.prevIsSelected = this.isSelected;
        }
        if (this.prevIsSelected !== this.isSelected && this.svg && this.isEditable) {
            this.updateAdornerInner(this.annontationBorders.x1, this.annontationBorders.y1, this.annontationBorders.x2, this.annontationBorders.y2);
            this.prevIsSelected = this.isSelected;
        }
    }
}
exports.CustomAnnotation = CustomAnnotation;
/** @ignore */
const createSvg = (svgString, svgRoot) => {
    const svgNode = document.createRange().createContextualFragment(svgString);
    svgRoot.appendChild(svgNode);
    return svgRoot.lastChild;
};
