"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BoxAnnotation = void 0;
const Deleter_1 = require("../../../Core/Deleter");
const Guard_1 = require("../../../Core/Guard");
const Point_1 = require("../../../Core/Point");
const Rect_1 = require("../../../Core/Rect");
const XyDirection_1 = require("../../../types/XyDirection");
const pointUtil_1 = require("../../../utils/pointUtil");
const translate_1 = require("../../../utils/translate");
const BrushCache_1 = require("../../Drawing/BrushCache");
const Pen2DCache_1 = require("../../Drawing/Pen2DCache");
const AnnotationBase_1 = require("./AnnotationBase");
const constants_1 = require("./constants");
const constants_2 = require("./constants");
const IAnnotation_1 = require("./IAnnotation");
const RenderContextAnnotationBase_1 = require("./RenderContextAnnotationBase");
/**
 * @summary The {@link BoxAnnotation} provides an {@link AnnotationBase | Annotation} which draws a rectangle or box over the {@link SciChartSurface}
 * @description
 * To add a {@link BoxAnnotation} to a {@link SciChartSurface}, use the following code:
 * ```ts
 * const sciChartSurface: SciChartSurface;
 * const boxAnnotation = new BoxAnnotation( { x1: 1, x2: 2, y1: 3, y2: 4, fill: "#FF000077", stroke: "#FF0000"});
 * sciChartSurface.annotations.add(boxAnnotation);
 * ```
 * @remarks Uses the fast WebGL/WebAssembly {@link WebGL2RenderingContext} for rendering
 */
class BoxAnnotation extends RenderContextAnnotationBase_1.RenderContextAnnotationBase {
    /**
     * Create an instance of a BoxAnnotation
     * @param options Optional parameters of type {@link IBoxAnnotationOptions} which configure the annotation upon construction
     */
    constructor(options) {
        var _a, _b, _c;
        super(options);
        /** @inheritDoc */
        this.type = IAnnotation_1.EAnnotationType.RenderContextBoxAnnotation;
        this.strokeThicknessProperty = 1;
        this.stroke = (_a = options === null || options === void 0 ? void 0 : options.stroke) !== null && _a !== void 0 ? _a : "#ffffff";
        this.strokeThickness = (_b = options === null || options === void 0 ? void 0 : options.strokeThickness) !== null && _b !== void 0 ? _b : 1;
        this.fill = (_c = options === null || options === void 0 ? void 0 : options.fill) !== null && _c !== void 0 ? _c : "#777777";
    }
    /**
     * Gets stroke for the outline of the {@link BoxAnnotation}
     * @remarks Acceptable values include RGB format e.g. ```#FF0000```, RGBA format e.g. ```#FF000077`` and RGBA format e.g. ```rgba(255,0,0,0.5)```
     */
    get stroke() {
        return this.strokeProperty;
    }
    /**
     * Sets the stroke for the outline of the {@link BoxAnnotation}
     * @remarks Acceptable values include RGB format e.g. ```#FF0000```, RGBA format e.g. ```#FF000077`` and RGBA format e.g. ```rgba(255,0,0,0.5)```
     */
    set stroke(htmlColorCode) {
        this.strokeProperty = htmlColorCode;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE);
    }
    /**
     * Gets the strokeThickness for the outline of the {@link BoxAnnotation}
     */
    get strokeThickness() {
        return this.strokeThicknessProperty;
    }
    /**
     * Sets the strokeThickness for the outline of the {@link BoxAnnotation}
     */
    set strokeThickness(value) {
        this.strokeThicknessProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE_THICKNESS);
    }
    /**
     * Gets the fill for the {@link BoxAnnotation}
     * @remarks Acceptable values include RGB format e.g. ```#FF0000```, RGBA format e.g. ```#FF000077`` and RGBA format e.g. ```rgba(255,0,0,0.5)```
     */
    get fill() {
        return this.fillProperty;
    }
    /**
     * Sets the fill for the {@link BoxAnnotation}
     * @remarks Acceptable values include RGB format e.g. ```#FF0000```, RGBA format e.g. ```#FF000077`` and RGBA format e.g. ```rgba(255,0,0,0.5)```
     */
    set fill(htmlColorCode) {
        this.fillProperty = htmlColorCode;
        this.notifyPropertyChanged(constants_1.PROPERTY.FILL);
    }
    /** @inheritDoc */
    delete() {
        this.strokePenCache = Deleter_1.deleteSafe(this.strokePenCache);
        this.fillBrushCache = Deleter_1.deleteSafe(this.fillBrushCache);
    }
    /** @inheritDoc */
    drawWithContext(renderContext, xCalc, yCalc, viewRect) {
        Guard_1.Guard.notNull(renderContext, "renderContext");
        Guard_1.Guard.notNull(xCalc, "xCalc");
        Guard_1.Guard.notNull(yCalc, "yCalc");
        const strokePen = this.stroke && this.strokeThickness ? Pen2DCache_1.getWebGlPenFromCache(this.strokePenCache) : undefined;
        strokePen === null || strokePen === void 0 ? void 0 : strokePen.setOpacity(this.opacity);
        const fillBrush = this.fill ? BrushCache_1.getWebGlBrushFromCache(this.fillBrushCache) : undefined;
        fillBrush === null || fillBrush === void 0 ? void 0 : fillBrush.setOpacity(this.opacity);
        this.annontationBorders.x1 = this.getX1Coordinate(xCalc, yCalc);
        this.annontationBorders.x2 = this.getX2Coordinate(xCalc, yCalc);
        this.annontationBorders.y1 = this.getY1Coordinate(xCalc, yCalc);
        this.annontationBorders.y2 = this.getY2Coordinate(xCalc, yCalc);
        const rect = Rect_1.Rect.createWithPoints(new Point_1.Point(this.annontationBorders.x1, this.annontationBorders.y1), new Point_1.Point(this.annontationBorders.x2, this.annontationBorders.y2));
        renderContext.drawRect(rect, viewRect, strokePen, fillBrush);
        this.updateAdornerInner(this.annontationBorders.x1, this.annontationBorders.x2, this.annontationBorders.y1, this.annontationBorders.y2);
    }
    /** @inheritDoc */
    onAttach(scs) {
        super.onAttach(scs);
        if (!this.strokePenCache) {
            this.strokePenCache = new Pen2DCache_1.Pen2DCache(scs.webAssemblyContext2D);
        }
        Pen2DCache_1.createPenInCache(this.strokePenCache, this.stroke, this.strokeThickness, this.opacity);
        if (!this.fillBrushCache) {
            this.fillBrushCache = new BrushCache_1.BrushCache(scs.webAssemblyContext2D);
        }
        BrushCache_1.createBrushInCache(this.fillBrushCache, this.fill, this.opacity);
    }
    onDragStarted(args) {
        super.onDragStarted(args);
        const { point1, point2, point3, point4 } = calcNewApex(this.x1, this.y1, this.x2, this.y2);
        const xyCoord1 = this.getXYCoordinatesFromValues(new Point_1.Point(point1.x, point1.y));
        const xyCoord2 = this.getXYCoordinatesFromValues(new Point_1.Point(point2.x, point2.y));
        const xyCoord3 = this.getXYCoordinatesFromValues(new Point_1.Point(point3.x, point3.y));
        const xyCoord4 = this.getXYCoordinatesFromValues(new Point_1.Point(point4.x, point4.y));
        const xyMousePoint = translate_1.translateFromCanvasToSeriesViewRect(new Point_1.Point(args.mousePoint.x, args.mousePoint.y), this.parentSurface.seriesViewRect);
        if (xyCoord1) {
            const dist = pointUtil_1.calcDistance(xyCoord1.x, xyCoord1.y, args.mousePoint.x, args.mousePoint.y);
            if (dist < constants_2.ADORNER_GRIP_RADIUS) {
                this.adornerDraggingPoint = AnnotationBase_1.EDraggingGripPoint.Point1;
                return true;
            }
        }
        if (xyCoord2) {
            const dist = pointUtil_1.calcDistance(xyCoord2.x, xyCoord2.y, args.mousePoint.x, args.mousePoint.y);
            if (dist < constants_2.ADORNER_GRIP_RADIUS) {
                this.adornerDraggingPoint = AnnotationBase_1.EDraggingGripPoint.Point2;
                return true;
            }
        }
        if (xyCoord3) {
            const dist = pointUtil_1.calcDistance(xyCoord3.x, xyCoord3.y, args.mousePoint.x, args.mousePoint.y);
            if (dist < constants_2.ADORNER_GRIP_RADIUS) {
                this.adornerDraggingPoint = AnnotationBase_1.EDraggingGripPoint.Point3;
                return true;
            }
        }
        if (xyCoord4) {
            const dist = pointUtil_1.calcDistance(xyCoord4.x, xyCoord4.y, args.mousePoint.x, args.mousePoint.y);
            if (dist < constants_2.ADORNER_GRIP_RADIUS) {
                this.adornerDraggingPoint = AnnotationBase_1.EDraggingGripPoint.Point4;
                return true;
            }
        }
        if (xyMousePoint) {
            if (this.isPointWithinBounds(args)) {
                this.adornerDraggingPoint = AnnotationBase_1.EDraggingGripPoint.Body;
                return true;
            }
        }
        return false;
    }
    checkIsClickedOnAnnotation(xyPoint, x1Coord, y1Coord, x2Coord, y2Coord) {
        const isInBounds = pointUtil_1.testIsInBounds(xyPoint.x, xyPoint.y, x1Coord, y1Coord, x2Coord, y2Coord);
        return isInBounds;
    }
    сalcDragDistance(xyValues) {
        if (this.adornerDraggingPoint === AnnotationBase_1.EDraggingGripPoint.Body) {
            if (!this.prevValue) {
                this.prevValue = xyValues;
                return;
            }
            this.x1 = this.x1 - (this.prevValue.x - xyValues.x);
            this.x2 = this.x2 - (this.prevValue.x - xyValues.x);
            this.y1 = this.y1 - (this.prevValue.y - xyValues.y);
            this.y2 = this.y2 - (this.prevValue.y - xyValues.y);
            this.prevValue = xyValues;
        }
        else if (this.adornerDraggingPoint === AnnotationBase_1.EDraggingGripPoint.Point1) {
            if (this.resizeDirections === XyDirection_1.EXyDirection.XDirection) {
                this.y2 = this.y2;
                this.x1 = xyValues.x;
            }
            else if (this.resizeDirections === XyDirection_1.EXyDirection.YDirection) {
                this.x1 = this.x1;
                this.y2 = xyValues.y;
            }
            else {
                this.x1 = xyValues.x;
                this.y2 = xyValues.y;
            }
        }
        else if (this.adornerDraggingPoint === AnnotationBase_1.EDraggingGripPoint.Point2) {
            if (this.resizeDirections === XyDirection_1.EXyDirection.XDirection) {
                this.y2 = this.y2;
                this.x2 = xyValues.x;
            }
            else if (this.resizeDirections === XyDirection_1.EXyDirection.YDirection) {
                this.x2 = this.x2;
                this.y2 = xyValues.y;
            }
            else {
                this.x2 = xyValues.x;
                this.y2 = xyValues.y;
            }
        }
        else if (this.adornerDraggingPoint === AnnotationBase_1.EDraggingGripPoint.Point3) {
            if (this.resizeDirections === XyDirection_1.EXyDirection.XDirection) {
                this.y1 = this.y1;
                this.x2 = xyValues.x;
            }
            else if (this.resizeDirections === XyDirection_1.EXyDirection.YDirection) {
                this.x2 = this.x2;
                this.y1 = xyValues.y;
            }
            else {
                this.x2 = xyValues.x;
                this.y1 = xyValues.y;
            }
        }
        else if (this.adornerDraggingPoint === AnnotationBase_1.EDraggingGripPoint.Point4) {
            if (this.resizeDirections === XyDirection_1.EXyDirection.XDirection) {
                this.y1 = this.y1;
                this.x1 = xyValues.x;
            }
            else if (this.resizeDirections === XyDirection_1.EXyDirection.YDirection) {
                this.x1 = this.x1;
                this.y1 = xyValues.y;
            }
            else {
                this.x1 = xyValues.x;
                this.y1 = xyValues.y;
            }
        }
    }
    notifyPropertyChanged(propertyName) {
        super.notifyPropertyChanged(propertyName);
        const strokePenRelatedProperties = [
            constants_1.PROPERTY.STROKE,
            constants_1.PROPERTY.STROKE_THICKNESS,
            constants_1.PROPERTY.STROKE_DASH_ARRAY,
            constants_1.PROPERTY.OPACITY
        ];
        if (this.strokePenCache && strokePenRelatedProperties.includes(propertyName)) {
            Pen2DCache_1.createPenInCache(this.strokePenCache, this.stroke, this.strokeThickness, this.opacity);
        }
        const fillBrushRelatedProperties = [constants_1.PROPERTY.FILL, constants_1.PROPERTY.OPACITY];
        if (this.fillBrushCache && fillBrushRelatedProperties.includes(propertyName)) {
            BrushCache_1.createBrushInCache(this.fillBrushCache, this.fill, this.opacity);
        }
    }
    updateAdornerInner(x1Coord, x2Coord, y1Coord, y2Coord) {
        super.updateAdorner();
        const adornerSvgRoot = this.parentSurface.domSvgAdornerLayer;
        if (this.svgAdorner) {
            this.deleteAdorner();
        }
        if (this.isSelected) {
            let xMin = x1Coord;
            let xMax = x2Coord;
            let yMin = y1Coord;
            let yMax = y2Coord;
            if (xMin > xMax) {
                xMin = x2Coord;
                xMax = x1Coord;
            }
            if (yMin > yMax) {
                yMin = y2Coord;
                yMax = y1Coord;
            }
            const svgString = svgStringTemplate(xMin, yMin, xMax, yMax);
            this.svgAdorner = createSvg(svgString, adornerSvgRoot);
        }
    }
}
exports.BoxAnnotation = BoxAnnotation;
/** @ignore */
const svgStringTemplate = (x1, y1, x2, y2) => {
    const colorLine = "#f00e0e66";
    const adornerFill = "#CDCDCD22";
    const adornerStroke = "#CDCDCD99";
    const delta = 3;
    return `<svg xmlns="http://www.w3.org/2000/svg">
  <line x1="${x1 - delta}" y1="${y1}" x2="${x2 + delta}" y2="${y1}" stroke="${colorLine}" stroke-width="${2 * delta}" />
  <line x1="${x2}" y1="${y1 + delta}" x2="${x2}" y2="${y2 - delta}" stroke="${colorLine}" stroke-width="${2 * delta}" />
  <line x1="${x1 - delta}" y1="${y2}" x2="${x2 + delta}" y2="${y2}" stroke="${colorLine}" stroke-width="${2 * delta}" />
  <line x1="${x1}" y1="${y1 + delta}" x2="${x1}" y2="${y2 - delta}" stroke="${colorLine}" stroke-width="${2 * delta}" />
  <circle cx="${x1}" cy="${y1}" r="${constants_2.ADORNER_GRIP_RADIUS}" fill="${adornerFill}" stroke="${adornerStroke}"/>
  <circle cx="${x1}" cy="${y2}" r="${constants_2.ADORNER_GRIP_RADIUS}" fill="${adornerFill}" stroke="${adornerStroke}"/>
  <circle cx="${x2}" cy="${y1}" r="${constants_2.ADORNER_GRIP_RADIUS}" fill="${adornerFill}" stroke="${adornerStroke}"/>
  <circle cx="${x2}" cy="${y2}" r="${constants_2.ADORNER_GRIP_RADIUS}" fill="${adornerFill}" stroke="${adornerStroke}"/>
</svg>`;
};
/** @ignore */
const createSvg = (svgString, svgRoot) => {
    const svgNode = document.createRange().createContextualFragment(svgString);
    svgRoot.appendChild(svgNode);
    return svgRoot.lastChild;
};
const calcNewApex = (x1, y1, x2, y2) => {
    const point1 = { x: x1, y: y2 };
    const point2 = { x: x2, y: y2 };
    const point3 = { x: x2, y: y1 };
    const point4 = { x: x1, y: y1 };
    return { point1, point2, point3, point4 };
};
