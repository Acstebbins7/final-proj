"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcNewApex = exports.AnnotationBase = exports.ECoordinateMode = exports.EDraggingGripPoint = void 0;
const EventHandler_1 = require("../../../Core/EventHandler");
const Guard_1 = require("../../../Core/Guard");
const Point_1 = require("../../../Core/Point");
const XyDirection_1 = require("../../../types/XyDirection");
const translate_1 = require("../../../utils/translate");
const AxisCore_1 = require("../Axis/AxisCore");
const AnnotationDragDeltaEventArgs_1 = require("./AnnotationDragDeltaEventArgs");
const constants_1 = require("./constants");
const IAnnotation_1 = require("./IAnnotation");
var EDraggingGripPoint;
(function (EDraggingGripPoint) {
    EDraggingGripPoint["Point1"] = "Point1";
    EDraggingGripPoint["Point2"] = "Point2";
    EDraggingGripPoint["Point3"] = "Point3";
    EDraggingGripPoint["Point4"] = "Point4";
    EDraggingGripPoint["Body"] = "Body";
})(EDraggingGripPoint = exports.EDraggingGripPoint || (exports.EDraggingGripPoint = {}));
/**
 * Defines the CoordinateMode for {@link AnnotationBase | Annotations} within SciChart's
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 */
var ECoordinateMode;
(function (ECoordinateMode) {
    /**
     * The {@link AnnotationBase.x1 | Annotation.x1}, {@link AnnotationBase.x2 | x2},
     * {@link AnnotationBase.y1 | y1}, {@link AnnotationBase.y2 | y2} coordinate is a data-value,
     * corresponding to the value on the {@link AxisBase2D | Axis} or in the
     * {@link IRenderableSeries.dataSeries | DataSeries}
     */
    ECoordinateMode[ECoordinateMode["DataValue"] = 0] = "DataValue";
    /**
     * The {@link AnnotationBase.x1 | Annotation.x1}, {@link AnnotationBase.x2 | x2},
     * {@link AnnotationBase.y1 | y1}, {@link AnnotationBase.y2 | y2} coordinate is a pixel coordinate,
     * corresponding to the distance from the top-left of the
     * {@link SciChartSurface}
     */
    ECoordinateMode[ECoordinateMode["Pixel"] = 1] = "Pixel";
    /**
     * The {@link AnnotationBase.x1 | Annotation.x1}, {@link AnnotationBase.x2 | x2},
     * {@link AnnotationBase.y1 | y1}, {@link AnnotationBase.y2 | y2} coordinate is relative,
     * where 0.0 corresponds to the left (or top) of the {@link SciChartSurface}
     * and 1.0 corresponds to the right (or bottom) of the {@link SciChartSurface}
     */
    ECoordinateMode[ECoordinateMode["Relative"] = 2] = "Relative";
})(ECoordinateMode = exports.ECoordinateMode || (exports.ECoordinateMode = {}));
/**
 * Defines the base class to an Annotation - a type of marker, text label, line or custom UI overlay on a 2D Cartesian {@link SciChartSurface}
 */
class AnnotationBase {
    /**
     * Creates an instance of the Annotation
     * @param options optional parameters of type {@link IAnnotationBaseOptions} used to configure the annotation at construct time
     */
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        this.prevIsSelected = true;
        this.annontationBorders = {
            x1: 0,
            x2: 0,
            y1: 0,
            y2: 0
        };
        this.annotationLayerProperty = IAnnotation_1.EAnnotationLayer.AboveChart;
        this.isEditableProperty = false;
        this.isHiddenProperty = false;
        this.xAxisIdProperty = AxisCore_1.AxisCore.DEFAULT_AXIS_ID;
        this.yAxisIdProperty = AxisCore_1.AxisCore.DEFAULT_AXIS_ID;
        this.xCoordinateModeProperty = ECoordinateMode.DataValue;
        this.yCoordinateModeProperty = ECoordinateMode.DataValue;
        this.isSelectedProperty = false;
        this.resizeDirectionsProperty = XyDirection_1.EXyDirection.XyDirection;
        this.dragStarted = new EventHandler_1.EventHandler();
        this.dragEnded = new EventHandler_1.EventHandler();
        this.dragDelta = new EventHandler_1.EventHandler();
        this.annotationLayerProperty = (_a = options === null || options === void 0 ? void 0 : options.annotationLayer) !== null && _a !== void 0 ? _a : this.annotationLayerProperty;
        this.resizeDirectionsProperty = (_b = options === null || options === void 0 ? void 0 : options.resizeDirections) !== null && _b !== void 0 ? _b : this.resizeDirectionsProperty;
        this.isEditableProperty = (_c = options === null || options === void 0 ? void 0 : options.isEditable) !== null && _c !== void 0 ? _c : this.isEditableProperty;
        this.isHiddenProperty = (_d = options === null || options === void 0 ? void 0 : options.isHidden) !== null && _d !== void 0 ? _d : this.isHiddenProperty;
        this.x1Property = (_e = options === null || options === void 0 ? void 0 : options.x1) !== null && _e !== void 0 ? _e : this.x1Property;
        this.y1Property = (_f = options === null || options === void 0 ? void 0 : options.y1) !== null && _f !== void 0 ? _f : this.y1Property;
        this.x2Property = (_g = options === null || options === void 0 ? void 0 : options.x2) !== null && _g !== void 0 ? _g : this.x2Property;
        this.y2Property = (_h = options === null || options === void 0 ? void 0 : options.y2) !== null && _h !== void 0 ? _h : this.y2Property;
        this.xAxisIdProperty = (_j = options === null || options === void 0 ? void 0 : options.xAxisId) !== null && _j !== void 0 ? _j : this.xAxisIdProperty;
        this.yAxisIdProperty = (_k = options === null || options === void 0 ? void 0 : options.yAxisId) !== null && _k !== void 0 ? _k : this.yAxisIdProperty;
        this.xCoordinateModeProperty = (_l = options === null || options === void 0 ? void 0 : options.xCoordinateMode) !== null && _l !== void 0 ? _l : this.xCoordinateModeProperty;
        this.yCoordinateModeProperty = (_m = options === null || options === void 0 ? void 0 : options.yCoordinateMode) !== null && _m !== void 0 ? _m : this.yCoordinateModeProperty;
        this.isSelectedProperty = (_o = options === null || options === void 0 ? void 0 : options.isSelected) !== null && _o !== void 0 ? _o : this.isSelectedProperty;
        this.opacityProperty = (_p = options === null || options === void 0 ? void 0 : options.opacity) !== null && _p !== void 0 ? _p : 1.0;
        if (options === null || options === void 0 ? void 0 : options.onDragStarted) {
            this.dragStarted.subscribe(options === null || options === void 0 ? void 0 : options.onDragStarted);
        }
        if (options === null || options === void 0 ? void 0 : options.onDragEnded) {
            this.dragEnded.subscribe(options === null || options === void 0 ? void 0 : options.onDragEnded);
        }
        if (options === null || options === void 0 ? void 0 : options.onDrag) {
            this.dragDelta.subscribe(options === null || options === void 0 ? void 0 : options.onDrag);
        }
    }
    /** @inheritDoc */
    get annotationLayer() {
        return this.annotationLayerProperty;
    }
    /** @inheritDoc */
    set annotationLayer(annotationCanvas) {
        this.annotationLayerProperty = annotationCanvas;
        this.notifyPropertyChanged(constants_1.PROPERTY.ANNOTATION_CANVAS);
    }
    /** @inheritDoc */
    get parentSurface() {
        return this.parentSurfaceProperty;
    }
    /** @inheritDoc */
    set parentSurface(parentSurface) {
        this.parentSurfaceProperty = parentSurface;
        this.notifyPropertyChanged(constants_1.PROPERTY.PARENT_SURFACE);
    }
    /** @inheritDoc */
    get isEditable() {
        return this.isEditableProperty;
    }
    /** @inheritDoc */
    set isEditable(isEditable) {
        this.isEditableProperty = isEditable;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_EDITABLE);
    }
    /** @inheritDoc */
    get isHidden() {
        return this.isHiddenProperty;
    }
    /** @inheritDoc */
    set isHidden(isHidden) {
        this.isHiddenProperty = isHidden;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_HIDDEN);
    }
    /** @inheritDoc */
    get xCoordinateMode() {
        return this.xCoordinateModeProperty;
    }
    /** @inheritDoc */
    set xCoordinateMode(xCoordinateMode) {
        this.xCoordinateModeProperty = xCoordinateMode;
        this.notifyPropertyChanged(constants_1.PROPERTY.X_COORDINATE_MODE);
    }
    /** @inheritDoc */
    get yCoordinateMode() {
        return this.yCoordinateModeProperty;
    }
    /** @inheritDoc */
    set yCoordinateMode(yCoordinateMode) {
        this.yCoordinateModeProperty = yCoordinateMode;
        this.notifyPropertyChanged(constants_1.PROPERTY.Y_COORDINATE_MODE);
    }
    /** @inheritDoc */
    get x1() {
        return this.x1Property;
    }
    /** @inheritDoc */
    set x1(x1) {
        this.x1Property = x1;
        this.notifyPropertyChanged(constants_1.PROPERTY.X1);
    }
    /** @inheritDoc */
    get x2() {
        return this.x2Property;
    }
    /** @inheritDoc */
    set x2(x2) {
        this.x2Property = x2;
        this.notifyPropertyChanged(constants_1.PROPERTY.X2);
    }
    /** @inheritDoc */
    get y1() {
        return this.y1Property;
    }
    /** @inheritDoc */
    set y1(y1) {
        this.y1Property = y1;
        this.notifyPropertyChanged(constants_1.PROPERTY.Y1);
    }
    /** @inheritDoc */
    get y2() {
        return this.y2Property;
    }
    /** @inheritDoc */
    set y2(y2) {
        this.y2Property = y2;
        this.notifyPropertyChanged(constants_1.PROPERTY.Y2);
    }
    /** @inheritDoc */
    get xAxisId() {
        return this.xAxisIdProperty;
    }
    /** @inheritDoc */
    set xAxisId(xAxisId) {
        this.xAxisIdProperty = xAxisId;
        this.notifyPropertyChanged(constants_1.PROPERTY.XAXIS_ID);
    }
    /** @inheritDoc */
    get yAxisId() {
        return this.yAxisIdProperty;
    }
    /** @inheritDoc */
    set yAxisId(yAxisId) {
        this.yAxisIdProperty = yAxisId;
        this.notifyPropertyChanged(constants_1.PROPERTY.YAXIS_ID);
    }
    /** @inheritDoc */
    get isVerticalChart() {
        const xAxis = this.parentSurface.xAxes.asArray().find(a => a.id === this.xAxisId);
        return xAxis.isVerticalChart;
    }
    /** @inheritDoc */
    set resizeDirections(value) {
        this.resizeDirectionsProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.RESIZE_DIRECTIONS);
    }
    /** @inheritDoc */
    get resizeDirections() {
        return this.resizeDirectionsProperty;
    }
    /** @inheritDoc */
    set isSelected(value) {
        this.isSelectedProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_SELECTED);
    }
    /** @inheritDoc */
    get isSelected() {
        return this.isSelectedProperty;
    }
    /** @inheritDoc */
    get opacity() {
        return this.opacityProperty;
    }
    /** @inheritDoc */
    set opacity(opacity) {
        this.opacityProperty = opacity;
        this.notifyPropertyChanged(constants_1.PROPERTY.OPACITY);
    }
    get isDraggingStarted() {
        return !!this.adornerDraggingPoint;
    }
    get svgAdornerRoot() {
        return this.svgAdornerRootProperty;
    }
    /** @inheritDoc */
    onAttach(scs) {
        this.svgAdornerRootProperty = scs.domSvgAdornerLayer;
        // Override in derived classes to be notified of attached
    }
    /** @inheritDoc */
    onDetach() {
        // Override in derived classes to be notified of detached
    }
    updateAdorner() {
        // this.updateAdornerInner();
        // this.updateAdornerInner();
    }
    // protected abstract updateAdornerInner(x1Coord: number, x2Coord: number, y1Coord: number, y2Coord: number): void;
    isPointWithinBounds(args) {
        const xyPointMouse = this.getXYValuesFromCoordinates(args.mousePoint, true);
        if (!xyPointMouse) {
            return false;
        }
        let x1Coord = this.annontationBorders.x1;
        let y1Coord = this.annontationBorders.y1;
        let x2Coord = this.annontationBorders.x2;
        let y2Coord = this.annontationBorders.y2;
        if (x1Coord > x2Coord) {
            x1Coord = this.annontationBorders.x2;
            x2Coord = this.annontationBorders.x1;
        }
        if (y1Coord < y2Coord) {
            y1Coord = this.annontationBorders.y2;
            y2Coord = this.annontationBorders.y1;
        }
        const xyPoint = translate_1.translateFromCanvasToSeriesViewRect(args.mousePoint, this.parentSurface.seriesViewRect);
        const isClickedOn = this.checkIsClickedOnAnnotation(xyPoint, x1Coord, y1Coord, x2Coord, y2Coord);
        this.isSelected = isClickedOn;
        return isClickedOn;
    }
    сalcDragDistance(xyPoint) { }
    onDragStarted(args) {
        var _a;
        (_a = this.dragStarted) === null || _a === void 0 ? void 0 : _a.raiseEvent();
        return false;
    }
    checkIsClickedOnAnnotation(xyPoint, x1, x2, y1, y2) {
        return false;
    }
    onDragAdorner(args) {
        const xyValues = this.getXYValuesFromCoordinates(args.mousePoint, true);
        if (xyValues) {
            this.сalcDragDistance(xyValues);
        }
        this.dragDelta.raiseEvent(new AnnotationDragDeltaEventArgs_1.AnnotationDragDeltaEventArgs());
    }
    onDragEnded() {
        var _a;
        (_a = this.dragEnded) === null || _a === void 0 ? void 0 : _a.raiseEvent();
        this.adornerDraggingPoint = undefined;
        this.prevValue = undefined;
    }
    /**
     * @summary Notifies subscribers of {@link AnnotationBase.propertyChanged} that a property has changed and the chart requires redrawing
     * @description SciChart provides fully reactive components, changing any property or changing data will cause the {@link AnnotationBase} to
     * redraw where necessary. This method notifies subscribers of the {@link AnnotationBase.propertyChanged} {@link EventHandler}
     * that a property has changed.
     * @param propertyName The name of the property which has changed
     */
    notifyPropertyChanged(propertyName) {
        if (this.invalidateParentCallback) {
            this.invalidateParentCallback();
        }
    }
    /**
     * Converts a value (e.g. from {@link x1}, {@link x2}, {@link y1} or {@link y2}) into a pixel coordinate
     * @param value - the value to convert
     * @param calculator the {@link CoordinateCalculatorBase} which will do the transformation
     * @param coordinateMode the {@link ECoordinateMode} to apply
     * @returns the pixel coordinate
     */
    getCoordinate(value, calculator, coordinateMode) {
        Guard_1.Guard.notNull(coordinateMode, "coordinateMode");
        Guard_1.Guard.notNull(calculator, "calculator");
        switch (coordinateMode) {
            case ECoordinateMode.Pixel: {
                // Value is 20.0 means pixel = 20.0
                return value;
            }
            case ECoordinateMode.DataValue: {
                // Value is 20.0 must be converted from data-value to coordinate using Axis api
                return calculator.getCoordinate(value);
            }
            case ECoordinateMode.Relative: {
                // Value is 0.5 means 50% of the viewport size
                return value * calculator.viewportDimension;
            }
            default: {
                throw new Error(`AnnotationBase.getCoordinate with CoordinateMode.${coordinateMode} is not implemented`);
            }
        }
    }
    /**
     * Returns the pixel X1 coordinate
     * @param xCalc the X {@link CoordinateCalculatorBase} which will do the transformation
     * @param yCalc the Y {@link CoordinateCalculatorBase} which will do the transformation
     * @returns the pixel X1 coordinate
     */
    getX1Coordinate(xCalc, yCalc) {
        var _a, _b, _c;
        if (this.xCoordinateMode === ECoordinateMode.Pixel) {
            return (_a = this.x1) !== null && _a !== void 0 ? _a : 0;
        }
        return this.isVerticalChart
            ? this.getCoordinate((_b = this.y1) !== null && _b !== void 0 ? _b : 0, yCalc, this.yCoordinateMode)
            : this.getCoordinate((_c = this.x1) !== null && _c !== void 0 ? _c : 0, xCalc, this.xCoordinateMode);
    }
    /**
     * Returns the pixel X2 coordinate
     * @param xCalc the X {@link CoordinateCalculatorBase} which will do the transformation
     * @param yCalc the Y {@link CoordinateCalculatorBase} which will do the transformation
     * @returns the pixel X2 coordinate
     */
    getX2Coordinate(xCalc, yCalc) {
        var _a, _b, _c;
        if (this.xCoordinateMode === ECoordinateMode.Pixel) {
            return (_a = this.x2) !== null && _a !== void 0 ? _a : 0;
        }
        return this.isVerticalChart
            ? this.getCoordinate((_b = this.y2) !== null && _b !== void 0 ? _b : 0, yCalc, this.yCoordinateMode)
            : this.getCoordinate((_c = this.x2) !== null && _c !== void 0 ? _c : 0, xCalc, this.xCoordinateMode);
    }
    /**
     * Returns the pixel Y1 coordinate
     * @param xCalc the X {@link CoordinateCalculatorBase} which will do the transformation
     * @param yCalc the Y {@link CoordinateCalculatorBase} which will do the transformation
     * @returns the pixel Y1 coordinate
     */
    getY1Coordinate(xCalc, yCalc) {
        var _a, _b, _c;
        if (this.yCoordinateMode === ECoordinateMode.Pixel) {
            return (_a = this.y1) !== null && _a !== void 0 ? _a : 0;
        }
        return this.isVerticalChart
            ? this.getCoordinate((_b = this.x1) !== null && _b !== void 0 ? _b : 0, xCalc, this.xCoordinateMode)
            : this.getCoordinate((_c = this.y1) !== null && _c !== void 0 ? _c : 0, yCalc, this.yCoordinateMode);
    }
    /**
     * Returns the pixel Y2 coordinate
     * @param xCalc the X {@link CoordinateCalculatorBase} which will do the transformation
     * @param yCalc the Y {@link CoordinateCalculatorBase} which will do the transformation
     * @returns the pixel Y2 coordinate
     */
    getY2Coordinate(xCalc, yCalc) {
        var _a, _b, _c;
        if (this.yCoordinateMode === ECoordinateMode.Pixel) {
            return (_a = this.y2) !== null && _a !== void 0 ? _a : 0;
        }
        return this.isVerticalChart
            ? this.getCoordinate((_b = this.x2) !== null && _b !== void 0 ? _b : 0, xCalc, this.xCoordinateMode)
            : this.getCoordinate((_c = this.y2) !== null && _c !== void 0 ? _c : 0, yCalc, this.yCoordinateMode);
    }
    /**
     * Converts a pixel coordinate back to a value
     * @param value - coordinate or dataValue to convert
     * @param calculator the {@link CoordinateCalculatorBase} which will do the transformation
     * @param coordinateMode the {@link ECoordinateMode} to apply
     * @returns the data-value or value
     */
    getValue(value, calculator, coordinateMode) {
        switch (coordinateMode) {
            case ECoordinateMode.Pixel: {
                return calculator.getDataValue(value);
            }
            case ECoordinateMode.DataValue: {
                return value;
            }
            // Case relative: 0.0 = left and 1.0 = right % on the viewport
            case ECoordinateMode.Relative: {
                return (calculator.visibleMax - calculator.visibleMin) * value + calculator.visibleMin;
            }
            default: {
                throw new Error("Not implemented");
            }
        }
    }
    deleteAdorner() {
        if (!this.parentSurface || this.parentSurface.isDeleted)
            return;
        this.svgAdornerRoot.removeChild(this.svgAdorner);
        this.svgAdorner = undefined;
    }
    getXYValuesFromCoordinates(point, translateToSeriesViewRect) {
        const xAxis = this.parentSurface.getXAxisById(this.xAxisId);
        const xCoordCalc = xAxis.getCurrentCoordinateCalculator();
        const yAxis = this.parentSurface.getYAxisById(this.yAxisId);
        const yCoordCalc = yAxis.getCurrentCoordinateCalculator();
        const viewRect = this.parentSurface.seriesViewRect;
        const translatedPoint = !translateToSeriesViewRect
            ? point
            : translate_1.translateFromCanvasToSeriesViewRect(point, viewRect);
        if (!translatedPoint) {
            return undefined;
        }
        const xValue = xCoordCalc.nativeCalculator.GetDataValue(xAxis.isVerticalChart ? translatedPoint.y : translatedPoint.x);
        const yValue = yCoordCalc.nativeCalculator.GetDataValue(xAxis.isVerticalChart ? translatedPoint.x : translatedPoint.y);
        return new Point_1.Point(xValue, yValue);
    }
    getXYCoordinatesFromValues(xyDataPoint) {
        let xCoord = 0;
        let yCoord = 0;
        const xAxis = this.parentSurface.getXAxisById(this.xAxisId);
        const xCoordCalc = xAxis.getCurrentCoordinateCalculator();
        const yAxis = this.parentSurface.getYAxisById(this.yAxisId);
        const yCoordCalc = yAxis.getCurrentCoordinateCalculator();
        const viewRect = this.parentSurface.seriesViewRect;
        if (xyDataPoint.x) {
            xCoord = xCoordCalc.nativeCalculator.GetCoordinate(xyDataPoint.x);
        }
        if (xyDataPoint.y) {
            yCoord = yCoordCalc.nativeCalculator.GetCoordinate(xyDataPoint.y);
        }
        const translatedPoint = translate_1.translateFromSeriesViewRectToCanvas(new Point_1.Point(xAxis.isVerticalChart ? yCoord : xCoord, xAxis.isVerticalChart ? xCoord : yCoord), viewRect);
        if (!translatedPoint) {
            return undefined;
        }
        return new Point_1.Point(translatedPoint.x, translatedPoint.y);
    }
}
exports.AnnotationBase = AnnotationBase;
exports.calcNewApex = (x1, y1, x2, y2) => {
    const point1 = { x: x1, y: y2 };
    const point2 = { x: x2, y: y2 };
    const point3 = { x: x2, y: y1 };
    const point4 = { x: x1, y: y1 };
    return { point1, point2, point3, point4 };
};
