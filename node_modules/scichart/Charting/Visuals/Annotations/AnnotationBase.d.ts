import { EventHandler } from "../../../Core/EventHandler";
import { Point } from "../../../Core/Point";
import { EXyDirection } from "../../../types/XyDirection";
import { ModifierMouseArgs } from "../../ChartModifiers/ModifierMouseArgs";
import { CoordinateCalculatorBase } from "../../Numerics/CoordinateCalculators/CoordinateCalculatorBase";
import { SciChartSurface } from "../SciChartSurface";
import { SciChartSurfaceBase } from "../SciChartSurfaceBase";
import { AnnotationDragDeltaEventArgs } from "./AnnotationDragDeltaEventArgs";
import { IAdornerProvider } from "./IAdornerProvider";
import { EAnnotationLayer, EAnnotationType, IAnnotation } from "./IAnnotation";
export declare enum EDraggingGripPoint {
    Point1 = "Point1",
    Point2 = "Point2",
    Point3 = "Point3",
    Point4 = "Point4",
    Body = "Body"
}
/**
 * Options passed to the constructor of an {@link AnnotationBase}, used to configure it at instantiation time
 */
export interface IAnnotationBaseOptions {
    /**
     * @description The layer to place the annotation on. See {@link EAnnotationLayer} for a list of values
     * @remarks applicable only to WebGL annotations
     */
    annotationLayer?: EAnnotationLayer;
    /**
     * @description if true, the annotation is hidden
     */
    isHidden?: boolean;
    /**
     * @description set annotaion resize direction
     */
    resizeDirections?: EXyDirection;
    /**
     * @description if true, the annotation is editable (can be dragged and manipulated by the user)
     */
    isEditable?: boolean;
    /**
     * @description the X1 coordinate of the annotation
     * @remarks The X1 coordinate obeys {@link xCoordinateMode} which defines whether the X1 coordinate is a pixel, data-value or relative coordinate
     */
    x1?: number;
    /**
     * @description the X2 coordinate of the annotation
     * @remarks The X1 coordinate obeys {@link xCoordinateMode} which defines whether the X2 coordinate is a pixel, data-value or relative coordinate
     */
    x2?: number;
    /**
     * @description the Y1 coordinate of the annotation
     * @remarks The Y1 coordinate obeys {@link xCoordinateMode} which defines whether the Y1 coordinate is a pixel, data-value or relative coordinate
     */
    y1?: number;
    /**
     * @description the Y2 coordinate of the annotation
     * @remarks The Y2 coordinate obeys {@link xCoordinateMode} which defines whether the Y2 coordinate is a pixel, data-value or relative coordinate
     */
    y2?: number;
    /**
     * @summary The current XAxis Id that this {@link IAnnotation} is bound to
     * @description By default all Annotations will draw on the first X,Y axis pair in SciChart.
     * If you want this to change, you must add a second axis to your {@link SciChartSurface} and link the {@link IAnnotation} by Axis Id.
     *
     * For example:
     * ```ts
     * const sciChartSurface: SciChartSurface;
     * const primaryXAxis = new NumericAxis(wasmContext); // Has Id = AxisCore.DEFAULT_AXIS_ID
     * const primaryYAxis = new NumericAxis(wasmContext); // Has Id = AxisCore.DEFAULT_AXIS_ID
     *
     * const secondaryXAxis = new NumericAxis(wasmContext); // For subsequent X,Y axis set an Id
     * secondaryXAxis.id = "SecondaryXAxis";
     * const secondaryYAxis = new NumericAxis(wasmContext);
     * secondaryYAxis.id = "SecondaryYAxis";
     *
     * // Add all Axis to the chart
     * sciChartSurface.xAxes.add(primaryXAxis);
     * sciChartSurface.yAxes.add(primaryYAxis);
     * sciChartSurface.xAxes.add(secondaryXAxis);
     * sciChartSurface.yAxes.add(secondaryYAxis);
     *
     * // Add an Annotation on the default axis
     * const annotation = new LineAnnotation(wasmContext); // xAxisId, yAxisId Defaults to AxisCore.DEFAULT_AXIS_ID
     * sciChartSurface.renderableSeries.add(annotation);
     *
     * // Add an Annotation on the specific axis
     * const annotation2 = new LineAnnotation(wasmContext);
     * annotation2.xAxisId = "SecondaryXAxis";
     * annotation2.yAxisId = "SecondaryYAxis";
     * sciChartSurface.renderableSeries.add(annotation2);
     * ```
     * @remarks The default value is set to {@link AxisCore.DEFAULT_AXIS_ID}.
     */
    xAxisId?: string;
    /**
     * The X-Coordinate mode. See {@link ECoordinateMode} for a list of values
     * @remarks Want to display an annotation stretching across the entire width (or height) or the {@link SciChartSurface}?
     * The {@link ECoordinateMode} enum has options which allow for relative, absolute or pixel coordinates which define annotation
     * placement.
     */
    xCoordinateMode?: ECoordinateMode;
    /**
     * @summary The current YAxis Id that this {@link IAnnotation} is bound to
     * @description By default all Annotations will draw on the first X,Y axis pair in SciChart.
     * If you want this to change, you must add a second axis to your {@link SciChartSurface} and link the {@link IAnnotation} by Axis Id.
     *
     * For example:
     * ```ts
     * const sciChartSurface: SciChartSurface;
     * const primaryXAxis = new NumericAxis(wasmContext); // Has Id = AxisCore.DEFAULT_AXIS_ID
     * const primaryYAxis = new NumericAxis(wasmContext); // Has Id = AxisCore.DEFAULT_AXIS_ID
     *
     * const secondaryXAxis = new NumericAxis(wasmContext); // For subsequent X,Y axis set an Id
     * secondaryXAxis.id = "SecondaryXAxis";
     * const secondaryYAxis = new NumericAxis(wasmContext);
     * secondaryYAxis.id = "SecondaryYAxis";
     *
     * // Add all Axis to the chart
     * sciChartSurface.xAxes.add(primaryXAxis);
     * sciChartSurface.yAxes.add(primaryYAxis);
     * sciChartSurface.xAxes.add(secondaryXAxis);
     * sciChartSurface.yAxes.add(secondaryYAxis);
     *
     * // Add an Annotation on the default axis
     * const annotation = new LineAnnotation(wasmContext); // xAxisId, yAxisId Defaults to AxisCore.DEFAULT_AXIS_ID
     * sciChartSurface.renderableSeries.add(annotation);
     *
     * // Add an Annotation on the specific axis
     * const annotation2 = new LineAnnotation(wasmContext);
     * annotation2.xAxisId = "SecondaryXAxis";
     * annotation2.yAxisId = "SecondaryYAxis";
     * sciChartSurface.renderableSeries.add(annotation2);
     * ```
     * @remarks The default value is set to {@link AxisCore.DEFAULT_AXIS_ID}.
     */
    yAxisId?: string;
    /**
     * The Y-Coordinate mode. See {@link ECoordinateMode} for a list of values
     * @remarks Want to display an annotation stretching across the entire width (or height) or the {@link SciChartSurface}?
     * The {@link ECoordinateMode} enum has options which allow for relative, absolute or pixel coordinates which define annotation
     * placement.
     */
    yCoordinateMode?: ECoordinateMode;
    /**
     * When true, the annotation is in the selected state
     */
    isSelected?: boolean;
    /**
     * Sets an opacity override for the entire annotation, from 0..1
     */
    opacity?: number;
    /**
     * Callback function called when drag has started. Only applicable if {@link isEditable} is true
     */
    onDragStarted?: () => void;
    /**
     * Callback function called when drag has ended. Only applicable if {@link isEditable} is true
     */
    onDragEnded?: () => void;
    /**
     * Callback function called when drag operation is in progress. Only applicable if {@link isEditable} is true
     */
    onDrag?: (args: AnnotationDragDeltaEventArgs) => void;
}
/**
 * Defines the CoordinateMode for {@link AnnotationBase | Annotations} within SciChart's
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 */
export declare enum ECoordinateMode {
    /**
     * The {@link AnnotationBase.x1 | Annotation.x1}, {@link AnnotationBase.x2 | x2},
     * {@link AnnotationBase.y1 | y1}, {@link AnnotationBase.y2 | y2} coordinate is a data-value,
     * corresponding to the value on the {@link AxisBase2D | Axis} or in the
     * {@link IRenderableSeries.dataSeries | DataSeries}
     */
    DataValue = 0,
    /**
     * The {@link AnnotationBase.x1 | Annotation.x1}, {@link AnnotationBase.x2 | x2},
     * {@link AnnotationBase.y1 | y1}, {@link AnnotationBase.y2 | y2} coordinate is a pixel coordinate,
     * corresponding to the distance from the top-left of the
     * {@link SciChartSurface}
     */
    Pixel = 1,
    /**
     * The {@link AnnotationBase.x1 | Annotation.x1}, {@link AnnotationBase.x2 | x2},
     * {@link AnnotationBase.y1 | y1}, {@link AnnotationBase.y2 | y2} coordinate is relative,
     * where 0.0 corresponds to the left (or top) of the {@link SciChartSurface}
     * and 1.0 corresponds to the right (or bottom) of the {@link SciChartSurface}
     */
    Relative = 2
}
/**
 * Defines the base class to an Annotation - a type of marker, text label, line or custom UI overlay on a 2D Cartesian {@link SciChartSurface}
 */
export declare abstract class AnnotationBase implements IAnnotation, IAdornerProvider {
    dragStarted: EventHandler<void>;
    dragEnded: EventHandler<void>;
    dragDelta: EventHandler<AnnotationDragDeltaEventArgs>;
    private opacityProperty;
    /** @inheritDoc */
    get annotationLayer(): EAnnotationLayer;
    /** @inheritDoc */
    set annotationLayer(annotationCanvas: EAnnotationLayer);
    /** @inheritDoc */
    get parentSurface(): SciChartSurface;
    /** @inheritDoc */
    set parentSurface(parentSurface: SciChartSurface);
    /** @inheritDoc */
    get isEditable(): boolean;
    /** @inheritDoc */
    set isEditable(isEditable: boolean);
    /** @inheritDoc */
    get isHidden(): boolean;
    /** @inheritDoc */
    set isHidden(isHidden: boolean);
    /** @inheritDoc */
    get xCoordinateMode(): ECoordinateMode;
    /** @inheritDoc */
    set xCoordinateMode(xCoordinateMode: ECoordinateMode);
    /** @inheritDoc */
    get yCoordinateMode(): ECoordinateMode;
    /** @inheritDoc */
    set yCoordinateMode(yCoordinateMode: ECoordinateMode);
    /** @inheritDoc */
    get x1(): number;
    /** @inheritDoc */
    set x1(x1: number);
    /** @inheritDoc */
    get x2(): number;
    /** @inheritDoc */
    set x2(x2: number);
    /** @inheritDoc */
    get y1(): number;
    /** @inheritDoc */
    set y1(y1: number);
    /** @inheritDoc */
    get y2(): number;
    /** @inheritDoc */
    set y2(y2: number);
    /** @inheritDoc */
    get xAxisId(): string;
    /** @inheritDoc */
    set xAxisId(xAxisId: string);
    /** @inheritDoc */
    get yAxisId(): string;
    /** @inheritDoc */
    set yAxisId(yAxisId: string);
    /** @inheritDoc */
    get isVerticalChart(): boolean;
    /** @inheritDoc */
    set resizeDirections(value: EXyDirection);
    /** @inheritDoc */
    get resizeDirections(): EXyDirection;
    /** @inheritDoc */
    set isSelected(value: boolean);
    /** @inheritDoc */
    get isSelected(): boolean;
    /** @inheritDoc */
    get opacity(): number;
    /** @inheritDoc */
    set opacity(opacity: number);
    get isDraggingStarted(): boolean;
    /** @inheritDoc */
    abstract readonly type: EAnnotationType;
    /** @inheritDoc */
    invalidateParentCallback: () => void;
    adornerDraggingPoint: EDraggingGripPoint;
    protected get svgAdornerRoot(): SVGSVGElement;
    protected svgAdorner: SVGElement;
    protected prevIsSelected: boolean;
    protected annontationBorders: {
        x1: number;
        x2: number;
        y1: number;
        y2: number;
    };
    protected prevValue: {
        x: number;
        y: number;
    };
    private annotationLayerProperty;
    private isEditableProperty;
    private isHiddenProperty;
    private parentSurfaceProperty;
    private x1Property;
    private x2Property;
    private y1Property;
    private y2Property;
    private xAxisIdProperty;
    private yAxisIdProperty;
    private xCoordinateModeProperty;
    private yCoordinateModeProperty;
    private isSelectedProperty;
    private resizeDirectionsProperty;
    private svgAdornerRootProperty;
    /**
     * Creates an instance of the Annotation
     * @param options optional parameters of type {@link IAnnotationBaseOptions} used to configure the annotation at construct time
     */
    protected constructor(options?: IAnnotationBaseOptions);
    /** @inheritDoc */
    onAttach(scs: SciChartSurfaceBase): void;
    /** @inheritDoc */
    onDetach(): void;
    /** @inheritDoc */
    abstract delete(): void;
    updateAdorner(): void;
    isPointWithinBounds(args: ModifierMouseArgs): boolean;
    сalcDragDistance(xyPoint: Point): void;
    onDragStarted(args: ModifierMouseArgs): boolean;
    checkIsClickedOnAnnotation(xyPoint: Point, x1: number, x2: number, y1: number, y2: number): boolean;
    onDragAdorner(args: ModifierMouseArgs): void;
    onDragEnded(): void;
    /**
     * @summary Notifies subscribers of {@link AnnotationBase.propertyChanged} that a property has changed and the chart requires redrawing
     * @description SciChart provides fully reactive components, changing any property or changing data will cause the {@link AnnotationBase} to
     * redraw where necessary. This method notifies subscribers of the {@link AnnotationBase.propertyChanged} {@link EventHandler}
     * that a property has changed.
     * @param propertyName The name of the property which has changed
     */
    protected notifyPropertyChanged(propertyName: string): void;
    /**
     * Converts a value (e.g. from {@link x1}, {@link x2}, {@link y1} or {@link y2}) into a pixel coordinate
     * @param value - the value to convert
     * @param calculator the {@link CoordinateCalculatorBase} which will do the transformation
     * @param coordinateMode the {@link ECoordinateMode} to apply
     * @returns the pixel coordinate
     */
    protected getCoordinate(value: number, calculator: CoordinateCalculatorBase, coordinateMode: ECoordinateMode): number;
    /**
     * Returns the pixel X1 coordinate
     * @param xCalc the X {@link CoordinateCalculatorBase} which will do the transformation
     * @param yCalc the Y {@link CoordinateCalculatorBase} which will do the transformation
     * @returns the pixel X1 coordinate
     */
    protected getX1Coordinate(xCalc: CoordinateCalculatorBase, yCalc: CoordinateCalculatorBase): number;
    /**
     * Returns the pixel X2 coordinate
     * @param xCalc the X {@link CoordinateCalculatorBase} which will do the transformation
     * @param yCalc the Y {@link CoordinateCalculatorBase} which will do the transformation
     * @returns the pixel X2 coordinate
     */
    protected getX2Coordinate(xCalc: CoordinateCalculatorBase, yCalc: CoordinateCalculatorBase): number;
    /**
     * Returns the pixel Y1 coordinate
     * @param xCalc the X {@link CoordinateCalculatorBase} which will do the transformation
     * @param yCalc the Y {@link CoordinateCalculatorBase} which will do the transformation
     * @returns the pixel Y1 coordinate
     */
    protected getY1Coordinate(xCalc: CoordinateCalculatorBase, yCalc: CoordinateCalculatorBase): number;
    /**
     * Returns the pixel Y2 coordinate
     * @param xCalc the X {@link CoordinateCalculatorBase} which will do the transformation
     * @param yCalc the Y {@link CoordinateCalculatorBase} which will do the transformation
     * @returns the pixel Y2 coordinate
     */
    protected getY2Coordinate(xCalc: CoordinateCalculatorBase, yCalc: CoordinateCalculatorBase): number;
    /**
     * Converts a pixel coordinate back to a value
     * @param value - coordinate or dataValue to convert
     * @param calculator the {@link CoordinateCalculatorBase} which will do the transformation
     * @param coordinateMode the {@link ECoordinateMode} to apply
     * @returns the data-value or value
     */
    protected getValue(value: number, calculator: CoordinateCalculatorBase, coordinateMode: ECoordinateMode): number;
    protected deleteAdorner(): void;
    protected getXYValuesFromCoordinates(point: Point, translateToSeriesViewRect: boolean): Point;
    protected getXYCoordinatesFromValues(xyDataPoint: Point): Point;
}
export declare const calcNewApex: (x1: number, y1: number, x2: number, y2: number) => {
    point1: {
        x: number;
        y: number;
    };
    point2: {
        x: number;
        y: number;
    };
    point3: {
        x: number;
        y: number;
    };
    point4: {
        x: number;
        y: number;
    };
};
