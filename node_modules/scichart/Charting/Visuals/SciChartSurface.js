"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SciChartSurface = void 0;
// @ts-ignore
const WasmModule2D = require("../../_wasm/scichart2d");
// @ts-ignore
const app_1 = require("../../constants/app");
const EasingFunctions_1 = require("../../Core/Animations/EasingFunctions");
const Dictionary_1 = require("../../Core/Dictionary");
const EventHandler_1 = require("../../Core/EventHandler");
const ObservableArray_1 = require("../../Core/ObservableArray");
const Rect_1 = require("../../Core/Rect");
const Thickness_1 = require("../../Core/Thickness");
const Size_1 = require("../../types/Size");
const ZoomState_1 = require("../../types/ZoomState");
const logger_1 = require("../../utils/logger");
const parseColor_1 = require("../../utils/parseColor");
const RenderContext2D_1 = require("../Drawing/RenderContext2D");
const RenderSurface_1 = require("../Drawing/RenderSurface");
const SolidBrushCache_1 = require("../Drawing/SolidBrushCache");
const WebGlRenderContext2D_1 = require("../Drawing/WebGlRenderContext2D");
const LayoutManager_1 = require("../LayoutManager/LayoutManager");
const SciChartRenderer_1 = require("../Services/SciChartRenderer");
const defaultThemeColors_1 = require("../Themes/defaultThemeColors");
const AdornerLayer_1 = require("./Annotations/AdornerLayer");
const drawBorder_1 = require("./Helpers/drawBorder");
const licenseManager2D_1 = require("./licenseManager2D");
const loader_1 = require("./loader");
const sciChartInitCommon_1 = require("./sciChartInitCommon");
const SciChartSurfaceBase_1 = require("./SciChartSurfaceBase");
const sciChartConfig = {};
const locateFile = SciChartSurfaceBase_1.getLocateFile(sciChartConfig);
/** @ignore */
const sciChartMaster = {
    wasmContext: undefined,
    getChildSurfaces: undefined,
    createChildSurface: undefined
};
/** @ignore */
let sciChartMasterPromise;
/** @ignore */
const MASTER_CANVAS_ID = "SciChartMasterCanvas";
/**
 * @summary The {@link SciChartSurface} is the root 2D Chart control in SciChart's High Performance Real-time
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Chart Library}
 * @description
 * To create a chart using SciChart, declare a {@link SciChartSurface} using {@link SciChartSurface.create},
 * add X and Y axes to the {@link SciChartSurface.xAxes} {@link SciChartSurface.yAxes} collection.
 *
 * Next, add a series or chart type by adding a {@link BaseRenderableSeries} to the {@link SciChartSurface.renderableSeries} collection.
 *
 * You can add annotations and markers using the {@link SciChartSurface.annotations} property, and you can add zoom and pan behaviours,
 * tooltips and more by using the {@link SciChartSurface.chartModifiers} property.
 *
 * To redraw a {@link SciChartSurface} at any time, call {@link SciChartSurface.invalidateElement}, however all properties are reactive and the
 * chart will automatically redraw if data or properties change.
 * @remarks
 * It is possible to have more than one {@link SciChartSurface} on screen at the same time.
 * {@link SciChartSurface | SciChartSurfaces} scale to fit the parent DIV where they are hosted. Use CSS to position the DIV.
 */
class SciChartSurface extends SciChartSurfaceBase_1.SciChartSurfaceBase {
    /**
     * Creates an instance of the {@link SciChartSurface}
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param options optional parameters of type {@link ISciChartSurfaceOptions} used to configure the {@link SciChartSurface}
     */
    constructor(webAssemblyContext, options) {
        var _a;
        super(webAssemblyContext, options === null || options === void 0 ? void 0 : options.canvases, MASTER_CANVAS_ID);
        /**
         * An event handler which notifies its subsribers when a render operation has finished. Use this
         * to time render performance, or to update elements of the chart or your UI on redraw.
         */
        this.rendered = new EventHandler_1.EventHandler();
        this.zoomStateProperty = ZoomState_1.EZoomState.AtExtents;
        this.paddingProperty = Thickness_1.Thickness.fromNumber(10);
        this.viewportBorderProperty = {
            borderBottom: undefined,
            borderLeft: undefined,
            borderRight: undefined,
            borderTop: undefined,
            color: "#00000000",
            border: undefined
        };
        this.canvasBorderProperty = {
            borderBottom: undefined,
            borderLeft: undefined,
            borderRight: undefined,
            borderTop: undefined,
            color: "#00000000",
            border: undefined
        };
        const viewportSize = (_a = options === null || options === void 0 ? void 0 : options.viewportSize) !== null && _a !== void 0 ? _a : new Size_1.Size(app_1.DEFAULT_WIDTH, app_1.DEFAULT_HEIGHT);
        this.webAssemblyContext2D = webAssemblyContext;
        if (!app_1.IS_TEST_ENV) {
            if (this.isCopyCanvasSurface) {
                this.changeMasterCanvasViewportSize(this.domCanvas2D.width, this.domCanvas2D.height);
                this.webAssemblyContext2D.TSRSetMainWindowSize(this.domMasterCanvas.width, this.domMasterCanvas.height);
            }
            else {
                this.webAssemblyContext2D.TSRSetMainWindowSize(this.domCanvas2D.width, this.domCanvas2D.height);
            }
        }
        this.invalidateElement = this.invalidateElement.bind(this);
        this.onRenderSurfaceDraw = this.onRenderSurfaceDraw.bind(this);
        this.renderSurface = new RenderSurface_1.RenderSurface(webAssemblyContext, viewportSize);
        this.renderSurface.handleDraw = this.onRenderSurfaceDraw;
        this.sciChartRenderer = new SciChartRenderer_1.SciChartRenderer(this);
        this.layoutManagerProperty = new LayoutManager_1.LayoutManager(this);
        // TODO: remove this
        if (this.domCanvas2D) {
            this.renderContext2D = new RenderContext2D_1.RenderContext2D(this.domCanvas2D);
        }
        // Setup series
        this.detachSeries = this.detachSeries.bind(this);
        this.attachSeries = this.attachSeries.bind(this);
        this.renderableSeries = new ObservableArray_1.ObservableArray();
        this.renderableSeries.collectionChanged.subscribe(args => {
            var _a, _b;
            (_a = args.getOldItems()) === null || _a === void 0 ? void 0 : _a.forEach(this.detachSeries);
            (_b = args.getNewItems()) === null || _b === void 0 ? void 0 : _b.forEach(this.attachSeries);
        });
        // Setup axis
        this.detachAxis = this.detachAxis.bind(this);
        this.attachAxis = this.attachAxis.bind(this);
        this.xAxes = new ObservableArray_1.ObservableArray();
        this.yAxes = new ObservableArray_1.ObservableArray();
        const handler = (args, isXAxis) => {
            var _a, _b;
            (_a = args.getOldItems()) === null || _a === void 0 ? void 0 : _a.forEach(a => this.detachAxis(a));
            (_b = args.getNewItems()) === null || _b === void 0 ? void 0 : _b.forEach(a => this.attachAxis(a, isXAxis));
        };
        this.xAxes.collectionChanged.subscribe(arg => handler(arg, true));
        this.yAxes.collectionChanged.subscribe(arg => handler(arg, false));
        // Setup annotations
        this.detachAnnotation = this.detachAnnotation.bind(this);
        this.attachAnnotation = this.attachAnnotation.bind(this);
        this.annotations = new ObservableArray_1.ObservableArray();
        this.modifierAnnotations = new ObservableArray_1.ObservableArray();
        this.annotations.collectionChanged.subscribe(arg => {
            var _a, _b;
            (_a = arg.getOldItems()) === null || _a === void 0 ? void 0 : _a.forEach(a => this.detachAnnotation(a));
            (_b = arg.getNewItems()) === null || _b === void 0 ? void 0 : _b.forEach(a => this.attachAnnotation(a));
        });
        this.modifierAnnotations.collectionChanged.subscribe(arg => {
            var _a, _b;
            (_a = arg.getOldItems()) === null || _a === void 0 ? void 0 : _a.forEach(a => this.detachAnnotation(a));
            (_b = arg.getNewItems()) === null || _b === void 0 ? void 0 : _b.forEach(a => this.attachAnnotation(a));
        });
        this.adornerLayer = new AdornerLayer_1.AdornerLayer(this);
        this.solidBrushCacheViewportBorder = new SolidBrushCache_1.SolidBrushCache(webAssemblyContext);
        this.solidBrushCacheCanvasBorder = new SolidBrushCache_1.SolidBrushCache(webAssemblyContext);
        // Watermark
        if (!app_1.IS_TEST_ENV) {
            this.watermarkProperties = new webAssemblyContext.SCRTWaterMarkProperties();
            this.watermarkPropertyPosition = new webAssemblyContext.TSRVector2(0, 0);
            this.watermarkProperties.SetPosition(this.watermarkPropertyPosition);
            this.watermarkProperties.SetOpacity(0.5);
            webAssemblyContext.SCRTSetWaterMarkProperties(this.watermarkProperties);
        }
        this.applySciChartBackground(defaultThemeColors_1.defaultThemeColors.sciChartBackground);
    }
    /**
     * @inheritDoc
     */
    get surfaceType() {
        return SciChartSurfaceBase_1.ESurfaceType.SciChartSurfaceType;
    }
    /**
     * Used internally - gets or sets the {@link LayoutManager}
     */
    get layoutManager() {
        return this.layoutManagerProperty;
    }
    /**
     * Creates a {@link SciChartSurface} and {@link TSciChart | WebAssembly Context} to occupy the div by element ID in your DOM.
     * @remarks This method is async and must be awaited
     * @param divElementId The Div Element ID where the {@link SciChartSurface} will reside
     * @param widthAspect Optional - the width aspect ratio of the {@link SciChartSurface}. By default SciChart will scale to fit the parent Div.
     * However if height of the div is not provided it will use width/height aspect ratio to calculate the height. The default ratio is 3/2.
     * @param heightAspect Optional - the height aspect ratio of the {@link SciChartSurface}. By default SciChart will scale to fit the parent Div.
     */
    static create(divElementId, widthAspect = 0, heightAspect = 0) {
        return createMultichart(divElementId, widthAspect, heightAspect);
    }
    /**
     * USED INTERNALLY - performs a similar operation to {@link SciChartSurface.create} but used internally for testing
     * @param divElementId
     * @param widthAspect
     * @param heightAspect
     */
    static createSingle(divElementId, widthAspect = 0, heightAspect = 0) {
        return new Promise(resolve => {
            const canvases = sciChartInitCommon_1.default.initCanvas(divElementId, widthAspect, heightAspect);
            loader_1.default.addLoaderStyles();
            const loaderDiv = loader_1.default.addChartLoader(canvases.domDivContainer);
            const webGLSupport = sciChartInitCommon_1.default.checkWebGLSupport();
            console.log("webGLSupport", webGLSupport);
            if (webGLSupport === sciChartInitCommon_1.default.EWebGLSupport.WebGL2 ||
                webGLSupport === sciChartInitCommon_1.default.EWebGLSupport.WebGL1) {
                // @ts-ignore
                new WasmModule2D({ locateFile }).then((wasmContext) => {
                    loader_1.default.removeChartLoader(canvases.domDivContainer, loaderDiv);
                    // @ts-ignore
                    wasmContext.doNotCaptureKeyboard = true;
                    initDrawEngineSingleChart(wasmContext, canvases, resolve);
                });
            }
            else {
                throw Error("Sorry Your browser does not support WebGL.");
            }
        });
    }
    static configure(config) {
        var _a, _b;
        sciChartConfig.dataUrl = (_a = config === null || config === void 0 ? void 0 : config.dataUrl) !== null && _a !== void 0 ? _a : undefined;
        sciChartConfig.wasmUrl = (_b = config === null || config === void 0 ? void 0 : config.wasmUrl) !== null && _b !== void 0 ? _b : undefined;
    }
    /**
     * Gets or sets the Padding between the SciChartSurface and it's inner elements, in order top, right, bottom, left
     * @remarks
     * Do not set padding.top and expect the chart to update, instead, treat the {@link Thickness} object as immutable and
     * set a new Thickness when you want to change the padding.
     */
    get padding() {
        return this.paddingProperty;
    }
    /**
     * Gets or sets the Padding between the SciChartSurface and it's inner elements, in order top, right, bottom, left
     * @remarks
     * Do not set padding.top and expect the chart to update, instead, treat the {@link Thickness} object as immutable and
     * set a new Thickness when you want to change the padding.
     */
    set padding(padding) {
        this.paddingProperty = padding;
        this.invalidateElement();
    }
    /**
     * Gets or sets a property whether rendering should be debugged. This will draw rectangles around key boxes and areas on the chart.
     * Used internally for development purposes
     */
    get debugRendering() {
        return this.debugRenderingProperty;
    }
    /**
     * Gets or sets a property whether rendering should be debugged. This will draw rectangles around key boxes and areas on the chart.
     * Used internally for development purposes
     */
    set debugRendering(debugRendering) {
        this.debugRenderingProperty = debugRendering;
        this.invalidateElement();
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        super.applyTheme(themeProvider);
        this.renderableSeries.asArray().forEach(rs => rs.applyTheme(themeProvider));
        this.xAxes.asArray().forEach(axis => axis.applyTheme(themeProvider));
        this.yAxes.asArray().forEach(axis => axis.applyTheme(themeProvider));
    }
    /**
     * @inheritDoc
     */
    changeViewportSize(width, height) {
        this.changeDomViewportSize(width, height);
        this.renderSurface.viewportSize = new Size_1.Size(width, height);
        if (!this.isCopyCanvasSurface) {
            this.webAssemblyContext2D.TSRSetMainWindowSize(width, height);
        }
        else {
            this.webAssemblyContext2D.TSRSetMainWindowSize(this.domMasterCanvas.width, this.domMasterCanvas.height);
        }
        this.invalidateElement();
    }
    /**
     * @inheritDoc
     */
    invalidateElement() {
        // When isSuspended (see suspendUpdates() function) ignore drawing
        if (this.isSuspended) {
            // Logger.log("SciChartSurface.isSuspended = true. Ignoring invalidateElement() call");
            return;
        }
        const canvasId = this.domCanvas2D ? this.domCanvas2D.id : "undefinedCanvasId";
        this.renderSurface.invalidateElement(canvasId);
    }
    // Step_5: Get context and pass drawing to SciChartRenderer
    doDrawingLoop() {
        const context = this.renderSurface.getRenderContext();
        this.sciChartRenderer.render(context);
    }
    /**
     * @inheritDoc
     */
    delete() {
        super.delete();
        this.renderableSeries.asArray().forEach(rs => rs.delete());
        this.renderableSeries.clear();
        this.xAxes.asArray().forEach(xAxis => xAxis.delete());
        this.yAxes.asArray().forEach(yAxis => yAxis.delete());
        this.annotations.asArray().forEach(annotation => annotation.delete());
        this.modifierAnnotations.asArray().forEach(modifierAnnotation => modifierAnnotation.delete());
    }
    /**
     * Gets the {@link AxisBase2D | XAxis} which matches the axisId. Returns undefined if not axis found
     * @param axisId The AxisId to search for
     */
    getXAxisById(axisId) {
        return this.xAxes.asArray().find(x => x.id === axisId);
    }
    /**
     * Gets the {@link AxisBase2D | YAxis} which matches the axisId. Returns undefined if not axis found
     * @param axisId The AxisId to search for
     */
    getYAxisById(axisId) {
        return this.yAxes.asArray().find(y => y.id === axisId);
    }
    /**
     * @summary Zooms the {@link SciChartSurface} in the X and Y direction to extents of all data (zoom to fit)
     * @description
     * @param animationDurationMs An optional animation duration. Default value is 0, which means 'no animation'
     * @param easingFunction An optional easing function for animations. See {@link TEasing} for a list of values
     * @param onCompleted the callback function
     */
    zoomExtents(animationDurationMs = 0, easingFunction = EasingFunctions_1.easing.outExpo, onCompleted = () => { }) {
        // Update accumulated vectors for stacked series
        const stackedSeries = this.renderableSeries.asArray().filter(el => el.isStacked);
        stackedSeries.forEach(el => el.updateAccumulatedVectors());
        const xSize = this.xAxes === undefined ? 0 : this.xAxes.size();
        const ySize = this.yAxes === undefined ? 0 : this.yAxes.size();
        if (xSize === 0 || ySize === 0) {
            throw new Error("Cannot ZoomExtents when XAxes or YAxes is undefined or empty");
        }
        // Update the VisibleRange of X Axes
        const xRanges = this.zoomExtentsXInternal(animationDurationMs, easingFunction, onCompleted);
        // Now ZoomExtents on Y for N Y-axes
        this.zoomExtentsYInternal(xRanges, animationDurationMs, easingFunction, onCompleted);
    }
    /**
     * @summary Zooms the {@link SciChartSurface} in the X direction to extents of all data (zoom to fit)
     * @description
     * @param animationDurationMs An optional animation duration. Default value is 0, which means 'no animation'
     * @param easingFunction An optional easing function for animations. See {@link TEasing} for a list of values
     */
    zoomExtentsX(animationDurationMs = 0, easingFunction = EasingFunctions_1.easing.outExpo) {
        this.zoomExtentsXInternal(animationDurationMs, easingFunction);
    }
    /**
     * @summary Zooms the {@link SciChartSurface} in the Y direction to extents of all data (zoom to fit)
     * @description
     * @param animationDurationMs An optional animation duration. Default value is 0, which means 'no animation'
     * @param easingFunction An optional easing function for animations. See {@link TEasing} for a list of values
     */
    zoomExtentsY(animationDurationMs = 0, easingFunction = EasingFunctions_1.easing.outExpo) {
        this.zoomExtentsYInternal(undefined, animationDurationMs, easingFunction);
    }
    /**
     * Used internally - gets or sets the {@link LayoutManager}
     */
    setLayoutManager(layoutManager) {
        this.layoutManagerProperty = layoutManager;
    }
    /**
     * @inheritDoc
     */
    updateWatermark(left, bottom) {
        if (!app_1.IS_TEST_ENV) {
            this.watermarkPropertyPosition.x = left;
            this.watermarkPropertyPosition.y = bottom;
            this.watermarkProperties.SetPosition(this.watermarkPropertyPosition);
            this.webAssemblyContext2D.SCRTSetWaterMarkProperties(this.watermarkProperties);
        }
    }
    /**
     * Sets zoomStateProperty
     * @param zoomState
     */
    setZoomState(zoomState) {
        this.zoomStateProperty = zoomState;
    }
    /**
     * Gets zoomStateProperty
     */
    get zoomState() {
        return this.zoomStateProperty;
    }
    /**
     * Gets or sets the SciChartSurface Viewport Border properties
     */
    get viewportBorder() {
        return this.viewportBorderProperty;
    }
    /**
     * Gets or sets the SciChartSurface Viewport Border properties
     */
    set viewportBorder(value) {
        this.viewportBorderProperty = Object.assign(Object.assign({}, this.viewportBorderProperty), value);
        this.notifyPropertyChanged("ViewportBorder");
    }
    /**
     * Gets or sets the SciChartSurface Canvas Border properties
     */
    get canvasBorder() {
        return this.canvasBorderProperty;
    }
    /**
     * Gets or sets the SciChartSurface Canvas Border properties
     */
    set canvasBorder(value) {
        this.canvasBorderProperty = Object.assign(Object.assign({}, this.canvasBorderProperty), value);
        this.notifyPropertyChanged("Border");
    }
    /**
     * Used internally - draws SciChartSurface borders
     */
    drawBorder(renderContext) {
        // Draw Viewport Border
        drawBorder_1.drawBorder(renderContext, this.webAssemblyContext2D, this.solidBrushCacheViewportBorder, this.seriesViewRect, this.leftViewportBorder, this.topViewportBorder, this.rightViewportBorder, this.bottomViewportBorder, this.viewportBorder.color);
        // Draw Canvas Border
        const canvasSize = renderContext.viewportSize;
        const canvasBorderRect = Rect_1.Rect.create(this.leftCanvasBorder, this.topCanvasBorder, canvasSize.width - this.leftCanvasBorder - this.rightCanvasBorder, canvasSize.height - this.topCanvasBorder - this.bottomCanvasBorder);
        drawBorder_1.drawBorder(renderContext, this.webAssemblyContext2D, this.solidBrushCacheCanvasBorder, canvasBorderRect, this.leftCanvasBorder, this.topCanvasBorder, this.rightCanvasBorder, this.bottomCanvasBorder, this.canvasBorder.color);
    }
    /**
     * Gets the SciChartSurface Viewport Left Border
     */
    get leftViewportBorder() {
        var _a, _b;
        return (_b = (_a = this.viewportBorder.borderLeft) !== null && _a !== void 0 ? _a : this.viewportBorder.border) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Gets the SciChartSurface Viewport Right Border
     */
    get rightViewportBorder() {
        var _a, _b;
        return (_b = (_a = this.viewportBorder.borderRight) !== null && _a !== void 0 ? _a : this.viewportBorder.border) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Gets the SciChartSurface Viewport Top Border
     */
    get topViewportBorder() {
        var _a, _b;
        return (_b = (_a = this.viewportBorder.borderTop) !== null && _a !== void 0 ? _a : this.viewportBorder.border) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Gets the SciChartSurface Viewport Bottom Border
     */
    get bottomViewportBorder() {
        var _a, _b;
        return (_b = (_a = this.viewportBorder.borderBottom) !== null && _a !== void 0 ? _a : this.viewportBorder.border) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Gets the SciChartSurface Canvas Left Border
     */
    get leftCanvasBorder() {
        var _a, _b;
        return (_b = (_a = this.canvasBorder.borderLeft) !== null && _a !== void 0 ? _a : this.canvasBorder.border) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Gets the SciChartSurface Canvas Right Border
     */
    get rightCanvasBorder() {
        var _a, _b;
        return (_b = (_a = this.canvasBorder.borderRight) !== null && _a !== void 0 ? _a : this.canvasBorder.border) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Gets the SciChartSurface Canvas Top Border
     */
    get topCanvasBorder() {
        var _a, _b;
        return (_b = (_a = this.canvasBorder.borderTop) !== null && _a !== void 0 ? _a : this.canvasBorder.border) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Gets the SciChartSurface Canvas Bottom Border
     */
    get bottomCanvasBorder() {
        var _a, _b;
        return (_b = (_a = this.canvasBorder.borderBottom) !== null && _a !== void 0 ? _a : this.canvasBorder.border) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * @inheritDoc
     */
    detachChartModifier(chartModifier) {
        super.detachChartModifier(chartModifier);
    }
    /**
     * @inheritDoc
     */
    attachChartModifier(chartModifier) {
        super.attachChartModifier(chartModifier);
        chartModifier.setParentSurface(this);
        chartModifier.invalidateParentCallback = this.invalidateElement;
        chartModifier.onAttach();
        this.invalidateElement();
    }
    /**
     * @inheritDoc
     */
    applySciChartBackground(htmlColor, alphaEnabled = true) {
        this.backgroundProperty = htmlColor;
        const renderContext = this.webAssemblyContext2D.SCRTGetMainRenderContext2D();
        if (renderContext) {
            const c = parseColor_1.parseColorToTArgb(htmlColor ? htmlColor : "rgba(28,28,30,1)");
            const f = 1 / 255;
            renderContext.SetClearColor(c.red * f, c.green * f, c.blue * f, c.opacity * f);
            renderContext.Clear();
            this.setClearAlphaParams(alphaEnabled, c.opacity * f);
        }
    }
    /**
     * @inheritDoc
     */
    setClearAlphaParams(enabled, alpha) {
        this.webAssemblyContext2D.SCRTSetClearAlphaParams(enabled, alpha);
    }
    zoomExtentsYInternal(xRanges, animationDurationMs = 0, easingFunction = EasingFunctions_1.easing.outExpo, onCompleted = () => { }) {
        this.yAxes.asArray().forEach(yAxis => {
            const yRange = yAxis.getWindowedYRange(xRanges);
            yAxis.animateVisibleRange(yRange, animationDurationMs, easingFunction, onCompleted);
        });
    }
    zoomExtentsXInternal(animationDurationMs = 0, easingFunction = EasingFunctions_1.easing.outExpo, onCompleted = () => { }) {
        const xRanges = new Dictionary_1.Dictionary();
        this.xAxes.asArray().forEach(xAxis => {
            const maxXRange = xAxis.getMaximumRange();
            xAxis.animateVisibleRange(maxXRange, animationDurationMs, easingFunction, onCompleted);
            xRanges.add(xAxis.id, maxXRange);
        });
        return xRanges;
    }
    // Step_4: Start drawing
    onRenderSurfaceDraw() {
        // Logger.log("onRenderSurfaceDraw! " + Date.now().toLocaleString());
        this.doDrawingLoop();
    }
    detachSeries(renderableSeries) {
        this.chartModifiers.asArray().forEach(cm => {
            cm.onDetachSeries(renderableSeries);
        });
        renderableSeries.onDetach();
        this.invalidateElement();
    }
    attachSeries(renderableSeries) {
        renderableSeries.onAttach(this);
        if (this.themeProviderProperty) {
            renderableSeries.applyTheme(this.themeProviderProperty);
        }
        this.chartModifiers.asArray().forEach(cm => {
            cm.onAttachSeries(renderableSeries);
        });
        this.invalidateElement();
    }
    detachAxis(axis) {
        axis.invalidateParentCallback = undefined;
        axis.parentSurface = undefined;
        this.invalidateElement();
    }
    attachAxis(axis, isXAxis) {
        axis.parentSurface = this;
        if (this.themeProviderProperty) {
            axis.applyTheme(this.themeProviderProperty);
        }
        if (axis.invalidateParentCallback) {
            throw new Error("Invalid operation in sciChartSurface.attachAxis, this axis has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another");
        }
        axis.isXAxis = isXAxis;
        if (isXAxis && this.xAxes.size() === 1) {
            axis.isPrimaryAxis = true;
        }
        if (!isXAxis && this.yAxes.size() === 1) {
            axis.isPrimaryAxis = true;
        }
        axis.invalidateParentCallback = this.invalidateElement;
        this.invalidateElement();
    }
    detachAnnotation(annotation) {
        annotation.onDetach();
        annotation.invalidateParentCallback = undefined;
        annotation.parentSurface = undefined;
        this.invalidateElement();
    }
    attachAnnotation(annotation) {
        if (annotation.invalidateParentCallback) {
            throw new Error("Invalid operation in sciChartSurface.attachAnnotation, this annotation has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another");
        }
        annotation.parentSurface = this;
        annotation.invalidateParentCallback = this.invalidateElement;
        annotation.onAttach(this);
        this.invalidateElement();
    }
}
exports.SciChartSurface = SciChartSurface;
// SINGLE CHART FUNCTIONS
/** @ignore */
const initDrawEngineSingleChart = (wasmContext, canvases, resolve) => {
    const width = canvases.domCanvas2D.width;
    const height = canvases.domCanvas2D.height;
    // @ts-ignore
    wasmContext.preRun.push(() => (ENV.SDL_EMSCRIPTEN_KEYBOARD_ELEMENT = "#chart_WebGL"));
    wasmContext.TSRSetMainWindowSize(width, height);
    let scs;
    wasmContext.canvas = canvases.domCanvasWebGL;
    const chartInitializer = {
        InitializeChart() {
            scs = new SciChartSurface(wasmContext, { viewportSize: new Size_1.Size(width, height), canvases });
            setTimeout(() => {
                scs.invalidateElement();
                licenseManager2D_1.licenseManager.applyLicense2D(wasmContext, scs, true);
                sciChartInitCommon_1.default.subscribeToResize(canvases.domChartRoot, canvases.aspect, scs);
                resolve({ wasmContext, sciChartSurface: scs });
            }, 0);
        },
        Draw() {
            scs.renderSurface.onRenderTimeElapsed();
        },
        Update(deltaTime) {
            logger_1.Logger.log("sciChartInitCommon.ts Update");
        },
        ShutDownChart() {
            logger_1.Logger.log("sciChartInitCommon.ts ShutDownChart");
        }
    };
    const chartInitObj = wasmContext.SCRTSampleChartInterface.implement(chartInitializer);
    chartInitObj.SetFPSCounterEnabled(false);
    wasmContext.SCRTSetGlobalSampleChartInterface(chartInitObj);
};
// MULTI-CHART FUNCTIONS
/** @ignore */
const createMultichart = (divElementId, width = 0, height = 0) => __awaiter(void 0, void 0, void 0, function* () {
    sciChartInitCommon_1.default.checkChartDivExists(divElementId);
    loader_1.default.addLoaderStyles();
    const canvases = sciChartInitCommon_1.default.initCanvas(divElementId, width, height, sciChartInitCommon_1.default.ECanvasType.canvas2D);
    const loaderDiv = loader_1.default.addChartLoader(canvases.domDivContainer);
    if (!sciChartMaster.wasmContext || !sciChartMaster.createChildSurface || !sciChartMaster.getChildSurfaces) {
        if (!sciChartMasterPromise) {
            sciChartMasterPromise = createMaster();
        }
        const master = yield sciChartMasterPromise;
        sciChartMaster.wasmContext = master.wasmContext;
        sciChartMaster.createChildSurface = master.createChildSurface;
        sciChartMaster.getChildSurfaces = master.getChildSurfaces;
    }
    const { createChildSurface, wasmContext } = sciChartMaster;
    const sciChartSurface = createChildSurface(divElementId, canvases);
    const restoreContext = () => {
        // invalidate WebGl Resources
        WebGlRenderContext2D_1.WebGlRenderContext2D.webGlResourcesRefs.forEach(penCache => {
            penCache.invalidateCache();
        });
        // stop the engine
        wasmContext.SCRTShutdownEngine2D();
        // replace WebGL canvas
        const element = document.querySelector(`#${MASTER_CANVAS_ID}`);
        element.removeEventListener("webglcontextlost", webGLLostContextEventHandler);
        document.body.removeChild(element);
        wasmContext.canvas = SciChartSurfaceBase_1.getMasterCanvas(MASTER_CANVAS_ID);
        wasmContext.canvas.addEventListener("webglcontextlost", webGLLostContextEventHandler, false);
        // restart the engine
        wasmContext.SCRTInitEngine2D();
        wasmContext.TSRSetDrawRequestsEnabled(true);
        // request redraw
        sciChartSurface.invalidateElement();
    };
    const webGLLostContextEventHandler = (event) => {
        console.warn("WebGL context lost.");
        event.preventDefault();
        restoreContext();
    };
    wasmContext.canvas.addEventListener("webglcontextlost", webGLLostContextEventHandler, false);
    return new Promise(resolve => {
        setTimeout(() => {
            loader_1.default.removeChartLoader(canvases.domDivContainer, loaderDiv);
            resolve({ wasmContext, sciChartSurface });
        }, 0);
    });
});
/** @ignore */
const createMaster = () => {
    const sciChartDestinations = [];
    const createChildSurfaceInner = (wasmContext, divElementId, canvases) => {
        const viewportSize = new Size_1.Size(canvases.domCanvas2D.width, canvases.domCanvas2D.height);
        const sciChartSurface = new SciChartSurface(wasmContext, { viewportSize, canvases });
        sciChartInitCommon_1.default.subscribeToResize(canvases.domChartRoot, canvases.aspect, sciChartSurface);
        sciChartSurface.setDestinations(sciChartDestinations);
        return sciChartSurface;
    };
    const addDestination = (wasmContext, canvasElementId, sciChartSurface, width, height, chartInitObj) => {
        const newDestination = SciChartSurfaceBase_1.createChartDestination(canvasElementId);
        if (!newDestination) {
            sciChartSurface.delete();
            return;
        }
        const dest = wasmContext.SCRTSurfaceDestination.implement(newDestination);
        chartInitObj.AddDestination(dest);
        chartInitObj.SetFPSCounterEnabled(false);
        sciChartDestinations.push({ canvasElementId, sciChartSurface, width, height });
    };
    return new Promise(resolve => {
        // @ts-ignore
        new WasmModule2D({ locateFile }).then((wasmContext) => {
            const getChildSurfaces = () => sciChartDestinations.map(el => el.sciChartSurface);
            // Create of replace child surface
            const createChildSurface = (divElementId, canvases) => {
                const canvas2dId = sciChartInitCommon_1.default.getCanvas2dId(divElementId);
                const sameIdDestinations = sciChartDestinations.filter(el => el.canvasElementId === canvas2dId);
                sameIdDestinations.forEach(el => el.sciChartSurface.delete());
                const otherDestinations = sciChartDestinations.filter(el => el.canvasElementId !== canvas2dId);
                chartInitObj.ClearDestinations();
                while (sciChartDestinations.length > 0) {
                    sciChartDestinations.pop();
                }
                otherDestinations.forEach(el => addDestination(wasmContext, el.canvasElementId, el.sciChartSurface, el.width, el.height, chartInitObj));
                const sciChartSurface = createChildSurfaceInner(wasmContext, divElementId, canvases);
                addDestination(wasmContext, canvas2dId, sciChartSurface, canvases.domCanvas2D.width, canvases.domCanvas2D.height, chartInitObj);
                licenseManager2D_1.licenseManager.applyLicense2D(wasmContext, sciChartSurface, false);
                return sciChartSurface;
            };
            wasmContext.canvas = SciChartSurfaceBase_1.getMasterCanvas(MASTER_CANVAS_ID);
            const chartInitializer = {
                InitializeChart() {
                    resolve({ getChildSurfaces, createChildSurface, wasmContext });
                },
                Draw() {
                    sciChartDestinations.forEach((dest, index) => {
                        const { canvasElementId, sciChartSurface } = dest;
                        const chart = wasmContext.SCRTGetGlobalSampleChartInterface();
                        if (chart.GetCurrentDestination()) {
                            const currDestID = chart.GetCurrentDestination().GetID();
                            if (currDestID === canvasElementId) {
                                sciChartSurface.renderSurface.onRenderTimeElapsed();
                            }
                        }
                    });
                },
                Update(deltaTime) {
                    // Logger.log("sciChartInitCommon.ts Update");
                },
                ShutDownChart() {
                    // Logger.log("sciChartInitCommon.ts ShutDownChart");
                }
            };
            const chartInitObj = wasmContext.SCRTSampleChartInterface.implement(chartInitializer);
            wasmContext.SCRTSetGlobalSampleChartInterface(chartInitObj);
            /// create an object that native side can trigger the copy to from...
            const canvasCopyObj = wasmContext.SCRTCopyToDestinationInterface.implement({
                CopyToDestination: SciChartSurfaceBase_1.copyToCanvas(MASTER_CANVAS_ID)
            });
            wasmContext.SCRTSetGlobalCopyToDestinationInterface(canvasCopyObj);
            wasmContext.TSRSetDrawRequestsEnabled(true);
        });
    });
};
