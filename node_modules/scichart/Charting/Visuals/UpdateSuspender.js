"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateSuspender = void 0;
const Dictionary_1 = require("../../Core/Dictionary");
const Guard_1 = require("../../Core/Guard");
/**
 * A class which allows nested suspend/resume operations on an {@link ISuspendable} target
 */
class UpdateSuspender {
    /**
     * Creates an instance of an {@link UpdateSuspender}
     * @param target The target that we want to suspend. Multiple nested suspend/resumes are permitted
     * @param shouldResumeTarget This flag is passed through to the target on resume
     */
    constructor(target, shouldResumeTarget = true) {
        this.resumeTargetProperty = shouldResumeTarget;
        this.targetProperty = target;
        if (!UpdateSuspender.suspendedInstances.containsKey(this.targetProperty.suspendableId)) {
            UpdateSuspender.suspendedInstances.add(target.suspendableId, { id: target.suspendableId, suspendable: target, suspendCount: 1 });
        }
        else {
            this.increment(target);
        }
    }
    /**
     * Get whether the provided {@link ISuspendable} instance is suspended or not
     * @param target The target {@link ISuspendable}
     */
    static getIsSuspended(target) {
        return UpdateSuspender.suspendedInstances.containsKey(target.suspendableId);
    }
    /**
     * A helper function to perform multiple operations in a single batch with a single redraw at the end
     * @remarks Implements the .suspendUpdates() and .resume() pattern around a function.
     * Equivalent to calling target.suspendUpdates(), batchOperation() then .resume()
     * @param target The target that we want to suspend and resume around a batch operation
     * @param batchOperation
     */
    static using(target, batchOperation) {
        Guard_1.Guard.notNull(target, "target");
        const s = target.suspendUpdates();
        try {
            batchOperation();
        }
        finally {
            s.resume();
        }
    }
    /**
     * Gets whether the current instance is suspended
     */
    get isSuspended() {
        return UpdateSuspender.getIsSuspended(this.targetProperty);
    }
    /**
     * Gets whether the target should resume once updates are resumed
     */
    get shouldResumeTarget() {
        return this.resumeTargetProperty;
    }
    /**
     * Call this to resume drawing on the target {@link ISuspendable}
     */
    resume() {
        this.targetProperty.decrementSuspend();
        if (this.decrement(this.targetProperty) === 0) {
            UpdateSuspender.suspendedInstances.remove(this.targetProperty.suspendableId);
            this.targetProperty.resumeUpdates(this);
        }
    }
    increment(target) {
        UpdateSuspender.suspendedInstances.item(target.suspendableId).suspendCount++;
    }
    decrement(target) {
        let current = UpdateSuspender.suspendedInstances.item(target.suspendableId).suspendCount;
        current--;
        UpdateSuspender.suspendedInstances.item(target.suspendableId).suspendCount = current;
        return current;
    }
}
exports.UpdateSuspender = UpdateSuspender;
/**
 * USED INTERNALLY: A map of string Id to Suspended instances
 */
UpdateSuspender.suspendedInstances = new Dictionary_1.Dictionary();
