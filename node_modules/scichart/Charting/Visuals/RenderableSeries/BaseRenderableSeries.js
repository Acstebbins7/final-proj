"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSeriesInfo = exports.getDataPointWidth = exports.BaseRenderableSeries = void 0;
const DoubleAnimator_1 = require("../../../Core/Animations/DoubleAnimator");
const Deleter_1 = require("../../../Core/Deleter");
const AxisType_1 = require("../../../types/AxisType");
const SeriesType_1 = require("../../../types/SeriesType");
const guid_1 = require("../../../utils/guid");
const WebGlRenderContext2D_1 = require("../../Drawing/WebGlRenderContext2D");
const HeatmapSeriesInfo_1 = require("../../Model/ChartData/HeatmapSeriesInfo");
const OhlcSeriesInfo_1 = require("../../Model/ChartData/OhlcSeriesInfo");
const StackedXySeriesInfo_1 = require("../../Model/ChartData/StackedXySeriesInfo");
const XyySeriesInfo_1 = require("../../Model/ChartData/XyySeriesInfo");
const IDataSeries_1 = require("../../Model/IDataSeries");
const IPaletteProvider_1 = require("../../Model/IPaletteProvider");
const defaultThemeColors_1 = require("../../Themes/defaultThemeColors");
const AxisCore_1 = require("../Axis/AxisCore");
const constants_1 = require("./constants");
const RolloverModifierRenderableSeriesProps_1 = require("./RolloverModifier/RolloverModifierRenderableSeriesProps");
/**
 * @summary Defines the base class to a Render Series (or Chart Type) in SciChart's High Performance Real-time
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 * A RenderableSeries defines how data should be rendered. e.g. as a Line Chart, Mountain Chart, Candlestick Chart etc...
 * This is independent from the {@link BaseDataSeries | DataSeries} which stores the data to render
 *
 * See derived types of {@link BaseDataSeries} to find out what data-series are available.
 * See derived types of {@link IRenderableSeries} to find out what 2D JavaScript Chart types are available.
 */
class BaseRenderableSeries {
    /**
     * Creates an instance of the {@link BaseRenderableSeries}
     * @param webAssemblyContext The {@link TSciChart | SciChart WebAssembly Context} containing
     * native methods and access to our WebGL2 WebAssembly Drawing Engine
     * @param options optional parameters of type {@link IBaseRenderableSeriesOptions} applied when constructing the series type
     */
    constructor(webAssemblyContext, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        /** @inheritDoc */
        this.id = guid_1.generateGuid();
        /** @inheritDoc */
        this.isStacked = false;
        /** @inheritDoc */
        this.rolloverModifierProps = new RolloverModifierRenderableSeriesProps_1.RolloverModifierRenderableSeriesProps();
        /** @inheritDoc */
        this.rolloverModifierProps1 = new RolloverModifierRenderableSeriesProps_1.RolloverModifierRenderableSeriesProps();
        /** @inheritDoc */
        this.drawingProviders = [];
        this.xAxisIdProperty = AxisCore_1.AxisCore.DEFAULT_AXIS_ID;
        this.yAxisIdProperty = AxisCore_1.AxisCore.DEFAULT_AXIS_ID;
        this.strokeThicknessProperty = 2;
        this.strokeProperty = defaultThemeColors_1.defaultThemeColors.lineSeriesColor;
        this.opacityProperty = 1;
        this.opacityOriginalValue = 1;
        this.drawNaNAsProperty = WebGlRenderContext2D_1.ELineDrawMode.DiscontinuousLine;
        this.isVisibleProperty = true;
        this.isDigitalLineProperty = false;
        this.isDelayPassed = false;
        this.firstAnimationRender = true;
        this.webAssemblyContext = webAssemblyContext;
        // It is very important to add bind(this) first line in constructor,
        // otherwise dataSeries passed through the options does not work!
        this.dataSeriesDataChanged = this.dataSeriesDataChanged.bind(this);
        this.effectPropertyChanged = this.effectPropertyChanged.bind(this);
        this.invalidateParent = this.invalidateParent.bind(this);
        this.getDataPointWidth = this.getDataPointWidth.bind(this);
        this.onAnimate = this.onAnimate.bind(this);
        this.afterAnimationComplete = this.afterAnimationComplete.bind(this);
        this.yAnimationValues = new webAssemblyContext.DoubleVector();
        // Need to set dataSeries (not just dataSeriesProperty) because of dataChanged.subscribe
        this.dataSeries = (_a = options === null || options === void 0 ? void 0 : options.dataSeries) !== null && _a !== void 0 ? _a : this.dataSeriesProperty;
        this.pointMarkerProperty = (_b = options === null || options === void 0 ? void 0 : options.pointMarker) !== null && _b !== void 0 ? _b : this.pointMarkerProperty;
        this.strokeProperty = (_c = options === null || options === void 0 ? void 0 : options.stroke) !== null && _c !== void 0 ? _c : this.strokeProperty;
        this.strokeThicknessProperty = (_d = options === null || options === void 0 ? void 0 : options.strokeThickness) !== null && _d !== void 0 ? _d : this.strokeThicknessProperty;
        this.opacityProperty = (_e = options === null || options === void 0 ? void 0 : options.opacity) !== null && _e !== void 0 ? _e : this.opacityProperty;
        this.xAxisIdProperty = (_f = options === null || options === void 0 ? void 0 : options.xAxisId) !== null && _f !== void 0 ? _f : this.xAxisIdProperty;
        this.yAxisIdProperty = (_g = options === null || options === void 0 ? void 0 : options.yAxisId) !== null && _g !== void 0 ? _g : this.yAxisIdProperty;
        this.isVisibleProperty = (_h = options === null || options === void 0 ? void 0 : options.isVisible) !== null && _h !== void 0 ? _h : this.isVisibleProperty;
        this.isDigitalLineProperty = (_j = options === null || options === void 0 ? void 0 : options.isDigitalLine) !== null && _j !== void 0 ? _j : this.isDigitalLineProperty;
        this.effect = options === null || options === void 0 ? void 0 : options.effect;
        this.paletteProviderProperty = (_k = options === null || options === void 0 ? void 0 : options.paletteProvider) !== null && _k !== void 0 ? _k : new IPaletteProvider_1.DefaultPaletteProvider();
        if ((_l = this.paletteProviderProperty) === null || _l === void 0 ? void 0 : _l.onAttached) {
            (_m = this.paletteProviderProperty) === null || _m === void 0 ? void 0 : _m.onAttached(this);
        }
        this.drawNaNAsProperty = (_o = options === null || options === void 0 ? void 0 : options.drawNaNAs) !== null && _o !== void 0 ? _o : this.drawNaNAsProperty;
        this.hitTestProvider = this.newHitTestProvider();
    }
    /** @inheritDoc */
    applyTheme(themeProvider) {
        const previousThemeProvider = this.parentSurface.previousThemeProvider;
        if (this.rolloverModifierProps.tooltipTextColor === previousThemeProvider.textAnnotationForeground) {
            this.rolloverModifierProps.tooltipTextColor = themeProvider.textAnnotationForeground;
        }
        if (this.rolloverModifierProps.tooltipColor === previousThemeProvider.textAnnotationBackground) {
            this.rolloverModifierProps.tooltipColor = themeProvider.textAnnotationBackground;
        }
        if (this.rolloverModifierProps.markerColor === previousThemeProvider.textAnnotationBackground) {
            this.rolloverModifierProps.markerColor = themeProvider.textAnnotationBackground;
        }
    }
    /** @inheritDoc */
    get paletteProvider() {
        return this.paletteProviderProperty;
    }
    /** @inheritDoc */
    set paletteProvider(paletteProvider) {
        var _a, _b;
        if ((_a = this.paletteProviderProperty) === null || _a === void 0 ? void 0 : _a.onDetached) {
            this.paletteProviderProperty.onDetached();
        }
        this.paletteProviderProperty = paletteProvider;
        if ((_b = this.paletteProviderProperty) === null || _b === void 0 ? void 0 : _b.onAttached) {
            this.paletteProviderProperty.onAttached(this);
        }
        this.notifyPropertyChanged(constants_1.PROPERTY.PALETTE_PROVIDER);
    }
    /** @inheritDoc */
    get isDigitalLine() {
        return this.isDigitalLineProperty;
    }
    /** @inheritDoc */
    set isDigitalLine(isDigitalLine) {
        this.isDigitalLineProperty = isDigitalLine;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_DIGITAL_LINE);
    }
    /** @inheritDoc */
    get isVisible() {
        return this.isVisibleProperty;
    }
    /** @inheritDoc */
    set isVisible(isVisible) {
        this.isVisibleProperty = isVisible;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_VISIBLE);
    }
    /** @inheritDoc */
    get pointMarker() {
        return this.pointMarkerProperty;
    }
    /** @inheritDoc */
    set pointMarker(pointMarker) {
        if (this.pointMarkerProperty) {
            this.pointMarkerProperty.invalidateParentCallback = undefined;
        }
        this.pointMarkerProperty = pointMarker;
        this.notifyPropertyChanged(constants_1.PROPERTY.POINT_MARKER);
        if (this.pointMarkerProperty) {
            this.pointMarkerProperty.invalidateParentCallback = this.invalidateParent;
        }
    }
    /** @inheritDoc */
    get drawNaNAs() {
        return this.drawNaNAsProperty;
    }
    /** @inheritDoc */
    set drawNaNAs(drawNaNAs) {
        this.drawNaNAsProperty = drawNaNAs;
        this.notifyPropertyChanged(constants_1.PROPERTY.DRAW_NAN_AS);
    }
    /** @inheritDoc */
    get stroke() {
        return this.strokeProperty;
    }
    /** @inheritDoc */
    set stroke(htmlColorCode) {
        this.strokeProperty = htmlColorCode;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE);
    }
    /** @inheritDoc */
    get strokeThickness() {
        return this.strokeThicknessProperty;
    }
    /** @inheritDoc */
    set strokeThickness(value) {
        this.strokeThicknessProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE_THICKNESS);
    }
    /** @inheritDoc */
    get opacity() {
        return this.opacityProperty;
    }
    /** @inheritDoc */
    set opacity(value) {
        this.opacityProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.OPACITY);
    }
    /** @inheritDoc */
    get xAxisId() {
        return this.xAxisIdProperty;
    }
    /** @inheritDoc */
    set xAxisId(id) {
        this.xAxisIdProperty = id;
        this.notifyPropertyChanged(constants_1.PROPERTY.XAXIS_ID);
    }
    /** @inheritDoc */
    get xAxis() {
        return this.parentSurface.xAxes.asArray().find(el => el.id === this.xAxisId);
    }
    /** @inheritDoc */
    get yAxis() {
        return this.parentSurface.yAxes.asArray().find(el => el.id === this.yAxisId);
    }
    /** @inheritDoc */
    get yAxisId() {
        return this.yAxisIdProperty;
    }
    /** @inheritDoc */
    set yAxisId(id) {
        this.yAxisIdProperty = id;
        this.notifyPropertyChanged(constants_1.PROPERTY.YAXIS_ID);
    }
    /** @inheritDoc */
    get dataSeries() {
        return this.dataSeriesProperty;
    }
    /** @inheritDoc */
    set dataSeries(dataSeries) {
        var _a, _b;
        (_a = this.dataSeriesProperty) === null || _a === void 0 ? void 0 : _a.dataChanged.unsubscribe(this.dataSeriesDataChanged);
        this.dataSeriesProperty = dataSeries;
        (_b = this.dataSeriesProperty) === null || _b === void 0 ? void 0 : _b.dataChanged.subscribe(this.dataSeriesDataChanged);
        this.notifyPropertyChanged(constants_1.PROPERTY.DATA_SERIES);
    }
    /**
     * Gets an optional {@link ShaderEffect} for modifying the render output of this {@link IRenderableSeries}
     * @remarks Options include {@link GlowEffect} and {@link ShadowEffect}. Apply an effect to see how it modifies rendering!
     */
    get effect() {
        return this.effectProperty;
    }
    /**
     * Sets an optional {@link ShaderEffect} for modifying the render output of this {@link IRenderableSeries}
     * @remarks Options include {@link GlowEffect} and {@link ShadowEffect}. Apply an effect to see how it modifies rendering!
     */
    set effect(effect) {
        var _a, _b;
        (_a = this.effectProperty) === null || _a === void 0 ? void 0 : _a.propertyChanged.unsubscribe(this.effectPropertyChanged);
        this.effectProperty = effect;
        (_b = this.effectProperty) === null || _b === void 0 ? void 0 : _b.propertyChanged.subscribe(this.effectPropertyChanged);
        this.notifyPropertyChanged(constants_1.PROPERTY.EFFECT);
    }
    /**
     * Gets a start up animation class, a child class for {@link BaseAnimation}
     */
    get animation() {
        return this.animationProperty;
    }
    /**
     * Sets a start up animation class, a child class for {@link BaseAnimation}
     */
    set animation(value) {
        this.animationProperty = value;
        this.firstAnimationRender = true;
        this.isDelayPassed = false;
        this.invalidateParent();
    }
    /** @inheritDoc */
    get isSpline() {
        return [SeriesType_1.ESeriesType.SplineBandSeries, SeriesType_1.ESeriesType.SplineLineSeries, SeriesType_1.ESeriesType.SplineMountainSeries].includes(this.type);
    }
    /** @inheritDoc */
    draw(renderContext, renderPassData) {
        var _a;
        (_a = this.hitTestProvider) === null || _a === void 0 ? void 0 : _a.update(renderPassData);
        let canDraw = true;
        if (this.animationProperty) {
            this.drawDelayTimer();
            canDraw = this.isDelayPassed;
        }
        if (canDraw) {
            this.firstAnimationRender = false;
            try {
                renderContext.pushShaderEffect(this.effect);
                this.drawingProviders.forEach(dp => dp.draw(renderContext, renderPassData));
            }
            finally {
                renderContext.popShaderEffect();
            }
        }
    }
    /** @inheritDoc */
    delete() {
        this.drawingProviders.forEach(dp => dp.delete());
        this.drawingProviders = [];
        this.dataSeries = Deleter_1.deleteSafe(this.dataSeries);
        this.yAnimationValues = Deleter_1.deleteSafe(this.yAnimationValues);
    }
    /** @inheritDoc */
    getXRange() {
        return this.dataSeries.xRange;
    }
    /** @inheritDoc */
    getYRange(xVisibleRange, isXCategoryAxis = false) {
        return this.dataSeries.getWindowedYRange(xVisibleRange, true, isXCategoryAxis);
    }
    /** @inheritDoc */
    notifyPropertyChanged(propertyName) {
        this.drawingProviders.forEach(dp => dp.onSeriesPropertyChange(propertyName));
        this.invalidateParent();
    }
    /**
     * @description Calculates data point width in pixels
     * @param xCoordCalc
     * @param widthFraction
     */
    getDataPointWidth(xCoordCalc, widthFraction) {
        const xValues = this.dataSeries.getNativeXValues();
        const seriesViewRectWidth = this.parentSurface.seriesViewRect.width;
        const isCategoryAxis = this.parentSurface.xAxes.size() !== 0 && this.xAxis.type === AxisType_1.EAxisType.CategoryAxis;
        return exports.getDataPointWidth(xValues, xCoordCalc, seriesViewRectWidth, widthFraction, isCategoryAxis);
    }
    /** @inheritDoc */
    onDetach() {
        this.invalidateParentCallback = undefined;
        this.parentSurface = undefined;
        this.drawingProviders.forEach(dp => dp.onDetachSeries());
        this.rolloverModifierProps.setInvalidateParentCallback(undefined);
    }
    /** @inheritDoc */
    onAttach(scs) {
        this.parentSurface = scs;
        if (this.invalidateParentCallback) {
            throw new Error("Invalid operation in sciChartSurface.attachSeries, this series has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another");
        }
        this.invalidateParentCallback = scs.invalidateElement;
        this.drawingProviders.forEach(dp => dp.onAttachSeries());
        this.rolloverModifierProps.setInvalidateParentCallback(scs.invalidateElement);
    }
    /** @inheritDoc */
    hasStrokePaletteProvider() {
        const strokePalette = this.paletteProvider;
        return (strokePalette === null || strokePalette === void 0 ? void 0 : strokePalette.overrideStrokeArgb) !== undefined;
    }
    /** @inheritDoc */
    hasFillPaletteProvider() {
        const fillPalette = this.paletteProvider;
        return (fillPalette === null || fillPalette === void 0 ? void 0 : fillPalette.overrideFillArgb) !== undefined;
    }
    /** @inheritDoc */
    hasPointMarkerPaletteProvider() {
        const pointMarkerPalette = this.paletteProvider;
        return (pointMarkerPalette === null || pointMarkerPalette === void 0 ? void 0 : pointMarkerPalette.overridePointMarkerArgb) !== undefined;
    }
    /** @inheritDoc */
    hasDataSeriesValues() {
        return this.dataSeries.hasValues;
    }
    /** @inheritDoc */
    hasDataSeries() {
        return !!this.dataSeries;
    }
    /** @inheritDoc */
    getDataSeriesValuesCount() {
        return this.dataSeries.count();
    }
    /** @inheritDoc */
    getBaseXValues() {
        const xNativeValues = this.getNativeXValues();
        const baseXValues = [];
        for (let i = 0; i < this.getDataSeriesValuesCount(); i++) {
            baseXValues.push(xNativeValues.get(i));
        }
        return baseXValues;
    }
    /** @inheritDoc */
    getDataSeriesName() {
        return this.dataSeries.dataSeriesName;
    }
    /** @inheritDoc */
    getNativeXValues() {
        return this.dataSeries.getNativeXValues();
    }
    /**
     * Returns the {@link IDataSeries.getNativeYValues} for the associated {@link dataSeries}
     */
    getNativeYValues() {
        return this.dataSeries.getNativeYValues();
    }
    /** @inheritDoc */
    checkIsOutOfDataRange(xValue, yValue) {
        const length = this.getDataSeriesValuesCount();
        const isCategoryAxis = this.xAxis.getCurrentCoordinateCalculator().isCategoryCoordinateCalculator;
        const min = isCategoryAxis ? 0 : this.getNativeXValues().get(0);
        const max = isCategoryAxis ? length - 1 : this.getNativeXValues().get(length - 1);
        return xValue < min || xValue > max;
    }
    /**
     * gets if the animation is currently running
     */
    get isRunningAnimation() {
        return !!this.animationToken;
    }
    /**
     * adds palette colors
     */
    pushPalettedColors(color, palettingState) {
        palettingState.palettedColors.push_back(color);
    }
    /**
     * Starts an animation for {@link IRenderableSeries}
     */
    animate() {
        if (!this.dataSeriesProperty || !this.animationProperty || !this.isDelayPassed) {
            return undefined;
        }
        const durationMs = this.animation.duration;
        if (durationMs <= 0) {
            return undefined;
        }
        if (this.isRunningAnimation) {
            this.animationToken.cancelAnimation();
            this.afterAnimationComplete();
        }
        this.beforeAnimationStart();
        this.animationToken = DoubleAnimator_1.DoubleAnimator.animate(0, 1, durationMs, this.onAnimate, this.afterAnimationComplete, this.animationProperty.ease);
    }
    /**
     * Runs before the animation starts
     * @protected
     */
    beforeAnimationStart() {
        this.opacityOriginalValue = this.opacity;
        const pointMarker = this.pointMarker;
        if (pointMarker) {
            pointMarker.fillOriginalValue = pointMarker.fill;
            pointMarker.strokeOriginalValue = pointMarker.stroke;
            pointMarker.opacityOriginalValue = pointMarker.opacity;
        }
    }
    /**
     * Runs after the animation is complete
     * @protected
     */
    afterAnimationComplete() {
        this.opacityProperty = this.opacityOriginalValue;
        const pointMarker = this.pointMarker;
        if (this.pointMarker) {
            pointMarker.fill = pointMarker.fillOriginalValue;
            pointMarker.stroke = pointMarker.strokeOriginalValue;
            pointMarker.opacity = pointMarker.opacityOriginalValue;
        }
        this.animationToken = undefined;
    }
    /**
     * Internal method that runs on each animation tick
     * @param progress The current animation progress, a value from 0 to 1
     * @protected
     */
    onAnimate(progress) {
        const pointMarker = this.pointMarker;
        if (this.animation.fadeEffect) {
            this.opacity = progress * this.opacityOriginalValue;
            if (pointMarker) {
                pointMarker.opacity = progress * pointMarker.opacityOriginalValue;
            }
        }
        else {
            this.opacity = this.opacityOriginalValue;
            if (pointMarker) {
                pointMarker.fill = pointMarker.fillOriginalValue;
                pointMarker.stroke = pointMarker.strokeOriginalValue;
            }
        }
        this.drawingProviders.forEach(dp => dp.onAnimate(progress, this.animation));
        if (this.invalidateParentCallback) {
            this.invalidateParentCallback();
        }
    }
    /**
     * Is being called when the data for the underlying DataSeries changes
     * @protected
     */
    dataSeriesDataChanged() {
        this.invalidateParent();
    }
    invalidateParent() {
        if (this.invalidateParentCallback) {
            this.invalidateParentCallback();
        }
    }
    effectPropertyChanged() {
        this.invalidateParent();
    }
    drawDelayTimer() {
        const delay = this.animationProperty.delay;
        if (!this.isDelayPassed && this.firstAnimationRender) {
            this.firstAnimationRender = false;
            setTimeout(() => {
                this.isDelayPassed = true;
                this.animate();
            }, delay);
        }
    }
}
exports.BaseRenderableSeries = BaseRenderableSeries;
exports.getDataPointWidth = (xValues, xCoordCalc, seriesViewRectWidth, widthFraction, isCategoryAxis) => {
    if (widthFraction < 0 || widthFraction > 1) {
        throw new Error("WidthFraction should be between 0.0 and 1.0 inclusive");
    }
    // TODO: vertical chart
    const count = xValues.size();
    let dataPointWidth = seriesViewRectWidth;
    const barsAmount = count;
    // TODO: logarithmic axis
    if (barsAmount > 1) {
        let max = xCoordCalc.getCoordinate(xValues.get(count - 1));
        let min = xCoordCalc.getCoordinate(xValues.get(0));
        if (isCategoryAxis) {
            max = xCoordCalc.getCoordinate(count - 1);
            min = xCoordCalc.getCoordinate(0);
        }
        dataPointWidth = Math.abs(max - min) / (barsAmount - 1);
    }
    else if (barsAmount === 1) {
        dataPointWidth = Math.min(dataPointWidth, xCoordCalc.getCoordinate(xValues.get(0)) * 2);
    }
    let candleWidth = Math.floor(dataPointWidth * widthFraction);
    if (candleWidth <= 1 || candleWidth % 2 !== 0) {
        candleWidth -= 1;
    }
    return candleWidth;
};
exports.getSeriesInfo = (rs, hitTestInfo) => {
    if (rs.isStacked) {
        return new StackedXySeriesInfo_1.StackedXySeriesInfo(rs, hitTestInfo);
    }
    switch (hitTestInfo.dataSeriesType) {
        case IDataSeries_1.EDataSeriesType.Ohlc:
            return new OhlcSeriesInfo_1.OhlcSeriesInfo(rs, hitTestInfo);
        case IDataSeries_1.EDataSeriesType.Xyy:
            return new XyySeriesInfo_1.XyySeriesInfo(rs, hitTestInfo);
        case IDataSeries_1.EDataSeriesType.HeatmapUniform:
            return new HeatmapSeriesInfo_1.HeatmapSeriesInfo(rs, hitTestInfo);
        default:
            return new XyySeriesInfo_1.XyySeriesInfo(rs, hitTestInfo);
    }
};
