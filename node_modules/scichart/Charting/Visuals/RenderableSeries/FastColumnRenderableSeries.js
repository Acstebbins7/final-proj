"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getXRange = exports.FastColumnRenderableSeries = void 0;
const NumberRange_1 = require("../../../Core/NumberRange");
const SeriesType_1 = require("../../../types/SeriesType");
const defaultThemeColors_1 = require("../../Themes/defaultThemeColors");
const animationHelper_1 = require("./Animations/animationHelper");
const BaseRenderableSeries_1 = require("./BaseRenderableSeries");
const constants_1 = require("./constants");
const ColumnSeriesDrawingProvider_1 = require("./DrawingProviders/ColumnSeriesDrawingProvider");
const PointMarkerDrawingProvider_1 = require("./DrawingProviders/PointMarkerDrawingProvider");
const ColumnSeriesHitTestProvider_1 = require("./HitTest/ColumnSeriesHitTestProvider");
/**
 * Defines a column-series or JavaScript column chart type in the SciChart's High Performance Real-time
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 * To add a column series to a {@link SciChartSurface} you need to declare both the {@link FastColumnRenderableSeries | RenderableSeries}
 * and a {@link XyDataSeries | DataSeries}. Simplified code sample below:
 *
 * ```ts
 * const sciChartSurface: SciChartSurface;
 * const wasmContext: TSciChart;
 * // Create and fill the dataseries
 * const dataSeries = new XyDataSeries(wasmContext);
 * dataSeries.append(1,2);
 * dataSeries.append(1,2);
 * // Create the renderableSeries
 * const columnSeries = new FastColumnRenderableSeries(wasmContext);
 * columnSeries.dataSeries = dataSeries;
 * // append to the SciChartSurface
 * sciChartSurface.renderableSeries.add(columnSeries);
 * ```
 */
class FastColumnRenderableSeries extends BaseRenderableSeries_1.BaseRenderableSeries {
    /**
     * Creates an instance of the {@link FastColumnRenderableSeries}
     * @param webAssemblyContext The {@link TSciChart | SciChart WebAssembly Context} containing
     * native methods and access to our WebGL2 WebAssembly Drawing Engine
     * @param options optional parameters of type {@link IColumnRenderableSeriesOptions} applied when constructing the series type
     */
    constructor(webAssemblyContext, options) {
        var _a, _b, _c, _d;
        super(webAssemblyContext, options);
        this.type = SeriesType_1.ESeriesType.ColumnSeries;
        this.fillProperty = defaultThemeColors_1.defaultThemeColors.columnFillBrush;
        this.zeroLineYProperty = 0;
        this.dataPointWidthProperty = 0.8;
        this.fill = (_a = options === null || options === void 0 ? void 0 : options.fill) !== null && _a !== void 0 ? _a : this.fillProperty;
        this.zeroLineY = (_b = options === null || options === void 0 ? void 0 : options.zeroLineY) !== null && _b !== void 0 ? _b : this.zeroLineYProperty;
        this.dataPointWidthProperty = (_c = options === null || options === void 0 ? void 0 : options.dataPointWidth) !== null && _c !== void 0 ? _c : this.dataPointWidthProperty;
        this.drawingProviders.push(new ColumnSeriesDrawingProvider_1.ColumnSeriesDrawingProvider(webAssemblyContext, this));
        this.drawingProviders.push(new PointMarkerDrawingProvider_1.PointMarkerDrawingProvider(webAssemblyContext, this));
        // This should be in the end after all DoubleVectors used for animation have been created
        this.animation = (_d = options === null || options === void 0 ? void 0 : options.animation) !== null && _d !== void 0 ? _d : this.animation;
    }
    applyTheme(themeProvider) {
        super.applyTheme(themeProvider);
        const previousThemeProvider = this.parentSurface.previousThemeProvider;
        if (this.fill === previousThemeProvider.columnFillBrush) {
            this.fill = themeProvider.columnFillBrush;
        }
        if (this.stroke === previousThemeProvider.columnLineColor) {
            this.stroke = themeProvider.columnLineColor;
        }
    }
    get fill() {
        return this.fillProperty;
    }
    set fill(htmlColorCode) {
        this.fillProperty = htmlColorCode;
        this.notifyPropertyChanged(constants_1.PROPERTY.FILL);
    }
    /**
     * Gets or sets the Zero-line Y, the Y-value where the mountain crosses zero and inverts. Default is 0
     */
    get zeroLineY() {
        return this.zeroLineYProperty;
    }
    /**
     * Gets or sets the Zero-line Y, the Y-value where the mountain crosses zero and inverts. Default is 0
     */
    set zeroLineY(zeroLineY) {
        this.zeroLineYProperty = zeroLineY;
        this.notifyPropertyChanged(constants_1.PROPERTY.ZERO_LINE_Y);
    }
    /**
     * Gets or sets the width of candles as a fraction of available space. Valid values range from 0.0 - 1.0
     */
    get dataPointWidth() {
        return this.dataPointWidthProperty;
    }
    /**
     * Gets or sets the width of candles as a fraction of available space. Valid values range from 0.0 - 1.0
     */
    set dataPointWidth(dataPointWidth) {
        this.dataPointWidthProperty = dataPointWidth;
        this.notifyPropertyChanged(constants_1.PROPERTY.DATA_POINT_WIDTH);
    }
    /**
     * @inheritDoc
     */
    getXRange() {
        const range = super.getXRange();
        const count = this.dataSeries.count();
        return exports.getXRange(range, count, this.dataPointWidth);
    }
    /**
     * @inheritDoc
     */
    getYRange(xVisibleRange, isXCategoryAxis = false) {
        const yRange = super.getYRange(xVisibleRange, isXCategoryAxis);
        if (!yRange) {
            return undefined;
        }
        return new NumberRange_1.NumberRange(Math.min(yRange.min, this.zeroLineY), Math.max(yRange.max, this.zeroLineY));
    }
    /**
     * @inheritDoc
     */
    newHitTestProvider() {
        return new ColumnSeriesHitTestProvider_1.ColumnSeriesHitTestProvider(this);
    }
    /**
     * @inheritDoc
     */
    onAnimate(progress) {
        var _a;
        super.onAnimate(progress);
        const dataSeries = this.dataSeries;
        if (!dataSeries) {
            (_a = this.animationToken) === null || _a === void 0 ? void 0 : _a.cancelAnimation();
        }
        else {
            animationHelper_1.calculateAnimationValues(this.webAssemblyContext, dataSeries.getNativeYValues(), this.yAnimationValues, this.animation, progress);
        }
    }
}
exports.FastColumnRenderableSeries = FastColumnRenderableSeries;
exports.getXRange = (range, count, widthFraction) => {
    if (count > 1) {
        const additionalValue = ((range.diff / (count - 1)) * widthFraction) / 2;
        return new NumberRange_1.NumberRange(range.min - additionalValue, range.max + additionalValue);
    }
    // TODO: figure out what to do if we have only one point
    return range;
};
