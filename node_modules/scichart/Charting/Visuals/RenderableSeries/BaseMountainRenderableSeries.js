"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseMountainRenderableSeries = void 0;
const colorUtil_1 = require("../../../utils/colorUtil");
const parseColor_1 = require("../../../utils/parseColor");
const defaultThemeColors_1 = require("../../Themes/defaultThemeColors");
const BaseRenderableSeries_1 = require("./BaseRenderableSeries");
const constants_1 = require("./constants");
const MountainSeriesDrawingProvider_1 = require("./DrawingProviders/MountainSeriesDrawingProvider");
const PointMarkerDrawingProvider_1 = require("./DrawingProviders/PointMarkerDrawingProvider");
const MountainSeriesHitTestProvider_1 = require("./HitTest/MountainSeriesHitTestProvider");
class BaseMountainRenderableSeries extends BaseRenderableSeries_1.BaseRenderableSeries {
    constructor(webAssemblyContext, options) {
        var _a, _b, _c, _d, _e;
        super(webAssemblyContext, options);
        this.zeroLineYProperty = 0;
        this.fillProperty = defaultThemeColors_1.defaultThemeColors.mountainAreaBrush;
        this.strokeDashArrayProperty = [];
        this.stroke = (_a = options === null || options === void 0 ? void 0 : options.stroke) !== null && _a !== void 0 ? _a : defaultThemeColors_1.defaultThemeColors.mountainLineColor;
        this.strokeDashArrayProperty = (_b = options === null || options === void 0 ? void 0 : options.strokeDashArray) !== null && _b !== void 0 ? _b : this.strokeDashArrayProperty;
        this.fillProperty = (_c = options === null || options === void 0 ? void 0 : options.fill) !== null && _c !== void 0 ? _c : this.fillProperty;
        this.zeroLineYProperty = (_d = options === null || options === void 0 ? void 0 : options.zeroLineY) !== null && _d !== void 0 ? _d : this.zeroLineYProperty;
        this.fillLinearGradientProperty = (_e = options === null || options === void 0 ? void 0 : options.fillLinearGradient) !== null && _e !== void 0 ? _e : this.fillLinearGradientProperty;
        this.drawingProviders.push(new MountainSeriesDrawingProvider_1.MountainSeriesDrawingProvider(webAssemblyContext, this));
        this.drawingProviders.push(new PointMarkerDrawingProvider_1.PointMarkerDrawingProvider(webAssemblyContext, this));
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        super.applyTheme(themeProvider);
        const previousThemeProvider = this.parentSurface.previousThemeProvider;
        if (this.fill === previousThemeProvider.mountainAreaBrush) {
            this.fill = themeProvider.mountainAreaBrush;
        }
        if (this.stroke === previousThemeProvider.mountainLineColor) {
            this.stroke = themeProvider.mountainLineColor;
        }
    }
    /**
     * Gets or sets the fill color as an HTML Color code
     */
    get fill() {
        return this.fillProperty;
    }
    /**
     * Gets or sets the fill color as an HTML Color code
     */
    set fill(htmlColorCode) {
        this.fillProperty = htmlColorCode;
        this.notifyPropertyChanged(constants_1.PROPERTY.FILL);
    }
    /**
     * Gets or sets the Zero-line Y, the Y-value where the mountain crosses zero and inverts. Default is 0
     */
    get zeroLineY() {
        return this.zeroLineYProperty;
    }
    /**
     * Gets or sets the Zero-line Y, the Y-value where the mountain crosses zero and inverts. Default is 0
     */
    set zeroLineY(zeroLineY) {
        this.zeroLineYProperty = zeroLineY;
        this.notifyPropertyChanged(constants_1.PROPERTY.ZERO_LINE_Y);
    }
    /**
     * Gets or sets the fill as a gradient brush
     */
    get fillLinearGradient() {
        return this.fillLinearGradientProperty;
    }
    /**
     * Gets or sets the fill as a gradient brush
     */
    set fillLinearGradient(gradientBrushParams) {
        // We need this check, to prevent creating new Texture if we set the same value
        if (gradientBrushParams !== this.fillLinearGradientProperty) {
            this.fillLinearGradientProperty = gradientBrushParams;
            this.notifyPropertyChanged(constants_1.PROPERTY.FILL_LINEAR_GRADIENT);
        }
    }
    /**
     * The StrokeDashArray defines the stroke or dash pattern for the line.
     * Accepts an array of values, e.g. [2,2] will have a line of length 2 and a gap of length 2.
     */
    get strokeDashArray() {
        return this.strokeDashArrayProperty;
    }
    /**
     * The StrokeDashArray defines the stroke or dash pattern for the line.
     * Accepts an array of values, e.g. [2,2] will have a line of length 2 and a gap of length 2.
     */
    set strokeDashArray(strokeDashArray) {
        this.strokeDashArrayProperty = strokeDashArray;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE_DASH_ARRAY);
    }
    /**
     * @inheritDoc
     */
    newHitTestProvider() {
        return new MountainSeriesHitTestProvider_1.MountainSeriesHitTestProvider(this);
    }
    /**
     * @inheritDoc
     */
    beforeAnimationStart() {
        super.beforeAnimationStart();
        this.fillOriginalValue = this.fill;
    }
    /**
     * @inheritDoc
     */
    afterAnimationComplete() {
        super.afterAnimationComplete();
        this.fillProperty = this.fillOriginalValue;
    }
    /**
     * @inheritDoc
     */
    onAnimate(progress) {
        super.onAnimate(progress);
        if (this.animation.fadeEffect) {
            const argbFillColor = parseColor_1.parseColorToUIntArgb(this.fillOriginalValue);
            const newArgbFillColor = colorUtil_1.uintArgbColorMultiplyOpacity(argbFillColor, progress);
            this.fill = parseColor_1.parseArgbToHtmlColor(newArgbFillColor);
        }
        else {
            this.fill = this.fillOriginalValue;
        }
    }
}
exports.BaseMountainRenderableSeries = BaseMountainRenderableSeries;
