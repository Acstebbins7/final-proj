"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniformHeatmapRenderableSeries = exports.COLOR_MAP_PREFIX = void 0;
const SeriesType_1 = require("../../../types/SeriesType");
const AxisCore_1 = require("../Axis/AxisCore");
const BaseRenderableSeries_1 = require("./BaseRenderableSeries");
const constants_1 = require("./constants");
const UniformHeatmapDrawingProvider_1 = require("./DrawingProviders/UniformHeatmapDrawingProvider");
const UniformHeatmapHitTestProvider_1 = require("./HitTest/UniformHeatmapHitTestProvider");
/** @ignore */
exports.COLOR_MAP_PREFIX = "colorMap.";
/**
 * @summary A JavaScript Heatmap chart type rendering a 2-dimensional array of data as color values between X,Y bounds in
 * SciChart's High Performance Real-time {@link https://www.scichart.com/javascript-chart-features | JavaScript Chart Library}
 * @description
 * Heatmaps are 2-dimensional arrays of data, rendered as a color-map on the chart. The {@link UniformHeatmapRenderableSeries}
 * assumes the cells are equal size, and spaced along the X,Y axis according to properties on the {@link UniformHeatmapDataSeries}.
 *
 * For a code sample how to initialize a uniform heatmap, see below
 *
 * ```ts
 * // Create an empty 2D array using the helper function zeroArray2D
 * const zValues: number[][] = zeroArray2D([height, width]);
 * // todo: fill the zValues 2d array with values
 *
 * // Create a UniformHeatmapDataSeries passing in zValues
 * const heatmapDataSeries = new UniformHeatmapDataSeries(wasmContext, 0, 1, 0, 1, zValues);
 *
 * // Create a Heatmap RenderableSeries with the color map. ColorMap.minimum/maximum defines the values in
 * // HeatmapDataSeries which correspond to gradient stops at 0..1
 * const heatmapSeries = new UniformHeatmapRenderableSeries(wasmContext, {
 *        dataSeries: heatmapDataSeries,
 *        colorMap: new HeatmapColorMap({
 *            minimum: 0,
 *           maximum: 200,
 *           gradientStops: [
 *               { offset: 0, color: "#00008B" },
 *               { offset: 0.2, color: "#6495ED" },
 *               { offset: 0.4, color: "#006400" },
 *               { offset: 0.6, color: "#7FFF00" },
 *               { offset: 0.8, color: "#FFFF00" },
 *               { offset: 1.0, color: "#FF0000" }
 *           ]
 *       })
 *   });
 *
 * // Add heatmap to the chart
 * sciChartSurface.renderableSeries.add(heatmapSeries);
 * ```
 */
class UniformHeatmapRenderableSeries extends BaseRenderableSeries_1.BaseRenderableSeries {
    /**
     * Creates an instance of the {@link UniformHeatmapRenderableSeries}
     * @param webAssemblyContext The {@link TSciChart | SciChart WebAssembly Context} containing
     * native methods and access to our WebGL2 WebAssembly Drawing Engine
     * @param options optional parameters of type {@link IHeatmapRenderableSeriesOptions} applied when constructing the series type
     */
    constructor(webAssemblyContext, options) {
        var _a, _b, _c;
        super(webAssemblyContext, options);
        this.type = SeriesType_1.ESeriesType.UniformHeatmapSeries;
        this.useLinearTextureFilteringProperty = false;
        this.colorMapPropertyChanged = this.colorMapPropertyChanged.bind(this);
        this.colorMap = options === null || options === void 0 ? void 0 : options.colorMap;
        this.dataSeries = options === null || options === void 0 ? void 0 : options.dataSeries;
        this.xAxisId = (_a = options === null || options === void 0 ? void 0 : options.xAxisId) !== null && _a !== void 0 ? _a : AxisCore_1.AxisCore.DEFAULT_AXIS_ID;
        this.xAxisId = (_b = options === null || options === void 0 ? void 0 : options.yAxisId) !== null && _b !== void 0 ? _b : AxisCore_1.AxisCore.DEFAULT_AXIS_ID;
        this.useLinearTextureFilteringProperty = (_c = options === null || options === void 0 ? void 0 : options.useLinearTextureFiltering) !== null && _c !== void 0 ? _c : this.useLinearTextureFilteringProperty;
        this.drawingProviders = [];
        this.drawingProviders.push(new UniformHeatmapDrawingProvider_1.UniformHeatmapDrawingProvider(webAssemblyContext, this));
    }
    /**
     * Gets or sets the {@link HeatmapColorMap}, which maps heatmap z-values to colors
     */
    get colorMap() {
        return this.colorMapProperty;
    }
    /**
     * Gets or sets the {@link HeatmapColorMap}, which maps heatmap z-values to colors
     */
    set colorMap(colorMap) {
        var _a, _b;
        (_a = this.colorMapProperty) === null || _a === void 0 ? void 0 : _a.propertyChanged.unsubscribe(this.colorMapPropertyChanged);
        this.colorMapProperty = colorMap;
        (_b = this.colorMapProperty) === null || _b === void 0 ? void 0 : _b.propertyChanged.subscribe(this.colorMapPropertyChanged);
        this.notifyPropertyChanged(constants_1.PROPERTY.COLOR_MAP);
    }
    /**
     * Gets or sets whether to make the heatmap linearly interpolated or smoothed between cells
     */
    get useLinearTextureFiltering() {
        return this.useLinearTextureFilteringProperty;
    }
    /**
     * Gets or sets whether to make the heatmap linearly interpolated or smoothed between cells
     */
    set useLinearTextureFiltering(value) {
        this.useLinearTextureFilteringProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.USE_LINEAR_TEXTURE_FILTERING);
    }
    /** @inheritDoc */
    checkIsOutOfDataRange(xValue, yValue) {
        const dataSeries = this.dataSeries;
        return (!dataSeries ||
            xValue <= dataSeries.xRange.min ||
            xValue >= dataSeries.xRange.max ||
            yValue <= dataSeries.yRange.min ||
            yValue >= dataSeries.yRange.max);
    }
    /**
     * Called when a property changes on {@link HeatmapColorMap}, and notifies the parent {@link SciChartSurface}
     * that a redraw is required.
     * @param args
     */
    colorMapPropertyChanged(args) {
        this.notifyPropertyChanged(exports.COLOR_MAP_PREFIX + args.propertyName);
    }
    /**
     * @inheritDoc
     */
    newHitTestProvider() {
        return new UniformHeatmapHitTestProvider_1.UniformHeatmapHitTestProvider(this);
    }
}
exports.UniformHeatmapRenderableSeries = UniformHeatmapRenderableSeries;
