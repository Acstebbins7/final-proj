"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FastOhlcRenderableSeries = void 0;
const Deleter_1 = require("../../../Core/Deleter");
const NumberRange_1 = require("../../../Core/NumberRange");
const SeriesType_1 = require("../../../types/SeriesType");
const IDataSeries_1 = require("../../Model/IDataSeries");
const defaultThemeColors_1 = require("../../Themes/defaultThemeColors");
const animationHelper_1 = require("./Animations/animationHelper");
const BaseRenderableSeries_1 = require("./BaseRenderableSeries");
const constants_1 = require("./constants");
const OhlcSeriesDrawingProvider_1 = require("./DrawingProviders/OhlcSeriesDrawingProvider");
const OhlcSeriesHitTestProvider_1 = require("./HitTest/OhlcSeriesHitTestProvider");
/**
 * Defines a JavaScript OHLC stock-chart eries in the SciChart's High Performance Real-time
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 * To add an OHLC series to a {@link SciChartSurface} you need to declare both the {@link FastOhlcRenderableSeries | RenderableSeries}
 * and a {@link OhlcDataSeries | OhlcDataSeries}. Simplified code sample below:
 *
 * ```ts
 * const sciChartSurface: SciChartSurface;
 * const wasmContext: TSciChart;
 * // Create and fill the dataseries
 * const dataSeries = new OhlcDataSeries(wasmContext);
 * dataSeries.append(dateValues, openValues, highValues, lowValues, closeValues);
 * // Create the renderableSeries
 * const ohlcSeries = new FastOhlcRenderableSeries(wasmContext);
 * ohlcSeries.dataSeries = dataSeries;
 * // append to the SciChartSurface
 * sciChartSurface.renderableSeries.add(ohlcSeries);
 * ```
 */
class FastOhlcRenderableSeries extends BaseRenderableSeries_1.BaseRenderableSeries {
    /**
     * Creates an instance of the {@link FastOhlcRenderableSeries}
     * @param webAssemblyContext The {@link TSciChart | SciChart WebAssembly Context} containing
     * native methods and access to our WebGL2 WebAssembly Drawing Engine
     * @param options optional parameters of type {@link IOhlcRenderableSeriesOptions} applied when constructing the series type
     */
    constructor(webAssemblyContext, options) {
        var _a;
        super(webAssemblyContext, options);
        this.type = SeriesType_1.ESeriesType.OhlcSeries;
        this.strokeUp = (options === null || options === void 0 ? void 0 : options.strokeUp) || defaultThemeColors_1.defaultThemeColors.upWickColor;
        this.strokeDown = (options === null || options === void 0 ? void 0 : options.strokeDown) || defaultThemeColors_1.defaultThemeColors.downWickColor;
        this.dataPointWidth = (options === null || options === void 0 ? void 0 : options.dataPointWidth) || 0.5;
        this.strokeThickness = (options === null || options === void 0 ? void 0 : options.strokeThickness) || 1;
        this.openAnimationValues = new webAssemblyContext.DoubleVector();
        this.highAnimationValues = new webAssemblyContext.DoubleVector();
        this.lowAnimationValues = new webAssemblyContext.DoubleVector();
        this.drawingProviders = [];
        this.drawingProviders.push(new OhlcSeriesDrawingProvider_1.OhlcSeriesDrawingProvider(webAssemblyContext, this, OhlcSeriesDrawingProvider_1.EOhlcDrawingMode.Ohlc));
        // This should be in the end after all DoubleVectors used for animation have been created
        this.animation = (_a = options === null || options === void 0 ? void 0 : options.animation) !== null && _a !== void 0 ? _a : this.animation;
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        super.applyTheme(themeProvider);
        const previousThemeProvider = this.parentSurface.previousThemeProvider;
        if (this.stroke === previousThemeProvider.lineSeriesColor) {
            this.stroke = themeProvider.lineSeriesColor;
        }
        if (this.strokeUp === previousThemeProvider.upWickColor) {
            this.strokeUp = themeProvider.upWickColor;
        }
        if (this.strokeDown === previousThemeProvider.downWickColor) {
            this.strokeDown = themeProvider.downWickColor;
        }
    }
    /**
     * Gets or sets the stoke when candlestick close is greater than open, as an HTML color code
     */
    get strokeUp() {
        return this.strokeUpProperty;
    }
    /**
     * Gets or sets the stoke when candlestick close is greater than open, as an HTML color code
     */
    set strokeUp(htmlColorCode) {
        this.strokeUpProperty = htmlColorCode;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE_UP);
    }
    /**
     * Gets or sets the stoke when candlestick close is less than open, as an HTML color code
     */
    get strokeDown() {
        return this.strokeDownProperty;
    }
    /**
     * Gets or sets the stoke when candlestick close is less than open, as an HTML color code
     */
    set strokeDown(htmlColorCode) {
        this.strokeDownProperty = htmlColorCode;
        this.notifyPropertyChanged(constants_1.PROPERTY.STROKE_DOWN);
    }
    /**
     * Gets or sets the width of candles as a fraction of available space. Valid values range from 0.0 - 1.0
     */
    get dataPointWidth() {
        return this.dataPointWidthProperty;
    }
    /**
     * Gets or sets the width of candles as a fraction of available space. Valid values range from 0.0 - 1.0
     */
    set dataPointWidth(value) {
        this.dataPointWidthProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.DATA_POINT_WIDTH);
    }
    /**
     * @inheritDoc
     */
    notifyPropertyChanged(propertyName) {
        super.notifyPropertyChanged(propertyName);
        if (propertyName === constants_1.PROPERTY.DATA_SERIES) {
            if (this.dataSeries !== undefined && this.dataSeries.type !== IDataSeries_1.EDataSeriesType.Ohlc) {
                throw new Error("DataSeries for Candlestick or Ohlc series must be type OhlcDataSeries");
            }
        }
    }
    /**
     * @inheritDoc
     */
    getXRange() {
        const range = super.getXRange();
        const count = this.dataSeries.count();
        if (count > 1) {
            const additionalValue = ((range.diff / (count - 1)) * this.dataPointWidth) / 2;
            return new NumberRange_1.NumberRange(range.min - additionalValue, range.max + additionalValue);
        }
        // TODO: figure out what to do if we have only one point
        return range;
    }
    /** @inheritDoc */
    delete() {
        this.openAnimationValues = Deleter_1.deleteSafe(this.openAnimationValues);
        this.highAnimationValues = Deleter_1.deleteSafe(this.highAnimationValues);
        this.lowAnimationValues = Deleter_1.deleteSafe(this.lowAnimationValues);
        super.delete();
    }
    /**
     * @inheritDoc
     */
    newHitTestProvider() {
        return new OhlcSeriesHitTestProvider_1.OhlcSeriesHitTestProvider(this);
    }
    /**
     * @inheritDoc
     */
    onAnimate(progress) {
        var _a;
        super.onAnimate(progress);
        const dataSeries = this.dataSeries;
        if (!dataSeries) {
            (_a = this.animationToken) === null || _a === void 0 ? void 0 : _a.cancelAnimation();
        }
        else {
            animationHelper_1.calculateAnimationValues(this.webAssemblyContext, dataSeries.getNativeOpenValues(), this.openAnimationValues, this.animation, progress);
            animationHelper_1.calculateAnimationValues(this.webAssemblyContext, dataSeries.getNativeHighValues(), this.highAnimationValues, this.animation, progress);
            animationHelper_1.calculateAnimationValues(this.webAssemblyContext, dataSeries.getNativeLowValues(), this.lowAnimationValues, this.animation, progress);
            animationHelper_1.calculateAnimationValues(this.webAssemblyContext, dataSeries.getNativeCloseValues(), this.yAnimationValues, this.animation, progress);
        }
    }
}
exports.FastOhlcRenderableSeries = FastOhlcRenderableSeries;
