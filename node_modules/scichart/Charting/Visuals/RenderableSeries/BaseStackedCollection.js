"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseStackedCollection = void 0;
const DoubleAnimator_1 = require("../../../Core/Animations/DoubleAnimator");
const EasingFunctions_1 = require("../../../Core/Animations/EasingFunctions");
const Deleter_1 = require("../../../Core/Deleter");
const ObservableArray_1 = require("../../../Core/ObservableArray");
const guid_1 = require("../../../utils/guid");
const AxisCore_1 = require("../Axis/AxisCore");
const animationHelper_1 = require("./Animations/animationHelper");
const constants_1 = require("./constants");
/**
 * A base class for stacked collections, which are used to create stacked mountain or column chart types.
 * Concrete types are {@link StackedColumnCollection} and {@link StackedMountainCollection}
 */
class BaseStackedCollection extends ObservableArray_1.ObservableArray {
    /**
     * Creates an instance of the {@link BaseStackedCollection}
     * @param webAssemblyContext The {@link TSciChart | SciChart WebAssembly Context} containing
     * native methods and access to our WebGL2 WebAssembly Drawing Engine
     */
    constructor(webAssemblyContext) {
        super();
        this.id = guid_1.generateGuid();
        this.isStacked = true;
        this.isSpline = false;
        this.isAccumulatedVectorDirty = true;
        this.isVisibleProperty = true;
        this.xAxisIdProperty = AxisCore_1.AxisCore.DEFAULT_AXIS_ID;
        this.yAxisIdProperty = AxisCore_1.AxisCore.DEFAULT_AXIS_ID;
        this.isOneHundredPercentProperty = false;
        this.isDelayPassed = false;
        this.firstAnimationRender = false;
        this.webAssemblyContext = webAssemblyContext;
        this.onAnimate = this.onAnimate.bind(this);
        this.notifyPropertyChanged = this.notifyPropertyChanged.bind(this);
        this.getParentSurface = this.getParentSurface.bind(this);
        this.afterAnimationComplete = this.afterAnimationComplete.bind(this);
        this.accumulatedVector0 = new this.webAssemblyContext.DoubleVector();
        this.accumulatedVectorAnimationValues0 = new this.webAssemblyContext.DoubleVector();
    }
    /** @inheritDoc */
    get isDigitalLine() {
        throw new Error("Setting or getting isDigitalLine is not supported for BaseStackedCollection");
    }
    /** @inheritDoc */
    set isDigitalLine(isDigitalLine) {
        throw new Error("Setting or getting isDigitalLine is not supported for BaseStackedCollection");
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        this.asArray().forEach(rs => {
            rs.applyTheme(themeProvider);
        });
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.accumulatedVector0 = Deleter_1.deleteSafe(this.accumulatedVector0);
        this.accumulatedVectorAnimationValues0 = Deleter_1.deleteSafe(this.accumulatedVectorAnimationValues0);
    }
    /**
     * @inheritDoc
     */
    notifyPropertyChanged(propertyName) {
        this.invalidateParent();
    }
    /**
     * @inheritDoc
     */
    getBaseXValues() {
        // TODO: find out do we need this method at all
        return [];
    }
    /**
     * @inheritDoc
     */
    getDataSeriesName() {
        // TODO: come up with some better name
        return "Stacked Collection";
    }
    /**
     * @inheritDoc
     */
    getDataSeriesValuesCount() {
        if (!this.getNativeXValues()) {
            return undefined;
        }
        return this.getNativeXValues().size();
    }
    /**
     * @inheritDoc
     */
    getNativeXValues() {
        var _a;
        if (this.size() === 0) {
            return undefined;
        }
        return (_a = this.get(0).dataSeries) === null || _a === void 0 ? void 0 : _a.getNativeXValues();
    }
    /**
     * @inheritDoc
     */
    hasDataSeries() {
        return !!this.getNativeXValues();
    }
    /**
     * @inheritDoc
     */
    hasStrokePaletteProvider() {
        // TODO: implement
        return false;
    }
    /**
     * @inheritDoc
     */
    hasFillPaletteProvider() {
        // TODO: implement
        return false;
    }
    /**
     * @inheritDoc
     */
    hasPointMarkerPaletteProvider() {
        // TODO: implement
        return false;
    }
    /**
     * @inheritDoc
     */
    onAttach(scs) {
        this.parentSurface = scs;
        if (this.invalidateParentCallback) {
            throw new Error("Invalid operation in sciChartSurface.attachSeries, this series has already been attached to a SciChartSurface. Please detach it from a SciChartSurface before attaching to another");
        }
        this.invalidateParentCallback = scs.invalidateElement;
    }
    /**
     * @inheritDoc
     */
    onDetach() {
        this.invalidateParentCallback = undefined;
        this.parentSurface = undefined;
        this.delete();
    }
    /**
     * Gets visible renderable series array
     */
    getVisibleSeries() {
        return this.asArray().filter(el => el.isVisible);
    }
    /**
     * @inheritDoc
     */
    get isVisible() {
        return this.isVisibleProperty;
    }
    /**
     * @inheritDoc
     */
    set isVisible(isVisible) {
        this.isVisibleProperty = isVisible;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_VISIBLE);
    }
    /**
     * @inheritDoc
     */
    get xAxis() {
        return this.parentSurface.xAxes.asArray().find(el => el.id === this.xAxisId);
    }
    /**
     * @inheritDoc
     */
    get xAxisId() {
        return this.xAxisIdProperty;
    }
    /**
     * @inheritDoc
     */
    set xAxisId(id) {
        this.xAxisIdProperty = id;
        this.notifyPropertyChanged(constants_1.PROPERTY.XAXIS_ID);
    }
    /**
     * @inheritDoc
     */
    get yAxis() {
        return this.parentSurface.yAxes.asArray().find(el => el.id === this.yAxisId);
    }
    /**
     * @inheritDoc
     */
    get yAxisId() {
        return this.yAxisIdProperty;
    }
    /**
     * @inheritDoc
     */
    set yAxisId(id) {
        this.yAxisIdProperty = id;
        this.notifyPropertyChanged(constants_1.PROPERTY.YAXIS_ID);
    }
    /**
     * Gets or sets 100% mode. When true, the stacked group becomes a 100% stacked chart
     */
    get isOneHundredPercent() {
        return this.isOneHundredPercentProperty;
    }
    /**
     * Gets or sets 100% mode. When true, the stacked group becomes a 100% stacked chart
     */
    set isOneHundredPercent(value) {
        this.isOneHundredPercentProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_ONE_HUNDRED_PERCENT);
    }
    /**
     * Gets a start up animation class, a child class for {@link BaseAnimation}
     */
    get animation() {
        return this.animationProperty;
    }
    /**
     * Sets a start up animation class, a child class for {@link BaseAnimation}
     */
    set animation(value) {
        this.animationProperty = value;
        this.firstAnimationRender = true;
        this.isDelayPassed = false;
        this.invalidateParent();
    }
    drawDelayTimer() {
        const delay = this.animationProperty.delay;
        if (!this.isDelayPassed && this.firstAnimationRender) {
            this.firstAnimationRender = false;
            setTimeout(() => {
                this.isDelayPassed = true;
                this.animate();
            }, delay);
        }
    }
    /**
     * Starts an animation for {@link IRenderableSeries}
     */
    animate() {
        if (!this.isAllDataSeriesSet() || !this.animationProperty || !this.isDelayPassed) {
            return undefined;
        }
        const durationMs = this.animation.duration;
        if (durationMs <= 0) {
            return undefined;
        }
        if (this.isRunningAnimation) {
            this.animationToken.cancelAnimation();
            this.afterAnimationComplete();
        }
        this.beforeAnimationStart();
        this.animationToken = DoubleAnimator_1.DoubleAnimator.animate(0, 1, durationMs, this.onAnimate, this.afterAnimationComplete, EasingFunctions_1.easing.linear);
    }
    /**
     * gets if the animation is currently running
     */
    get isRunningAnimation() {
        return !!this.animationToken;
    }
    /**
     * checkIsOutOfDataRange() is not supported for BaseStackedCollection
     * @param xValue
     * @param yValue
     */
    checkIsOutOfDataRange(xValue, yValue) {
        throw Error("checkIsOutOfDataRange() method is not supported for BaseStackedCollection");
    }
    // PROPERTIES END
    // Un-Supported PROPERTIES
    /**
     * dataSeries property is not supported for BaseStackedCollection
     */
    get dataSeries() {
        throw Error("dataSeries property is not supported for BaseStackedCollection");
    }
    /**
     * dataSeries property is not supported for BaseStackedCollection
     */
    set dataSeries(value) {
        throw Error("dataSeries property is not supported for BaseStackedCollection");
    }
    /**
     * drawNaNAs property is not supported for BaseStackedCollection
     */
    get drawNaNAs() {
        throw Error("drawNaNAs property is not supported for BaseStackedCollection");
    }
    /**
     * drawNaNAs property is not supported for BaseStackedCollection
     */
    set drawNaNAs(value) {
        throw Error("drawNaNAs property is not supported for BaseStackedCollection");
    }
    /**
     * drawingProviders property is not supported for BaseStackedCollection
     */
    get drawingProviders() {
        throw Error("drawingProviders property is not supported for BaseStackedCollection");
    }
    /**
     * drawingProviders property is not supported for BaseStackedCollection
     */
    set drawingProviders(value) {
        throw Error("drawingProviders property is not supported for BaseStackedCollection");
    }
    /**
     * hitTestProvider property is not supported for BaseStackedCollection
     */
    get hitTestProvider() {
        throw Error("hitTestProvider property is not supported for BaseStackedCollection");
    }
    /**
     * hitTestProvider property is not supported for BaseStackedCollection
     */
    set hitTestProvider(value) {
        throw Error("hitTestProvider property is not supported for BaseStackedCollection");
    }
    /**
     * paletteProvider property is not supported for BaseStackedCollection
     */
    get paletteProvider() {
        throw Error("paletteProvider property is not supported for BaseStackedCollection");
    }
    /**
     * paletteProvider property is not supported for BaseStackedCollection
     */
    set paletteProvider(value) {
        throw Error("paletteProvider property is not supported for BaseStackedCollection");
    }
    /**
     * pointMarker property is not supported for BaseStackedCollection
     */
    get pointMarker() {
        throw Error("pointMarker property is not supported for BaseStackedCollection");
    }
    /**
     * pointMarker property is not supported for BaseStackedCollection
     */
    set pointMarker(value) {
        throw Error("pointMarker property is not supported for BaseStackedCollection");
    }
    /**
     * rolloverModifierProps property is not supported for BaseStackedCollection
     */
    get rolloverModifierProps() {
        throw Error("rolloverModifierProps property is not supported for BaseStackedCollection");
    }
    /**
     * rolloverModifierProps property is not supported for BaseStackedCollection
     */
    set rolloverModifierProps(value) {
        throw Error("rolloverModifierProps property is not supported for BaseStackedCollection");
    }
    /**
     * stroke property is not supported for BaseStackedCollection
     */
    get stroke() {
        throw Error("stroke property is not supported for BaseStackedCollection");
    }
    /**
     * stroke property is not supported for BaseStackedCollection
     */
    set stroke(value) {
        throw Error("stroke property is not supported for BaseStackedCollection");
    }
    /**
     * strokeThickness property is not supported for BaseStackedCollection
     */
    get strokeThickness() {
        throw Error("strokeThickness property is not supported for BaseStackedCollection");
    }
    /**
     * strokeThickness property is not supported for BaseStackedCollection
     */
    set strokeThickness(value) {
        throw Error("strokeThickness property is not supported for BaseStackedCollection");
    }
    /**
     * effect property is not supported for BaseStackedCollection
     */
    get effect() {
        throw Error("effect property is not supported for BaseStackedCollection");
    }
    /**
     * effect property is not supported for BaseStackedCollection
     */
    set effect(effect) {
        throw Error("effect property is not supported for BaseStackedCollection");
    }
    /**
     * opacity property is not supported for BaseStackedCollection
     */
    get opacity() {
        throw Error("effect property is not supported for BaseStackedCollection");
    }
    /**
     * opacity property is not supported for BaseStackedCollection
     */
    set opacity(value) {
        throw Error("effect property is not supported for BaseStackedCollection");
    }
    /**
     * rolloverModifierProps1() is not supported for BaseStackedCollection
     */
    set rolloverModifierProps1(value) {
        throw Error("rolloverModifierProps1() method is not supported for BaseStackedCollection");
    }
    /**
     * rolloverModifierProps1() is not supported for BaseStackedCollection
     */
    get rolloverModifierProps1() {
        throw Error("rolloverModifierProps1() method is not supported for BaseStackedCollection");
    }
    // Un-Supported PROPERTIES END
    isAllDataSeriesSet() {
        let isDataSeriesSet = true;
        this.asArray().forEach(el => {
            if (!el.dataSeries) {
                isDataSeriesSet = false;
            }
        });
        return isDataSeriesSet;
    }
    /**
     * notifies listeners to {@link invalidateParentCallback} and redraws the {@link SciChartSurface}
     */
    invalidateParent() {
        if (this.invalidateParentCallback) {
            this.invalidateParentCallback();
        }
    }
    /**
     * Gets the first series in the collection, else undefined
     */
    getFirstSeries() {
        if (this.size() === 0) {
            return undefined;
        }
        return this.get(0);
    }
    /**
     * Gets the parent {@link SciChartSurface}
     */
    getParentSurface() {
        return this.parentSurface;
    }
    /**
     * Runs before the animation starts
     * @protected
     */
    beforeAnimationStart() {
        this.getVisibleSeries().forEach(rs => {
            rs.beforeAnimationStart();
        });
    }
    /**
     * Runs after the animation is complete
     * @protected
     */
    afterAnimationComplete() {
        this.getVisibleSeries().forEach(rs => {
            rs.afterAnimationComplete();
        });
    }
    /**
     * Internal method that runs on each animation tick
     * @param progress The current animation progress, a value from 0 to 1
     * @protected
     */
    onAnimate(progress) {
        var _a;
        if (!this.isAllDataSeriesSet()) {
            (_a = this.animationToken) === null || _a === void 0 ? void 0 : _a.cancelAnimation();
        }
        else {
            this.updateAccumulatedVectors();
            animationHelper_1.calculateAnimationValues(this.webAssemblyContext, this.accumulatedVector0, this.accumulatedVectorAnimationValues0, this.animation, progress);
            this.getVisibleSeries().forEach(rs => {
                rs.onAnimate(progress, this.animation);
            });
        }
        if (this.invalidateParentCallback) {
            this.invalidateParentCallback();
        }
    }
}
exports.BaseStackedCollection = BaseStackedCollection;
