"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackedColumnSeriesHitTestProvider = void 0;
const pointUtil_1 = require("../../../../utils/pointUtil");
const BaseHitTestProvider_1 = require("./BaseHitTestProvider");
/**
 * Hit-test provider for {@link StackedColumnRenderableSeries}. See base class {@link BaseHitTestProvider} for further info
 */
class StackedColumnSeriesHitTestProvider extends BaseHitTestProvider_1.BaseHitTestProvider {
    /**
     * @inheritDoc
     */
    getHitTestInfo(xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate) {
        const { xCoordinateCalculator, yCoordinateCalculator, isVerticalChart } = this.currentRenderPassData;
        const { type, dataSeries, accumulatedVector, getGroupIndex, getGroupsCount, getColumnWidth } = this.parentSeries;
        const hitTestInfo = BaseHitTestProvider_1.createNewHitTestInfo(xCoordinateCalculator, yCoordinateCalculator, isVerticalChart, type, dataSeries.type, dataSeries.getNativeXValues(), accumulatedVector, xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate);
        const groupIndex = getGroupIndex();
        const groupsCount = getGroupsCount();
        const columnWidth = getColumnWidth(xCoordinateCalculator);
        const halfWidth = columnWidth / 2;
        const coordShift = (0.5 + groupIndex - groupsCount / 2) * columnWidth;
        hitTestInfo.xValue = xCoordinateCalculator.getDataValue(hitTestInfo.xCoord + coordShift);
        const columnCenterX = hitTestInfo.xCoord + coordShift;
        hitTestInfo.isHit = pointUtil_1.testIsInBounds(xHitCoord, yHitCoord, columnCenterX - halfWidth, Number.MAX_VALUE, columnCenterX + halfWidth, Number.MIN_VALUE);
        // Hit-test on StackedColumnSeries returns Y accumulated, Y1 original
        hitTestInfo.y1Value = dataSeries.getNativeYValues().get(nearestPointIndex);
        return hitTestInfo;
    }
}
exports.StackedColumnSeriesHitTestProvider = StackedColumnSeriesHitTestProvider;
