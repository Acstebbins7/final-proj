"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHitTestInfo = exports.createNewHitTestInfo = exports.BaseHitTestProvider = void 0;
const Guard_1 = require("../../../../Core/Guard");
const Point_1 = require("../../../../Core/Point");
const pointUtil_1 = require("../../../../utils/pointUtil");
const translate_1 = require("../../../../utils/translate");
const HitTestInfo_1 = require("./HitTestInfo");
const IHitTestProvider_1 = require("./IHitTestProvider");
/**
 * Defines the base class to Hit-Test Providers: classes which performs hit-tests on series, returning data-values at X-Y mouse locations
 */
class BaseHitTestProvider {
    /**
     * Creates an instance of the {@link BaseHitTestProvider}
     * @param parentSeries the parent {@link IRenderableSeries | RenderableSeries} that this Hit-Test provider is attached to
     */
    constructor(parentSeries) {
        Guard_1.Guard.notNull(parentSeries, "parentSeries");
        this.parentSeries = parentSeries;
    }
    /**
     * @inheritDoc
     */
    update(renderPassData) {
        this.currentRenderPassData = renderPassData;
    }
    /**
     * @inheritDoc
     */
    hitTest(point, logic, hitTestRadius, interpolate) {
        if (!this.currentRenderPassData || !point) {
            return undefined;
        }
        const translatedPoint = translate_1.translateFromCanvasToSeriesViewRect(point, this.parentSeries.parentSurface.seriesViewRect);
        if (!translatedPoint) {
            return HitTestInfo_1.HitTestInfo.empty();
        }
        const { isVerticalChart } = this.currentRenderPassData;
        const xHitCoord = translatedPoint.x;
        const yHitCoord = translatedPoint.y;
        const nearestPointIndex = logic === IHitTestProvider_1.ENearestPointLogic.NearestPoint2D
            ? this.getNearestPoint2D(xHitCoord, yHitCoord)
            : this.getNearestHorizontalPoint(isVerticalChart ? yHitCoord : xHitCoord);
        return this.getHitTestInfo(xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate);
    }
    /**
     * @inheritDoc
     */
    getNearestPoint2D(xHitCoord, yHitCoord) {
        const { xCoordinateCalculator, yCoordinateCalculator, isVerticalChart } = this.currentRenderPassData;
        const { dataSeries } = this.parentSeries;
        const dataLength = dataSeries.count();
        // const xHitValue = xCoordinateCalculator.getDataValue(isVerticalChart ? yHitCoord : xHitCoord);
        // const yHitValue = yCoordinateCalculator.getDataValue(isVerticalChart ? xHitCoord : yHitCoord);
        // TODO: if isSorted
        let nearestPointIndex = -1;
        let currentDistance = Number.MAX_VALUE;
        const isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
        for (let i = 0; i < dataLength; i++) {
            const dataX = isCategoryAxis ? i : dataSeries.getNativeXValues().get(i);
            const dataY = dataSeries.getNativeYValues().get(i);
            const coordX = xCoordinateCalculator.getCoordinate(dataX);
            const coordY = yCoordinateCalculator.getCoordinate(dataY);
            const distance = pointUtil_1.calcDistance(xHitCoord, yHitCoord, coordX, coordY);
            // console.log(`Index: ${i}\r\n x1: ${xHitCoord},\r\n y1: ${yHitCoord},\r\n x2: ${coordX},\r\ny 2: ${coordY}\r\n Distance: ${distance}`);
            if (distance < currentDistance) {
                nearestPointIndex = i;
                currentDistance = distance;
            }
        }
        return nearestPointIndex;
    }
    /**
     * @inheritDoc
     */
    getNearestHorizontalPoint(xHitCoord) {
        // TODO: if sorted
        const { xCoordinateCalculator } = this.currentRenderPassData;
        const { dataSeries } = this.parentSeries;
        const xHitValue = xCoordinateCalculator.getDataValue(xHitCoord);
        const dataLength = dataSeries.count();
        let nearestPointIndex = -1;
        let currentDistance = Number.MAX_VALUE;
        const isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
        for (let i = 0; i < dataLength; i++) {
            const xValue = isCategoryAxis ? i : dataSeries.getNativeXValues().get(i);
            const distance = Math.abs(xHitValue - xValue);
            if (distance < currentDistance) {
                nearestPointIndex = i;
                currentDistance = distance;
            }
        }
        return nearestPointIndex;
    }
    /**
     * Creates a {@link HitTestInfo} instance from provided parameters
     * @param xHitCoord
     * @param yHitCoord
     * @param nearestPointIndex
     * @param hitTestRadius - not used
     * @param interpolate
     */
    createNewHitTestInfo(xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate) {
        const { xCoordinateCalculator, yCoordinateCalculator, isVerticalChart } = this.currentRenderPassData;
        const { type, dataSeries } = this.parentSeries;
        return exports.createNewHitTestInfo(xCoordinateCalculator, yCoordinateCalculator, isVerticalChart, type, dataSeries.type, dataSeries.getNativeXValues(), dataSeries.getNativeYValues(), xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate);
    }
    getHitTestInfo(xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate) {
        const { xCoordinateCalculator, yCoordinateCalculator, isVerticalChart } = this.currentRenderPassData;
        const { type, dataSeries } = this.parentSeries;
        return exports.getHitTestInfo(xCoordinateCalculator, yCoordinateCalculator, isVerticalChart, type, dataSeries.type, dataSeries.getNativeXValues(), dataSeries.getNativeYValues(), xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate);
    }
}
exports.BaseHitTestProvider = BaseHitTestProvider;
BaseHitTestProvider.DEFAULT_HIT_TEST_RADIUS = 7.07;
exports.createNewHitTestInfo = (xCoordinateCalculator, yCoordinateCalculator, isVerticalChart, renderableSeriesType, dataSeriesType, xNativeValues, yNativeValues, xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate) => {
    const isCategoryAxis = xCoordinateCalculator.isCategoryCoordinateCalculator;
    const xValue = isCategoryAxis ? nearestPointIndex : xNativeValues.get(nearestPointIndex);
    const yValue = yNativeValues.get(nearestPointIndex);
    const hitTestInfo = new HitTestInfo_1.HitTestInfo();
    hitTestInfo.dataSeriesName = renderableSeriesType;
    hitTestInfo.dataSeriesType = dataSeriesType;
    hitTestInfo.hitTestPoint = new Point_1.Point(xHitCoord, yHitCoord);
    const hitTestPointXValue = xCoordinateCalculator.getDataValue(isVerticalChart ? yHitCoord : xHitCoord);
    const hitTestPointYValue = yCoordinateCalculator.getDataValue(isVerticalChart ? xHitCoord : yHitCoord);
    hitTestInfo.hitTestPointValues = new Point_1.Point(hitTestPointXValue, hitTestPointYValue);
    hitTestInfo.dataSeriesIndex = nearestPointIndex;
    hitTestInfo.xCoord = xCoordinateCalculator.getCoordinate(xValue);
    hitTestInfo.yCoord = yCoordinateCalculator.getCoordinate(yValue);
    if (isVerticalChart) {
        const temp = hitTestInfo.xCoord;
        hitTestInfo.xCoord = hitTestInfo.yCoord;
        hitTestInfo.yCoord = temp;
    }
    hitTestInfo.xValue = xValue;
    if (isCategoryAxis) {
        hitTestInfo.xCategoryValue = xNativeValues.get(nearestPointIndex);
    }
    hitTestInfo.yValue = yValue;
    hitTestInfo.hitTestRadius = hitTestRadius;
    hitTestInfo.isHit = false;
    hitTestInfo.isCategoryAxis = isCategoryAxis;
    return hitTestInfo;
};
exports.getHitTestInfo = (xCoordinateCalculator, yCoordinateCalculator, isVerticalChart, renderableSeriesType, dataSeriesType, xNativeValues, yNativeValues, xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate) => {
    const hitTestInfo = exports.createNewHitTestInfo(xCoordinateCalculator, yCoordinateCalculator, isVerticalChart, renderableSeriesType, dataSeriesType, xNativeValues, yNativeValues, xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate);
    const dataSeriesCount = xNativeValues.size();
    const xValue = xNativeValues.get(nearestPointIndex);
    const yValue = yNativeValues.get(nearestPointIndex);
    const xPointValue = xCoordinateCalculator.getDataValue(isVerticalChart ? yHitCoord : xHitCoord);
    let xLeft, xRight, yLeft, yRight;
    if (xValue <= xPointValue) {
        if (nearestPointIndex + 1 <= dataSeriesCount - 1) {
            xLeft = xValue;
            yLeft = yValue;
            xRight = xNativeValues.get(nearestPointIndex + 1);
            yRight = yNativeValues.get(nearestPointIndex + 1);
        }
        else {
            // SCJS-566 Condition where click is to the right of the last point, compute distance on a single point
            const dataXCoord = xCoordinateCalculator.getCoordinate(xValue);
            const dataYCoord = yCoordinateCalculator.getCoordinate(yValue);
            const distance = pointUtil_1.calcDistance(xHitCoord, yHitCoord, dataXCoord, dataYCoord);
            hitTestInfo.isHit = distance < hitTestRadius;
            // console.log(`Index: ${nearestPointIndex}\r\n x1: ${xHitCoord},\r\n y1: ${yHitCoord},\r\n` +
            //  `x2: ${dataXCoord},\r\ny 2: ${dataYCoord}\r\n Distance: ${distance}`);
            return hitTestInfo;
        }
    }
    else {
        if (nearestPointIndex - 1 >= 0) {
            xLeft = xNativeValues.get(nearestPointIndex - 1);
            yLeft = yNativeValues.get(nearestPointIndex - 1);
            xRight = xValue;
            yRight = yValue;
        }
        else {
            // SCJS-566 Condition where click is to the left of the last point, compute distance on a single point
            const dataXCoord = xCoordinateCalculator.getCoordinate(xValue);
            const dataYCoord = yCoordinateCalculator.getCoordinate(yValue);
            hitTestInfo.isHit = pointUtil_1.calcDistance(xHitCoord, yHitCoord, dataXCoord, dataYCoord) < hitTestRadius;
            return hitTestInfo;
        }
    }
    const xLeftCoord = isVerticalChart
        ? yCoordinateCalculator.getCoordinate(yLeft)
        : xCoordinateCalculator.getCoordinate(xLeft);
    const xRightCoord = isVerticalChart
        ? yCoordinateCalculator.getCoordinate(yRight)
        : xCoordinateCalculator.getCoordinate(xRight);
    const yLeftCoord = isVerticalChart
        ? xCoordinateCalculator.getCoordinate(xLeft)
        : yCoordinateCalculator.getCoordinate(yLeft);
    const yRightCoord = isVerticalChart
        ? xCoordinateCalculator.getCoordinate(xRight)
        : yCoordinateCalculator.getCoordinate(yRight);
    hitTestInfo.isHit =
        pointUtil_1.calcDistanceFromLine(xHitCoord, yHitCoord, xLeftCoord, yLeftCoord, xRightCoord, yRightCoord) < hitTestRadius;
    return hitTestInfo;
};
