"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniformHeatmapHitTestProvider = void 0;
const Point_1 = require("../../../../Core/Point");
const translate_1 = require("../../../../utils/translate");
const BaseHitTestProvider_1 = require("./BaseHitTestProvider");
const HitTestInfo_1 = require("./HitTestInfo");
/**
 * Hit-test provider for {@link UniformHeatmapRenderableSeries}. See base class {@link BaseHitTestProvider} for further info
 */
class UniformHeatmapHitTestProvider extends BaseHitTestProvider_1.BaseHitTestProvider {
    /**
     * @inheritDoc
     */
    hitTest(point, logic, hitTestRadius, interpolate) {
        if (!this.currentRenderPassData || !point) {
            return undefined;
        }
        const translatedPoint = translate_1.translateFromCanvasToSeriesViewRect(point, this.parentSeries.parentSurface.seriesViewRect);
        if (!translatedPoint) {
            return HitTestInfo_1.HitTestInfo.empty();
        }
        const xHitCoord = translatedPoint.x;
        const yHitCoord = translatedPoint.y;
        const heatmapPoint = this.getNearestPointHeatmap(xHitCoord, yHitCoord);
        const { xIndex, yIndex, zValue } = heatmapPoint;
        return this.getHitTestInfoHeatmap(xHitCoord, yHitCoord, xIndex, yIndex, zValue);
    }
    getNearestPointHeatmap(xHitCoord, yHitCoord) {
        const { xCoordinateCalculator, yCoordinateCalculator, isVerticalChart } = this.currentRenderPassData;
        const heatmapDataSeries = this.parentSeries.dataSeries;
        const xHitValue = xCoordinateCalculator.getDataValue(isVerticalChart ? yHitCoord : xHitCoord);
        const yHitValue = yCoordinateCalculator.getDataValue(isVerticalChart ? xHitCoord : yHitCoord);
        const xIndex = Math.floor((xHitValue - heatmapDataSeries.xStart) / heatmapDataSeries.xStep);
        const yIndex = Math.floor((yHitValue - heatmapDataSeries.yStart) / heatmapDataSeries.yStep);
        if (xIndex < 0 ||
            xIndex >= heatmapDataSeries.arrayWidth ||
            yIndex < 0 ||
            yIndex >= heatmapDataSeries.arrayHeight) {
            return { xIndex: -1, yIndex: -1, zValue: undefined };
        }
        const zValue = heatmapDataSeries.getZValue(yIndex, xIndex);
        return { xIndex, yIndex, zValue };
    }
    getHitTestInfoHeatmap(xHitCoord, yHitCoord, xIndex, yIndex, zValue) {
        const { xCoordinateCalculator, yCoordinateCalculator, isVerticalChart } = this.currentRenderPassData;
        const { type, dataSeries } = this.parentSeries;
        const hitTestInfo = new HitTestInfo_1.HitTestInfo();
        hitTestInfo.dataSeriesName = type;
        hitTestInfo.dataSeriesType = dataSeries.type;
        hitTestInfo.hitTestPoint = new Point_1.Point(xHitCoord, yHitCoord);
        const hitTestPointXValue = xCoordinateCalculator.getDataValue(isVerticalChart ? yHitCoord : xHitCoord);
        const hitTestPointYValue = yCoordinateCalculator.getDataValue(isVerticalChart ? xHitCoord : yHitCoord);
        hitTestInfo.hitTestPointValues = new Point_1.Point(hitTestPointXValue, hitTestPointYValue);
        hitTestInfo.xValue = hitTestPointXValue;
        hitTestInfo.yValue = hitTestPointYValue;
        hitTestInfo.heatmapXIndex = xIndex;
        hitTestInfo.heatmapYIndex = yIndex;
        hitTestInfo.zValue = zValue;
        // TODO: set correct heatmapValue
        hitTestInfo.heatmapValue = zValue;
        // TODO maybe calculate coordinates of the cell center?
        hitTestInfo.xCoord = xHitCoord;
        hitTestInfo.yCoord = yHitCoord;
        hitTestInfo.isHit = (xIndex !== -1 && yIndex !== -1);
        return hitTestInfo;
    }
}
exports.UniformHeatmapHitTestProvider = UniformHeatmapHitTestProvider;
