"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColumnSeriesHitTestProvider = void 0;
const pointUtil_1 = require("../../../../utils/pointUtil");
const BaseHitTestProvider_1 = require("./BaseHitTestProvider");
/**
 * Hit-test provider for {@link FastColumnRenderableSeries}. See base class {@link BaseHitTestProvider} for further info
 */
class ColumnSeriesHitTestProvider extends BaseHitTestProvider_1.BaseHitTestProvider {
    /**
     * @inheritDoc
     */
    getNearestPoint2D(xHitCoord, yHitCoord) {
        const { xCoordinateCalculator, yCoordinateCalculator } = this.currentRenderPassData;
        const { dataSeries } = this.parentSeries;
        const dataLength = dataSeries.count();
        const xHitValue = xCoordinateCalculator.getDataValue(xHitCoord);
        const yHitValue = yCoordinateCalculator.getDataValue(yHitCoord);
        // TODO: if isSorted
        let nearestPointIndex = -1;
        let currentDistance = Number.MAX_VALUE;
        const { zeroLineY } = this.parentSeries;
        for (let i = 0; i < dataLength; i++) {
            const xValue = dataSeries.getNativeXValues().get(i);
            const yValue = dataSeries.getNativeYValues().get(i);
            const distance = yValue === zeroLineY
                ? pointUtil_1.calcDistance(xHitValue, yHitValue, xValue, yValue)
                : pointUtil_1.calcDistanceFromLine(xHitValue, yHitValue, xValue, yValue, xValue, zeroLineY);
            if (distance < currentDistance) {
                nearestPointIndex = i;
                currentDistance = distance;
            }
        }
        return nearestPointIndex;
    }
    /**
     * @inheritDoc
     */
    getHitTestInfo(xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate) {
        const hitTestInfo = this.createNewHitTestInfo(xHitCoord, yHitCoord, nearestPointIndex, hitTestRadius, interpolate);
        const { getDataPointWidth, dataPointWidth, zeroLineY } = this.parentSeries;
        const { xCoordinateCalculator, yCoordinateCalculator } = this.currentRenderPassData;
        const columnCenterX = hitTestInfo.xCoord;
        const columnCenterY = hitTestInfo.yCoord;
        const columnWidth = getDataPointWidth(xCoordinateCalculator, dataPointWidth);
        const zeroLineYCoord = yCoordinateCalculator.getCoordinate(zeroLineY);
        const halfWidth = columnWidth / 2;
        const topColumnSide = zeroLineYCoord > columnCenterY ? zeroLineYCoord : columnCenterY;
        const bottomColumnSide = zeroLineYCoord > columnCenterY ? columnCenterY : zeroLineYCoord;
        hitTestInfo.isHit = pointUtil_1.testIsInBounds(xHitCoord, yHitCoord, columnCenterX - halfWidth, topColumnSide, columnCenterX + halfWidth, bottomColumnSide);
        hitTestInfo.isWithinDataBounds = pointUtil_1.testIsInXBounds(xHitCoord, columnCenterX, halfWidth);
        return hitTestInfo;
    }
}
exports.ColumnSeriesHitTestProvider = ColumnSeriesHitTestProvider;
