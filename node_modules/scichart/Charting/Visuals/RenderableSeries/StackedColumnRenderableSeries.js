"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackedColumnRenderableSeries = void 0;
const Deleter_1 = require("../../../Core/Deleter");
const SeriesType_1 = require("../../../types/SeriesType");
const BrushCache_1 = require("../../Drawing/BrushCache");
const Pen2DCache_1 = require("../../Drawing/Pen2DCache");
const BaseStackedRenderableSeries_1 = require("./BaseStackedRenderableSeries");
const constants_1 = require("./constants");
const StackedColumnSeriesHitTestProvider_1 = require("./HitTest/StackedColumnSeriesHitTestProvider");
/**
 * @summary The {@link StackedColumnRenderableSeries} allows creating JavaScript Stacked Column charts, and 100% Stacked Column Charts
 * @description
 * Multiple {@link StackedColumnRenderableSeries} are required to create a stacked column chart type in SciChart.
 * These are grouped with a {@link StackedColumnCollection}, which implements {@link IRenderableSeries} and may be added
 * directly to a {@link SciChartSurface.renderableSeries} collection.
 *
 * Code sample below for stacking above and below (vertical stacking)
 * ```ts
 * const stackedColumn0 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn0.stackedGroupId = "group one"; // Same group ID means stack vertically
 * const stackedColumn1 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn1.stackedGroupId = "group one"; // Same group ID means stack vertically
 * const stackedColumn2 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn2.stackedGroupId = "group one"; // Same group ID means stack vertically
 * const stackedColumnCollection = new StackedColumnCollection(wasmContext);
 * stackedColumnCollection.add(stackedColumn0, stackedColumn1, stackedColumn2);
 *
 * sciChartSurface.renderableSeries.add(stackedColumnCollection);
 * ````
 *
 *  Code sample below for stacking side by side (horizontal stacking)
 * ```ts
 * const stackedColumn0 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn0.stackedGroupId = "group one"; // Different group ID means stack horizontally
 * const stackedColumn1 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn1.stackedGroupId = "group two"; // Different group ID means stack horizontally
 * const stackedColumn2 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn2.stackedGroupId = "group three"; // Different group ID means stack horizontally
 * const stackedColumnCollection = new StackedColumnCollection(wasmContext);
 * stackedColumnCollection.add(stackedColumn0, stackedColumn1, stackedColumn2);
 *
 * sciChartSurface.renderableSeries.add(stackedColumnCollection);
 * ````
 * @remarks
 * Do not add the {@link StackedColumnRenderableSeries} directly to {@link SciChartSurface.renderableSeries} array, instead,
 * use a {@link StackedColumnCollection} to group / stack the columns.
 */
class StackedColumnRenderableSeries extends BaseStackedRenderableSeries_1.BaseStackedRenderableSeries {
    /**
     * Creates an instance of the {@link StackedColumnRenderableSeries}
     * @param webAssemblyContext The {@link TSciChart | SciChart WebAssembly Context} containing
     * native methods and access to our WebGL2 WebAssembly Drawing Engine
     */
    constructor(webAssemblyContext) {
        super(webAssemblyContext);
        this.type = SeriesType_1.ESeriesType.StackedColumnSeries;
        this.fillProperty = "#7e8486";
        this.spacingProperty = 0;
        this.stackedGroupIdProperty = "default";
        this.getGroupIndex = this.getGroupIndex.bind(this);
        this.getGroupsCount = this.getGroupsCount.bind(this);
        this.getColumnWidth = this.getColumnWidth.bind(this);
        this.fillBrushCache = new BrushCache_1.BrushCache(webAssemblyContext);
        this.strokePenCache = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.stroke = "#000";
        this.strokeThickness = 1;
    }
    // PUBLIC
    /**
     * @inheritDoc
     */
    delete() {
        this.strokePenCache = Deleter_1.deleteSafe(this.strokePenCache);
        this.fillBrushCache = Deleter_1.deleteSafe(this.fillBrushCache);
        super.delete();
    }
    /**
     * Called internally when the {@link StackedColumnRenderableSeries} is attached to a parent {@link StackedColumnCollection}
     * @param parentCollection the parent {@link BaseStackedCollection}
     * @param getParentSurfaceFn function to get the parent {@link SciChartSurface}
     * @param notifyPropertyChangedFn function to notify property has changed
     * @param getColumnWidthFn function to get the column width
     */
    onAttachToParentCollection(parentCollection, getParentSurfaceFn, notifyPropertyChangedFn, getColumnWidthFn) {
        if (this.parentCollection) {
            throw new Error("Invalid operation in StackedColumnRenderableSeries.onAttachToParentCollection, this series has been already attached to collection. Please detach it from the collection before attaching to another");
        }
        this.parentCollection = parentCollection;
        this.getParentSurfaceFn = getParentSurfaceFn;
        this.notifyParentPropertyChangedFn = notifyPropertyChangedFn;
        this.getColumnWidthFn = getColumnWidthFn;
        const { stroke, strokeThickness, fill, opacity } = this;
        Pen2DCache_1.createPenInCache(this.strokePenCache, stroke, strokeThickness, opacity);
        BrushCache_1.createBrushInCache(this.fillBrushCache, fill, opacity);
    }
    /**
     * Gets the fill brush of the column as an HTML color code
     */
    getFillBrush() {
        return BrushCache_1.getScrtBrushFromCache(this.fillBrushCache);
    }
    /**
     * Gets the stroke of the column as an HTML color code
     */
    getStrokePen() {
        const { stroke, strokeThickness, fill, opacity } = this;
        return Pen2DCache_1.createPenInCache(this.strokePenCache, stroke, strokeThickness, opacity);
    }
    getGroupIndex() {
        return this.groupIndex;
    }
    setGroupIndex(value) {
        this.groupIndex = value;
    }
    getGroupsCount() {
        return this.groupsCount;
    }
    setGroupsCount(value) {
        this.groupsCount = value;
    }
    /**
     * Called internally - gets the column width in pixels
     * @param xCoordinateCalculator The current XAxis {@link CoordinateCalculatorBase}
     */
    getColumnWidth(xCoordinateCalculator) {
        return this.getColumnWidthFn(xCoordinateCalculator);
    }
    /**
     * @inheritDoc
     */
    notifyPropertyChanged(propertyName) {
        super.notifyPropertyChanged(propertyName);
        if (propertyName === constants_1.PROPERTY.STROKE ||
            propertyName === constants_1.PROPERTY.STROKE_THICKNESS ||
            propertyName === constants_1.PROPERTY.OPACITY) {
            Pen2DCache_1.createPenInCache(this.strokePenCache, this.stroke, this.strokeThickness, this.opacity);
        }
        if (propertyName === constants_1.PROPERTY.FILL || propertyName === constants_1.PROPERTY.OPACITY) {
            BrushCache_1.createBrushInCache(this.fillBrushCache, this.fill, this.opacity);
        }
    }
    // PROPERTIES
    /**
     * Gets or sets the Fill of the column chart as an HTML color code
     */
    get fill() {
        return this.fillProperty;
    }
    /**
     * Gets or sets the Fill of the column chart as an HTML color code
     */
    set fill(fill) {
        this.fillProperty = fill;
        this.notifyPropertyChanged(constants_1.PROPERTY.FILL);
    }
    // public get zeroLineY(): number {
    //     return this.zeroLineYProperty;
    // }
    // public set zeroLineY(zeroLineY: number) {
    //     this.zeroLineYProperty = zeroLineY;
    //     this.notifyPropertyChanged(PROPERTY.ZERO_LINE_Y);
    // }
    get spacing() {
        return this.spacingProperty;
    }
    set spacing(value) {
        this.spacingProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.SPACING);
    }
    /**
     * Gets or sets the Stacked Group ID
     * @description
     * The Stacked Group Id is used to group {@link StackedColumnRenderableSeries} inside a {@link StackedColumnCollection}
     * into vertical or horizontal stacked groups.
     *
     * For a normal stacked column chart (stacks vertically), set {@link StackedColumnRenderableSeries.stackedGroupId} inside a
     * {@link StackedColumnCollection} to the SAME value
     *
     * For a column chart (stacked side by side), set {@link StackedColumnRenderableSeries.stackedGroupId} inside a
     * {@link StackedColumnCollection} to DIFFERENT values
     */
    get stackedGroupId() {
        return this.stackedGroupIdProperty;
    }
    /**
     * Gets or sets the Stacked Group ID
     * @description
     * The Stacked Group Id is used to group {@link StackedColumnRenderableSeries} inside a {@link StackedColumnCollection}
     * into vertical or horizontal stacked groups.
     *
     * For a normal stacked column chart (stacks vertically), set {@link StackedColumnRenderableSeries.stackedGroupId} inside a
     * {@link StackedColumnCollection} to the SAME value
     *
     * For a column chart (stacked side by side), set {@link StackedColumnRenderableSeries.stackedGroupId} inside a
     * {@link StackedColumnCollection} to DIFFERENT values
     */
    set stackedGroupId(value) {
        this.stackedGroupIdProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.STACKED_GROUP_ID);
    }
    // PROPERTIES END
    // PROTECTED
    /**
     * @inheritDoc
     */
    newHitTestProvider() {
        return new StackedColumnSeriesHitTestProvider_1.StackedColumnSeriesHitTestProvider(this);
    }
}
exports.StackedColumnRenderableSeries = StackedColumnRenderableSeries;
