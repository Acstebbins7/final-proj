"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShaderEffect = void 0;
const app_1 = require("../../../constants/app");
const Deleter_1 = require("../../../Core/Deleter");
const EventHandler_1 = require("../../../Core/EventHandler");
const Guard_1 = require("../../../Core/Guard");
const Point_1 = require("../../../Core/Point");
const PropertyChangedEventArgs_1 = require("../../../Core/PropertyChangedEventArgs");
const parseColor_1 = require("../../../utils/parseColor");
const tsrExtensions_1 = require("../../../utils/tsrExtensions");
const constants_1 = require("./constants");
/**
 * A {@link ShaderEffect} can be applied to a {@link BaseRenderableSeries | RenderableSeries} via the
 * {@link BaseRenderableSeries.effect} property. The effect modifies the render output of the chart type.
 */
class ShaderEffect {
    /**
     * Creates an instance of the {@link ShaderEffect}
     * @param webAssemblyContext The {@link TSciChart | SciChart WebAssembly Context} containing
     * native methods and access to our WebGL2 WebAssembly Drawing Engine
     * @param seriesEffect The native {@link SCRTSeriesEffect} instance that provides the shader effect
     * @param options Optional parameters of type {@link IShaderEffectOptions} to configure the effect
     */
    constructor(webAssemblyContext, seriesEffect, options) {
        Guard_1.Guard.notNull(webAssemblyContext, "webAssemblyContext");
        if (!app_1.IS_TEST_ENV) {
            Guard_1.Guard.notNull(seriesEffect, "seriesEffect");
        }
        this.webAssemblyContext = webAssemblyContext;
        this.propertyChanged = new EventHandler_1.EventHandler();
        this.nativeEffect = seriesEffect;
        this.intensity = (options === null || options === void 0 ? void 0 : options.intensity) || 1;
        this.range = (options === null || options === void 0 ? void 0 : options.range) || 0;
        this.offset = (options === null || options === void 0 ? void 0 : options.offset) || new Point_1.Point(0, 0);
        this.color = (options === null || options === void 0 ? void 0 : options.color) || "#FFFFFF";
    }
    /**
     * Gets the native {@link SCRTSeriesEffect} which contains the shader effect that will be applied in WebGL
     */
    getNativeEffect() {
        return this.nativeEffect;
    }
    /**
     * Gets or sets the intensity property
     */
    get intensity() {
        return this.intensityProperty;
    }
    /**
     * Gets or sets the intensity property
     */
    set intensity(intensity) {
        this.intensityProperty = intensity;
        this.nativeEffect.SetIntensity(intensity);
        this.notifyPropertyChanged(constants_1.PROPERTY.INTENSITY);
    }
    /**
     * Gets or sets the offset property
     */
    get offset() {
        return this.offsetProperty;
    }
    /**
     * Gets or sets the offset property
     */
    set offset(offset) {
        Guard_1.Guard.notNull(offset, "offset");
        this.offsetProperty = offset;
        const tsrOffset = new this.webAssemblyContext.TSRVector2(offset.x, offset.y);
        this.nativeEffect.SetOffset(tsrOffset);
        this.notifyPropertyChanged(constants_1.PROPERTY.OFFSET);
    }
    /**
     * Gets or sets the color property as an HTML Color code
     */
    get color() {
        return this.colorProperty;
    }
    /**
     * Gets or sets the color property as an HTML Color code
     */
    set color(color) {
        this.colorProperty = color;
        const colorArgb = parseColor_1.parseColorToTArgb(color);
        const tsrVector4 = new this.webAssemblyContext.TSRVector4();
        tsrExtensions_1.toTsrVector4(colorArgb, tsrVector4);
        this.nativeEffect.SetColor(tsrVector4);
        Deleter_1.deleteSafe(tsrVector4);
        this.notifyPropertyChanged(constants_1.PROPERTY.COLOR);
    }
    /**
     * Gets or sets the range property
     */
    get range() {
        return this.rangeProperty;
    }
    /**
     * Gets or sets the range property
     */
    set range(range) {
        this.rangeProperty = range;
        this.nativeEffect.SetRange(range);
        this.notifyPropertyChanged(constants_1.PROPERTY.RANGE);
    }
    /**
     * Notifies subscribers to {@link propertyChanged} that a property has changed and the parent {@link SciChartSurface} needs to redraw
     * @param propertyName
     */
    notifyPropertyChanged(propertyName) {
        var _a;
        (_a = this.propertyChanged) === null || _a === void 0 ? void 0 : _a.raiseEvent(new PropertyChangedEventArgs_1.PropertyChangedEventArgs(propertyName));
    }
}
exports.ShaderEffect = ShaderEffect;
