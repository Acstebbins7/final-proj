import { NumberRange } from "../../../Core/NumberRange";
import { ESeriesType } from "../../../types/SeriesType";
import { TSciChart } from "../../../types/TSciChart";
import { WebGlRenderContext2D } from "../../Drawing/WebGlRenderContext2D";
import { CoordinateCalculatorBase } from "../../Numerics/CoordinateCalculators/CoordinateCalculatorBase";
import { RenderPassData } from "../../Services/RenderPassData";
import { SciChartSurface } from "../SciChartSurface";
import { BaseStackedCollection } from "./BaseStackedCollection";
import { StackedColumnRenderableSeries } from "./StackedColumnRenderableSeries";
/**
 * @summary A {@link StackedColumnCollection} allows grouping multiple {@link StackedColumnRenderableSeries}
 * to create a JavaScript Stacked Column, 100 Stacked Column or Stacked Bar chart
 * @description
 * Multiple {@link StackedColumnRenderableSeries} are required to create a stacked column chart type in SciChart.
 * These are grouped with a {@link StackedColumnCollection}, which implements {@link IRenderableSeries} and may be added
 * directly to a {@link SciChartSurface.renderableSeries} collection.
 *
 * Code sample below for stacking above and below (vertical stacking)
 * ```ts
 * const stackedColumn0 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn0.stackedGroupId = "group one"; // Same group ID means stack vertically
 * const stackedColumn1 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn1.stackedGroupId = "group one"; // Same group ID means stack vertically
 * const stackedColumn2 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn2.stackedGroupId = "group one"; // Same group ID means stack vertically
 * const stackedColumnCollection = new StackedColumnCollection(wasmContext);
 * stackedColumnCollection.add(stackedColumn0, stackedColumn1, stackedColumn2);
 *
 * sciChartSurface.renderableSeries.add(stackedColumnCollection);
 * ````
 *
 *  Code sample below for stacking side by side (horizontal stacking)
 * ```ts
 * const stackedColumn0 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn0.stackedGroupId = "group one"; // Different group ID means stack horizontally
 * const stackedColumn1 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn1.stackedGroupId = "group two"; // Different group ID means stack horizontally
 * const stackedColumn2 = new StackedColumnRenderableSeries(wasmContext);
 * stackedColumn2.stackedGroupId = "group three"; // Different group ID means stack horizontally
 * const stackedColumnCollection = new StackedColumnCollection(wasmContext);
 * stackedColumnCollection.add(stackedColumn0, stackedColumn1, stackedColumn2);
 *
 * sciChartSurface.renderableSeries.add(stackedColumnCollection);
 * ````
 * @remarks This type implements {@link IRenderableSeries} but it is not a renderable series, instead it wraps multiple
 * {@link StackedColumnRenderableSeries} to create a stacked column chart
 */
export declare class StackedColumnCollection extends BaseStackedCollection<StackedColumnRenderableSeries> {
    readonly type = ESeriesType.VerticallyStackedColumnCollection;
    private seriesGroups;
    private nativeDrawingProvider;
    private dataPointWidthProperty;
    private zeroLineYProperty;
    /**
     * Creates an instance of the {@link StackedColumnCollection}
     * @param webAssemblyContext The {@link TSciChart | SciChart WebAssembly Context} containing
     * native methods and access to our WebGL2 WebAssembly Drawing Engine
     */
    constructor(webAssemblyContext: TSciChart);
    /**
     * @inheritDoc
     */
    delete(): void;
    /**
     * @inheritDoc
     */
    updateAccumulatedVectors(): void;
    /**
     * @inheritDoc
     */
    draw(renderContext: WebGlRenderContext2D, renderPassData: RenderPassData): void;
    /**
     * @inheritDoc
     */
    getXRange(): NumberRange;
    /**
     * @inheritDoc
     */
    getYRange(xVisibleRange: NumberRange, isXCategoryAxis: boolean): NumberRange;
    /**
     * @inheritDoc
     */
    onAttach(scs: SciChartSurface): void;
    /**
     * @inheritDoc
     */
    notifyPropertyChanged(propertyName: string): void;
    /**
     * @inheritDoc
     */
    hasDataSeriesValues(): boolean;
    /**
     * Called internally - gets the column width in pixels
     * @param xCoordinateCalculator The current XAxis {@link CoordinateCalculatorBase}
     */
    getColumnWidth(xCoordinateCalculator: CoordinateCalculatorBase): number;
    /**
     * Gets or sets the Datapoint width, as a fraction of available space from 0.0 - 1.0
     */
    get dataPointWidth(): number;
    /**
     * Gets or sets the Datapoint width, as a fraction of available space from 0.0 - 1.0
     */
    set dataPointWidth(dataPointWidth: number);
    /**
     * Gets or sets the Zero-line Y, the Y-value where the mountain crosses zero and inverts. Default is 0
     */
    get zeroLineY(): number;
    /**
     * Gets or sets the Zero-line Y, the Y-value where the mountain crosses zero and inverts. Default is 0
     */
    set zeroLineY(zeroLineY: number);
    private detachChildSeries;
    private attachChildSeries;
    private isEnoughDataToDraw;
    private checkXValuesCorrect;
    /**
     * @param numberOfElements - number of element expected is used for performance to reserve memory
     */
    private clearAccumulatedVectors;
    private getLastVisibleSeries;
    private updateHitTestProviders;
    /**
     * @description Group series by stackedGroupId
     */
    private updateGroups;
    private getGroupsCount;
}
