"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OhlcSeriesDrawingProvider = exports.EOhlcDrawingMode = void 0;
const Deleter_1 = require("../../../../Core/Deleter");
const BrushCache_1 = require("../../../Drawing/BrushCache");
const Pen2DCache_1 = require("../../../Drawing/Pen2DCache");
const constants_1 = require("../constants");
const BaseSeriesDrawingProvider_1 = require("./BaseSeriesDrawingProvider");
var EOhlcDrawingMode;
(function (EOhlcDrawingMode) {
    EOhlcDrawingMode[EOhlcDrawingMode["Candles"] = 0] = "Candles";
    EOhlcDrawingMode[EOhlcDrawingMode["Ohlc"] = 1] = "Ohlc";
})(EOhlcDrawingMode = exports.EOhlcDrawingMode || (exports.EOhlcDrawingMode = {}));
/**
 * Used internally - a drawing provider performs drawing for a {@link FastOhlcRenderableSeries} using
 * our WebAssembly WebGL rendering engine
 */
class OhlcSeriesDrawingProvider extends BaseSeriesDrawingProvider_1.BaseSeriesDrawingProvider {
    /**
     * Creates an instance of the {@link OhlcSeriesDrawingProvider}
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param parentSeries the parent {@link FastOhlcRenderableSeries} which this drawing provider is attached to
     */
    constructor(webAssemblyContext, parentSeries, drawingMode) {
        super(webAssemblyContext, parentSeries);
        this.drawingMode = drawingMode;
        this.nativeDrawingProvider = new this.webAssemblyContext.SCRTCandlestickSeriesDrawingProvider();
        const { strokeThickness, strokeUp, strokeDown, opacity } = parentSeries;
        const candlestickSeries = parentSeries;
        this.strokeUpPenCache = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.strokeDownPenCache = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.brushUpCache = new BrushCache_1.BrushCache(webAssemblyContext);
        this.brushDownCache = new BrushCache_1.BrushCache(webAssemblyContext);
        Pen2DCache_1.createPenInCache(this.strokeUpPenCache, strokeUp, strokeThickness, opacity);
        Pen2DCache_1.createPenInCache(this.strokeDownPenCache, strokeDown, strokeThickness, opacity);
        if (candlestickSeries.brushUp) {
            BrushCache_1.createBrushInCache(this.brushUpCache, candlestickSeries.brushUp, opacity);
        }
        if (candlestickSeries.brushDown) {
            BrushCache_1.createBrushInCache(this.brushDownCache, candlestickSeries.brushDown, opacity);
        }
    }
    /**
     * @inheritDoc
     */
    onSeriesPropertyChange(propertyName) {
        super.onSeriesPropertyChange(propertyName);
        const { strokeThickness, strokeUp, strokeDown, opacity } = this.parentSeries;
        if (propertyName === constants_1.PROPERTY.STROKE_UP ||
            propertyName === constants_1.PROPERTY.STROKE_THICKNESS ||
            propertyName === constants_1.PROPERTY.OPACITY) {
            Pen2DCache_1.createPenInCache(this.strokeUpPenCache, strokeUp, strokeThickness, opacity);
        }
        if (propertyName === constants_1.PROPERTY.STROKE_DOWN ||
            propertyName === constants_1.PROPERTY.STROKE_THICKNESS ||
            propertyName === constants_1.PROPERTY.OPACITY) {
            Pen2DCache_1.createPenInCache(this.strokeDownPenCache, strokeDown, strokeThickness, opacity);
        }
        const candlestickSeries = this.parentSeries;
        if (propertyName === constants_1.PROPERTY.BRUSH_DOWN || propertyName === constants_1.PROPERTY.OPACITY) {
            BrushCache_1.createBrushInCache(this.brushDownCache, candlestickSeries === null || candlestickSeries === void 0 ? void 0 : candlestickSeries.brushDown, opacity);
        }
        if (propertyName === constants_1.PROPERTY.BRUSH_UP || propertyName === constants_1.PROPERTY.OPACITY) {
            BrushCache_1.createBrushInCache(this.brushUpCache, candlestickSeries === null || candlestickSeries === void 0 ? void 0 : candlestickSeries.brushUp, opacity);
        }
    }
    /**
     * @inheritDoc
     */
    draw(renderContext, renderPassData) {
        const args = new this.webAssemblyContext.SCRTOhlcDrawingParams();
        try {
            // Candles only requires brush up, down
            if (this.drawingMode === EOhlcDrawingMode.Candles) {
                const brushUp = BrushCache_1.getScrtBrushFromCache(this.brushUpCache);
                const brushDown = BrushCache_1.getScrtBrushFromCache(this.brushDownCache);
                if (!brushUp || !brushDown) {
                    return;
                }
                args.SetBrushes(brushUp, brushDown);
            }
            const strokeUpPen = Pen2DCache_1.getScrtPenFromCache(this.strokeUpPenCache);
            const strokeDownPen = Pen2DCache_1.getScrtPenFromCache(this.strokeDownPenCache);
            // Ohlc and candle both require stroke up, down
            if (!strokeUpPen || !strokeDownPen) {
                return;
            }
            args.SetPens(strokeUpPen, strokeDownPen);
            // Paletting per point
            const neutralColor = "#ffffffff";
            super.applyStrokeFillPaletting(neutralColor, undefined, neutralColor, undefined, this.parentSeries.opacity);
            args.SetPalettedColors(this.palettingState.palettedColors);
            args.forceShaderMethod = true;
            args.verticalChart = renderPassData.isVerticalChart;
            args.candleWidth = this.parentSeries.getDataPointWidth(renderPassData.xCoordinateCalculator, this.parentSeries.dataPointWidth);
            args.drawAsOhlc = this.drawingMode === EOhlcDrawingMode.Ohlc;
            const nativeContext = renderContext.getNativeContext();
            const viewRect = this.parentSeries.parentSurface.seriesViewRect;
            // TODO: We need to get truncated pointseries out (viewport culling) for efficient drawing of large datasets
            const dataSeries = this.parentSeries.dataSeries;
            const isCategoryAxis = renderPassData.xCoordinateCalculator.isCategoryCoordinateCalculator;
            const xValues = dataSeries.getNativeXValues();
            let openValues;
            let highValues;
            let lowValues;
            let closeValues;
            if (this.parentSeries.isRunningAnimation) {
                openValues = this.parentSeries.openAnimationValues;
                highValues = this.parentSeries.highAnimationValues;
                lowValues = this.parentSeries.lowAnimationValues;
                closeValues = this.parentSeries.yAnimationValues;
            }
            else {
                openValues = dataSeries.getNativeOpenValues();
                highValues = dataSeries.getNativeHighValues();
                lowValues = dataSeries.getNativeLowValues();
                closeValues = dataSeries.getNativeCloseValues();
            }
            args.count = closeValues.size();
            nativeContext.PushMatrix();
            nativeContext.PushState();
            nativeContext.Translate(viewRect.x, viewRect.y);
            nativeContext.SetClipRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
            this.nativeDrawingProvider.DrawPointsVec(nativeContext, isCategoryAxis ? dataSeries.getNativeIndexes() : xValues, openValues, highValues, lowValues, closeValues, renderPassData.xCoordinateCalculator.nativeCalculator, renderPassData.yCoordinateCalculator.nativeCalculator, args);
            nativeContext.PopMatrix();
            nativeContext.PopState();
        }
        finally {
            args.delete();
        }
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.strokeDownPenCache = Deleter_1.deleteSafe(this.strokeDownPenCache);
        this.strokeUpPenCache = Deleter_1.deleteSafe(this.strokeUpPenCache);
        this.brushUpCache = Deleter_1.deleteSafe(this.brushUpCache);
        this.brushDownCache = Deleter_1.deleteSafe(this.brushDownCache);
        this.nativeDrawingProvider = Deleter_1.deleteSafe(this.nativeDrawingProvider);
        super.delete();
    }
}
exports.OhlcSeriesDrawingProvider = OhlcSeriesDrawingProvider;
