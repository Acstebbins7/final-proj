"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColumnSeriesDrawingProvider = void 0;
const Deleter_1 = require("../../../../Core/Deleter");
const BrushCache_1 = require("../../../Drawing/BrushCache");
const Pen2DCache_1 = require("../../../Drawing/Pen2DCache");
const constants_1 = require("../constants");
const BaseSeriesDrawingProvider_1 = require("./BaseSeriesDrawingProvider");
/**
 * Used internally - a drawing provider performs drawing for a {@link FastColumnRenderableSeries} using
 * our WebAssembly WebGL rendering engine
 */
class ColumnSeriesDrawingProvider extends BaseSeriesDrawingProvider_1.BaseSeriesDrawingProvider {
    /**
     * Creates an instance of the {@link ColumnSeriesDrawingProvider}
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param parentSeries the parent {@link FastColumnRenderableSeries} which this drawing provider is attached to
     */
    constructor(webAssemblyContext, parentSeries) {
        super(webAssemblyContext, parentSeries);
        this.nativeDrawingProvider = new webAssemblyContext.SCRTColumnSeriesDrawingProvider();
        this.strokePenCache = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.fillBrushCache = new BrushCache_1.BrushCache(webAssemblyContext);
        const { stroke, strokeThickness, fill, opacity } = this.parentSeries;
        Pen2DCache_1.createPenInCache(this.strokePenCache, stroke, strokeThickness, opacity);
        BrushCache_1.createBrushInCache(this.fillBrushCache, fill, opacity);
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.nativeDrawingProvider = Deleter_1.deleteSafe(this.nativeDrawingProvider);
        this.strokePenCache = Deleter_1.deleteSafe(this.strokePenCache);
        this.fillBrushCache = Deleter_1.deleteSafe(this.fillBrushCache);
        super.delete();
    }
    /**
     * @inheritDoc
     */
    draw(renderContext, renderPassData) {
        // TODO: We need to get truncated pointseries out (viewport culling) for efficient drawing of large datasets
        const dataSeries = this.parentSeries.dataSeries;
        const viewRect = this.parentSeries.parentSurface.seriesViewRect;
        const args = new this.webAssemblyContext.SCRTColumnDrawingParams();
        args.forceShaderMethod = true;
        args.verticalChart = renderPassData.isVerticalChart;
        args.zeroLineY = this.parentSeries.zeroLineY;
        args.columnWidth = this.parentSeries.getDataPointWidth(renderPassData.xCoordinateCalculator, this.parentSeries.dataPointWidth);
        args.viewportWidth = viewRect.width;
        args.viewportHeight = viewRect.height;
        const fillBrush = BrushCache_1.getScrtBrushFromCache(this.fillBrushCache);
        if (fillBrush) {
            args.SetFillBrush(fillBrush);
        }
        const linesPen = Pen2DCache_1.getScrtPenFromCache(this.strokePenCache);
        if (linesPen) {
            args.SetLinesPen(linesPen);
        }
        // Paletting per point
        super.applyStrokeFillPaletting(this.parentSeries.stroke, linesPen, this.parentSeries.fill, fillBrush, this.parentSeries.opacity);
        args.SetPalettedColors(this.palettingState.palettedColors);
        const isCategoryAxis = renderPassData.xCoordinateCalculator.isCategoryCoordinateCalculator;
        const { isRunningAnimation } = this.parentSeries;
        const xValues = dataSeries.getNativeXValues();
        let yValues;
        if (isRunningAnimation) {
            yValues = this.parentSeries.yAnimationValues;
        }
        else {
            yValues = dataSeries.getNativeYValues();
        }
        args.count = yValues.size();
        const nativeContext = renderContext.getNativeContext();
        nativeContext.PushMatrix();
        nativeContext.PushState();
        nativeContext.Translate(viewRect.x, viewRect.y);
        nativeContext.SetClipRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
        this.nativeDrawingProvider.DrawPointsVec(nativeContext, isCategoryAxis ? dataSeries.getNativeIndexes() : xValues, yValues, renderPassData.xCoordinateCalculator.nativeCalculator, renderPassData.yCoordinateCalculator.nativeCalculator, args);
        nativeContext.PopMatrix();
        nativeContext.PopState();
        args.delete();
    }
    /**
     * @inheritDoc
     */
    onSeriesPropertyChange(propertyName) {
        super.onSeriesPropertyChange(propertyName);
        if (propertyName === constants_1.PROPERTY.STROKE ||
            propertyName === constants_1.PROPERTY.STROKE_THICKNESS ||
            propertyName === constants_1.PROPERTY.OPACITY) {
            const { stroke, strokeThickness, opacity } = this.parentSeries;
            Pen2DCache_1.createPenInCache(this.strokePenCache, stroke, strokeThickness, opacity);
        }
        if (propertyName === constants_1.PROPERTY.FILL || propertyName === constants_1.PROPERTY.OPACITY) {
            const { fill, opacity } = this.parentSeries;
            BrushCache_1.createBrushInCache(this.fillBrushCache, fill, opacity);
        }
    }
}
exports.ColumnSeriesDrawingProvider = ColumnSeriesDrawingProvider;
