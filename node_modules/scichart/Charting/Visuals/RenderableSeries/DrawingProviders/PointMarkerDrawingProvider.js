"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PointMarkerDrawingProvider = void 0;
const Deleter_1 = require("../../../../Core/Deleter");
const BaseSeriesDrawingProvider_1 = require("./BaseSeriesDrawingProvider");
/**
 * Used internally - a drawing provider performs drawing for a {@link IRenderableSeries | Renderable Series} which draw a
 * point-marker using our WebAssembly WebGL rendering engine
 */
class PointMarkerDrawingProvider extends BaseSeriesDrawingProvider_1.BaseSeriesDrawingProvider {
    /**
     * Creates an instance of the {@link PointMarkerDrawingProvider}
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param parentSeries the parent {@link IRenderableSeries} which this drawing provider is attached to
     * @param ySelector an optional Y-selector for choosing which y-values to use for drawing points
     * @param yAnimationSelector an optional selector for choosing which y-animation values to use for drawing points
     */
    constructor(webAssemblyContext, parentSeries, ySelector, yAnimationSelector) {
        super(webAssemblyContext, parentSeries);
        this.ySelector = ySelector === undefined ? ds => ds.getNativeYValues() : ySelector;
        this.yAnimationValuesSelector =
            yAnimationSelector === undefined ? rs => rs.yAnimationValues : yAnimationSelector;
        this.nativeDrawingProvider = new this.webAssemblyContext.SCRTScatterSeriesDrawingProvider();
        this.yAnimationValuesDP = new this.webAssemblyContext.DoubleVector();
    }
    /**
     * @inheritDoc
     */
    onSeriesPropertyChange(propertyName) {
        // Deliberately empty
    }
    /**
     * @inheritDoc
     */
    draw(renderContext, renderPassData) {
        const pointMarker = this.parentSeries.pointMarker;
        if (pointMarker === undefined) {
            return;
        }
        let spriteTexture, strokeMaskTexture;
        if (this.parentSeries.hasPointMarkerPaletteProvider()) {
            spriteTexture = pointMarker.getFillMask();
            strokeMaskTexture = pointMarker.getStrokeMask();
        }
        else {
            spriteTexture = pointMarker.getSprite();
            strokeMaskTexture = undefined;
        }
        const dataSeries = this.parentSeries.dataSeries;
        const args = new this.webAssemblyContext.SCRTPointDrawingParams();
        const isCategoryAxis = renderPassData.xCoordinateCalculator.isCategoryCoordinateCalculator;
        const xValues = dataSeries.getNativeXValues();
        let yValues;
        const parentSeries = this.parentSeries;
        const { isRunningAnimation } = parentSeries;
        if (isRunningAnimation) {
            const yAnimationValues = this.yAnimationValuesSelector(parentSeries);
            if (this.parentSeries.isSpline && yAnimationValues.size() > 0) {
                const splineSeries = parentSeries;
                yValues = this.updateAnimationValues(xValues.size(), yAnimationValues, splineSeries.interpolationPoints);
            }
            else {
                yValues = yAnimationValues;
            }
        }
        else {
            yValues = this.ySelector(dataSeries);
        }
        args.count = yValues.size();
        args.verticalChart = renderPassData.isVerticalChart;
        args.forceShaderMethod = true;
        args.SetSpriteTexture(spriteTexture.getTexture());
        if (strokeMaskTexture) {
            args.SetStrokeMask(strokeMaskTexture.getTexture());
        }
        // Paletting per point
        super.applyStrokeFillPaletting(pointMarker.stroke, undefined, pointMarker.fill, undefined, this.parentSeries.opacity);
        args.SetPalettedColors(this.palettingState.palettedColors);
        const nativeContext = renderContext.getNativeContext();
        this.drawPoints(nativeContext, isCategoryAxis ? dataSeries.getNativeIndexes() : xValues, yValues, renderPassData.xCoordinateCalculator.nativeCalculator, renderPassData.yCoordinateCalculator.nativeCalculator, args, this.parentSeries.parentSurface.seriesViewRect);
        args.delete();
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.nativeDrawingProvider = Deleter_1.deleteSafe(this.nativeDrawingProvider);
        this.yAnimationValuesDP = Deleter_1.deleteSafe(this.yAnimationValuesDP);
        super.delete();
    }
    drawPoints(nativeContext, xValues, yValues, xCoordCalc, yCoordCalc, args, viewRect) {
        nativeContext.PushMatrix();
        nativeContext.PushState();
        nativeContext.Translate(viewRect.x, viewRect.y);
        nativeContext.SetClipRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
        this.nativeDrawingProvider.DrawPointsVec(nativeContext, xValues, yValues, xCoordCalc, yCoordCalc, args);
        nativeContext.PopMatrix();
        nativeContext.PopState();
    }
    updateAnimationValues(size, yAnimationValues, interpolationPoints) {
        this.yAnimationValuesDP.resize(size, 0);
        for (let i = 0; i < size - 1; i++) {
            const element = yAnimationValues.get((interpolationPoints + 1) * i);
            this.yAnimationValuesDP.set(i, element);
        }
        const lastIndex = yAnimationValues.size() - 1;
        this.yAnimationValuesDP.set(size - 1, yAnimationValues.get(lastIndex));
        return this.yAnimationValuesDP;
    }
}
exports.PointMarkerDrawingProvider = PointMarkerDrawingProvider;
