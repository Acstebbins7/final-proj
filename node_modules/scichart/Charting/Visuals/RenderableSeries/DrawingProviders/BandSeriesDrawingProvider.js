"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BandSeriesDrawingProvider = void 0;
const Deleter_1 = require("../../../../Core/Deleter");
const SeriesType_1 = require("../../../../types/SeriesType");
const Pen2DCache_1 = require("../../../Drawing/Pen2DCache");
const BrushCache_1 = require("../../../Drawing/BrushCache");
const WebGlRenderContext2D_1 = require("../../../Drawing/WebGlRenderContext2D");
const constants_1 = require("../constants");
const BaseSeriesDrawingProvider_1 = require("./BaseSeriesDrawingProvider");
/**
 * Used internally - a drawing provider performs drawing for a {@link BaseBandRenderableSeries} using
 * our WebAssembly WebGL rendering engine
 */
class BandSeriesDrawingProvider extends BaseSeriesDrawingProvider_1.BaseSeriesDrawingProvider {
    /**
     * Creates an instance of the {@link BandSeriesDrawingProvider}
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param parentSeries the parent {@link BaseBandRenderableSeries} which this drawing provider is attached to
     */
    constructor(webAssemblyContext, parentSeries) {
        super(webAssemblyContext, parentSeries);
        this.linesPenCache = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.strokePenY1Cache = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.fillBrushCache = new BrushCache_1.BrushCache(webAssemblyContext);
        this.fillBrushY1Cache = new BrushCache_1.BrushCache(webAssemblyContext);
    }
    /**
     * @inheritDoc
     */
    onAttachSeries() {
        super.onAttachSeries();
        this.nativeDrawingProvider = new this.webAssemblyContext.SCRTBandSeriesDrawingProvider();
        const { stroke, strokeThickness, fill, strokeY1, fillY1, opacity, strokeDashArray, strokeY1DashArray } = this.parentSeries;
        Pen2DCache_1.createPenInCache(this.linesPenCache, stroke, strokeThickness, opacity, strokeDashArray);
        Pen2DCache_1.createPenInCache(this.strokePenY1Cache, strokeY1, strokeThickness, opacity, strokeY1DashArray);
        BrushCache_1.createBrushInCache(this.fillBrushCache, fill, opacity);
        BrushCache_1.createBrushInCache(this.fillBrushY1Cache, fillY1, opacity);
    }
    /**
     * @inheritDoc
     */
    onDetachSeries() {
        super.onDetachSeries();
        this.delete();
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.nativeDrawingProvider = Deleter_1.deleteSafe(this.nativeDrawingProvider);
        this.linesPenCache = Deleter_1.deleteSafe(this.linesPenCache);
        this.fillBrushCache = Deleter_1.deleteSafe(this.fillBrushCache);
        this.strokePenY1Cache = Deleter_1.deleteSafe(this.strokePenY1Cache);
        this.fillBrushY1Cache = Deleter_1.deleteSafe(this.fillBrushY1Cache);
        super.delete();
    }
    /**
     * @inheritDoc
     */
    draw(renderContext, renderPassData) {
        var _a;
        const dataSeries = this.parentSeries.dataSeries;
        const args = new this.webAssemblyContext.SCRTBandDrawingParams();
        args.forceShaderMethod = true;
        args.verticalChart = renderPassData.isVerticalChart;
        args.lineGaps = dataSeries.containsNaN
            ? this.parentSeries.drawNaNAs === WebGlRenderContext2D_1.ELineDrawMode.DiscontinuousLine
                ? this.webAssemblyContext.SCRTLineGapMode.DrawGaps
                : this.webAssemblyContext.SCRTLineGapMode.CloseGaps
            : this.webAssemblyContext.SCRTLineGapMode.Default;
        args.isDigitalLine = this.parentSeries.isDigitalLine;
        const fillBrush = BrushCache_1.getScrtBrushFromCache(this.fillBrushCache);
        if (fillBrush) {
            args.SetFillBrush(fillBrush);
        }
        const linesPen = Pen2DCache_1.getScrtPenFromCache(this.linesPenCache);
        if (linesPen) {
            args.SetLinesPen(linesPen);
        }
        const fillBrushY1 = BrushCache_1.getScrtBrushFromCache(this.fillBrushY1Cache);
        if (fillBrushY1) {
            args.SetFillBrush1(fillBrushY1);
        }
        const strokePenY1 = Pen2DCache_1.getScrtPenFromCache(this.strokePenY1Cache);
        if (strokePenY1) {
            args.SetLinesPen1(strokePenY1);
        }
        const isCategoryAxis = renderPassData.xCoordinateCalculator.isCategoryCoordinateCalculator;
        const xValues = dataSeries.getNativeXValues();
        let xDrawValues;
        let yDrawValues;
        let y1DrawValues;
        const { isRunningAnimation } = this.parentSeries;
        const isSplineBandSeries = this.parentSeries.type === SeriesType_1.ESeriesType.SplineBandSeries && xValues.size() > 1;
        if (isSplineBandSeries) {
            const splineBandSeries = this.parentSeries;
            if (!isRunningAnimation) {
                splineBandSeries.updateSplineValues();
            }
            xDrawValues = splineBandSeries.xSplineValues;
            yDrawValues = isRunningAnimation ? splineBandSeries.yAnimationValues : splineBandSeries.ySplineValues;
            y1DrawValues = isRunningAnimation ? splineBandSeries.y1AnimationValues : splineBandSeries.y1SplineValues;
        }
        else {
            xDrawValues = isCategoryAxis ? dataSeries.getNativeIndexes() : xValues;
            yDrawValues = isRunningAnimation ? this.parentSeries.yAnimationValues : dataSeries.getNativeYValues();
            y1DrawValues = isRunningAnimation ? this.parentSeries.y1AnimationValues : dataSeries.getNativeY1Values();
        }
        args.count = yDrawValues.size();
        // Paletting per point
        super.applyStrokeFillPaletting(undefined, undefined, undefined, undefined, undefined, true);
        const paletteTexture = (_a = this.palettingState.paletteTextureCache) === null || _a === void 0 ? void 0 : _a.value;
        if (paletteTexture) {
            args.SetPalette(paletteTexture);
        }
        args.isSmoothColors = this.palettingState.gradientPaletting;
        const nativeContext = renderContext.getNativeContext();
        const viewRect = this.parentSeries.parentSurface.seriesViewRect;
        nativeContext.PushMatrix();
        nativeContext.PushState();
        nativeContext.Translate(viewRect.x, viewRect.y);
        nativeContext.SetClipRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
        this.nativeDrawingProvider.DrawPointsVec(nativeContext, xDrawValues, yDrawValues, y1DrawValues, renderPassData.xCoordinateCalculator.nativeCalculator, renderPassData.yCoordinateCalculator.nativeCalculator, args);
        nativeContext.PopMatrix();
        nativeContext.PopState();
        args.delete();
    }
    /**
     * @inheritDoc
     */
    onSeriesPropertyChange(propertyName) {
        super.onSeriesPropertyChange(propertyName);
        const { stroke, strokeY1, strokeThickness, fill, fillY1, opacity, strokeDashArray, strokeY1DashArray } = this.parentSeries;
        if (propertyName === constants_1.PROPERTY.STROKE ||
            propertyName === constants_1.PROPERTY.STROKE_THICKNESS ||
            propertyName === constants_1.PROPERTY.OPACITY ||
            propertyName === constants_1.PROPERTY.STROKE_DASH_ARRAY) {
            Pen2DCache_1.createPenInCache(this.linesPenCache, stroke, strokeThickness, opacity, strokeDashArray);
        }
        if (propertyName === constants_1.PROPERTY.STROKE_Y1 ||
            propertyName === constants_1.PROPERTY.STROKE_THICKNESS ||
            propertyName === constants_1.PROPERTY.OPACITY ||
            propertyName === constants_1.PROPERTY.STROKE_Y1_DASH_ARRAY) {
            Pen2DCache_1.createPenInCache(this.strokePenY1Cache, strokeY1, strokeThickness, opacity, strokeY1DashArray);
        }
        if (propertyName === constants_1.PROPERTY.FILL || propertyName === constants_1.PROPERTY.OPACITY) {
            BrushCache_1.createBrushInCache(this.fillBrushCache, fill, opacity);
        }
        if (propertyName === constants_1.PROPERTY.FILL_Y1 || propertyName === constants_1.PROPERTY.OPACITY) {
            BrushCache_1.createBrushInCache(this.fillBrushY1Cache, fillY1, opacity);
        }
    }
}
exports.BandSeriesDrawingProvider = BandSeriesDrawingProvider;
