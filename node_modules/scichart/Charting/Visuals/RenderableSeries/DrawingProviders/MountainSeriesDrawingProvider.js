"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MountainSeriesDrawingProvider = void 0;
const Deleter_1 = require("../../../../Core/Deleter");
const SeriesType_1 = require("../../../../types/SeriesType");
const BrushCache_1 = require("../../../Drawing/BrushCache");
const Pen2DCache_1 = require("../../../Drawing/Pen2DCache");
const WebGlRenderContext2D_1 = require("../../../Drawing/WebGlRenderContext2D");
const constants_1 = require("../constants");
const BaseSeriesDrawingProvider_1 = require("./BaseSeriesDrawingProvider");
/** @ignore */
const TEXTURE_SIZE = 256;
/**
 * Used internally - a drawing provider performs drawing for a {@link BaseMountainRenderableSeries} using
 * our WebAssembly WebGL rendering engine
 */
class MountainSeriesDrawingProvider extends BaseSeriesDrawingProvider_1.BaseSeriesDrawingProvider {
    /**
     * Creates an instance of the {@link MountainSeriesDrawingProvider}
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param parentSeries the parent {@link BaseMountainRenderableSeries} which this drawing provider is attached to
     */
    constructor(webAssemblyContext, parentSeries) {
        super(webAssemblyContext, parentSeries);
        this.strokePenCache = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.fillBrushCache = new BrushCache_1.BrushCache(webAssemblyContext);
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.nativeDrawingProvider = Deleter_1.deleteSafe(this.nativeDrawingProvider);
        this.strokePenCache = Deleter_1.deleteSafe(this.strokePenCache);
        this.fillBrushCache = Deleter_1.deleteSafe(this.fillBrushCache);
        super.delete();
    }
    /**
     * @inheritDoc
     */
    draw(renderContext, renderPassData) {
        var _a;
        // TODO: We need to get truncated pointseries out (viewport culling) for efficient drawing of large datasets
        const dataSeries = this.parentSeries.dataSeries;
        const args = new this.webAssemblyContext.SCRTMountainDrawingParams();
        args.forceShaderMethod = true;
        args.lineGaps = dataSeries.containsNaN
            ? this.parentSeries.drawNaNAs === WebGlRenderContext2D_1.ELineDrawMode.DiscontinuousLine
                ? this.webAssemblyContext.SCRTLineGapMode.DrawGaps
                : this.webAssemblyContext.SCRTLineGapMode.CloseGaps
            : this.webAssemblyContext.SCRTLineGapMode.Default;
        args.verticalChart = renderPassData.isVerticalChart;
        args.zeroLineY = this.parentSeries.zeroLineY;
        args.isDigitalLine = this.parentSeries.isDigitalLine;
        const fillBrush = BrushCache_1.getScrtBrushFromCache(this.fillBrushCache);
        if (fillBrush) {
            args.SetFillBrush(fillBrush);
        }
        const strokePen = Pen2DCache_1.getScrtPenFromCache(this.strokePenCache);
        if (strokePen) {
            args.SetLinesPen(strokePen);
        }
        // Paletting per point
        super.applyStrokeFillPaletting(this.parentSeries.stroke, strokePen, this.parentSeries.fill, fillBrush, this.parentSeries.opacity, true, this.parentSeries.fillLinearGradient !== undefined);
        const paletteTexture = (_a = this.palettingState.paletteTextureCache) === null || _a === void 0 ? void 0 : _a.value;
        if (paletteTexture) {
            args.SetPalette(paletteTexture);
        }
        args.isSmoothColors = this.palettingState.gradientPaletting;
        const isCategoryAxis = renderPassData.xCoordinateCalculator.isCategoryCoordinateCalculator;
        const xValues = dataSeries.getNativeXValues();
        let xDrawValues;
        let yDrawValues;
        const { isRunningAnimation } = this.parentSeries;
        const isSplineMountainSeries = this.parentSeries.type === SeriesType_1.ESeriesType.SplineMountainSeries && xValues.size() > 1;
        if (isSplineMountainSeries) {
            const rs = this.parentSeries;
            if (!isRunningAnimation) {
                rs.updateSplineValues();
            }
            xDrawValues = rs.xSplineValues;
            yDrawValues = isRunningAnimation ? rs.yAnimationValues : rs.ySplineValues;
        }
        else {
            xDrawValues = isCategoryAxis ? dataSeries.getNativeIndexes() : xValues;
            yDrawValues = isRunningAnimation ? this.parentSeries.yAnimationValues : dataSeries.getNativeYValues();
        }
        args.count = yDrawValues.size();
        const nativeContext = renderContext.getNativeContext();
        const viewRect = this.parentSeries.parentSurface.seriesViewRect;
        nativeContext.PushMatrix();
        nativeContext.PushState();
        nativeContext.Translate(viewRect.x, viewRect.y);
        nativeContext.SetClipRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
        this.nativeDrawingProvider.DrawPointsVec(nativeContext, xDrawValues, yDrawValues, renderPassData.xCoordinateCalculator.nativeCalculator, renderPassData.yCoordinateCalculator.nativeCalculator, args);
        nativeContext.PopMatrix();
        nativeContext.PopState();
        args.delete();
    }
    /**
     * @inheritDoc
     */
    onSeriesPropertyChange(propertyName) {
        super.onSeriesPropertyChange(propertyName);
        if (propertyName === constants_1.PROPERTY.STROKE ||
            propertyName === constants_1.PROPERTY.STROKE_DASH_ARRAY ||
            propertyName === constants_1.PROPERTY.STROKE_THICKNESS ||
            propertyName === constants_1.PROPERTY.OPACITY) {
            const { stroke, strokeThickness, fill, opacity, strokeDashArray } = this.parentSeries;
            Pen2DCache_1.createPenInCache(this.strokePenCache, stroke, strokeThickness, opacity, strokeDashArray);
        }
        if (propertyName === constants_1.PROPERTY.FILL ||
            propertyName === constants_1.PROPERTY.OPACITY ||
            propertyName === constants_1.PROPERTY.FILL_LINEAR_GRADIENT) {
            this.createBrush();
        }
    }
    /**
     * @inheritDoc
     */
    onAttachSeries() {
        super.onAttachSeries();
        this.nativeDrawingProvider = new this.webAssemblyContext.SCRTMountainSeriesDrawingProvider();
        const { stroke, strokeThickness, opacity, strokeDashArray } = this.parentSeries;
        Pen2DCache_1.createPenInCache(this.strokePenCache, stroke, strokeThickness, opacity, strokeDashArray);
        this.createBrush();
    }
    createBrush() {
        const { fill, opacity, fillLinearGradient } = this.parentSeries;
        return BrushCache_1.createBrushInCache(this.fillBrushCache, fill, opacity, fillLinearGradient);
    }
}
exports.MountainSeriesDrawingProvider = MountainSeriesDrawingProvider;
