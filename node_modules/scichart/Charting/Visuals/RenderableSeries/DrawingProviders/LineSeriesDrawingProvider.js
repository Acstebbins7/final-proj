"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineSeriesDrawingProvider = void 0;
const Deleter_1 = require("../../../../Core/Deleter");
const SeriesType_1 = require("../../../../types/SeriesType");
const Pen2DCache_1 = require("../../../Drawing/Pen2DCache");
const WebGlRenderContext2D_1 = require("../../../Drawing/WebGlRenderContext2D");
const constants_1 = require("../constants");
const BaseSeriesDrawingProvider_1 = require("./BaseSeriesDrawingProvider");
/**
 * Used internally - a drawing provider performs drawing for a {@link FastLineRenderableSeries} using
 * our WebAssembly WebGL rendering engine
 */
class LineSeriesDrawingProvider extends BaseSeriesDrawingProvider_1.BaseSeriesDrawingProvider {
    /**
     * Creates an instance of the {@link LineSeriesDrawingProvider}
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param parentSeries the parent {@link FastLineRenderableSeries} which this drawing provider is attached to
     */
    constructor(webAssemblyContext, parentSeries) {
        super(webAssemblyContext, parentSeries);
        this.linesPenCache = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
    }
    /**
     * @inheritDoc
     */
    onSeriesPropertyChange(propertyName) {
        super.onSeriesPropertyChange(propertyName);
        if (propertyName === constants_1.PROPERTY.PALETTE_PROVIDER) {
            this.linesPenCache.invalidateCache();
        }
        if (propertyName === constants_1.PROPERTY.STROKE ||
            propertyName === constants_1.PROPERTY.STROKE_THICKNESS ||
            propertyName === constants_1.PROPERTY.PALETTE_PROVIDER ||
            propertyName === constants_1.PROPERTY.OPACITY ||
            propertyName === constants_1.PROPERTY.STROKE_DASH_ARRAY) {
            const { stroke, strokeThickness, opacity, strokeDashArray } = this.parentSeries;
            Pen2DCache_1.createPenInCache(this.linesPenCache, stroke, strokeThickness, opacity, strokeDashArray);
        }
    }
    /**
     * @inheritDoc
     */
    onAttachSeries() {
        super.onAttachSeries();
        this.nativeDrawingProvider = new this.webAssemblyContext.SCRTLineSeriesDrawingProvider();
        const { stroke, strokeThickness, opacity, strokeDashArray } = this.parentSeries;
        Pen2DCache_1.createPenInCache(this.linesPenCache, stroke, strokeThickness, opacity, strokeDashArray);
    }
    /**
     * @inheritDoc
     */
    onDetachSeries() {
        super.onDetachSeries();
        this.nativeDrawingProvider = Deleter_1.deleteSafe(this.nativeDrawingProvider);
    }
    /**
     * @inheritDoc
     */
    draw(renderContext, renderPassData) {
        const linesPen = Pen2DCache_1.getScrtPenFromCache(this.linesPenCache);
        if (!linesPen) {
            return;
        }
        // TODO: We need to get truncated pointseries out (viewport culling) for efficient drawing of large datasets
        const dataSeries = this.parentSeries.dataSeries;
        const args = new this.webAssemblyContext.SCRTLineDrawingParams();
        args.SetLinesPen(linesPen);
        args.isDigitalLine = this.parentSeries.isDigitalLine;
        args.forceShaderMethod = true;
        args.lineGaps = dataSeries.containsNaN
            ? this.parentSeries.drawNaNAs === WebGlRenderContext2D_1.ELineDrawMode.DiscontinuousLine
                ? this.webAssemblyContext.SCRTLineGapMode.DrawGaps
                : this.webAssemblyContext.SCRTLineGapMode.CloseGaps
            : this.webAssemblyContext.SCRTLineGapMode.Default;
        args.verticalChart = renderPassData.isVerticalChart;
        const isCategoryAxis = renderPassData.xCoordinateCalculator.isCategoryCoordinateCalculator;
        const xValues = dataSeries.getNativeXValues();
        let xDrawValues;
        let yDrawValues;
        const { isRunningAnimation } = this.parentSeries;
        const isSplineLineSeries = this.parentSeries.type === SeriesType_1.ESeriesType.SplineLineSeries && xValues.size() > 1;
        if (isSplineLineSeries) {
            const splineLineSeries = this.parentSeries;
            if (!isRunningAnimation) {
                splineLineSeries.updateSplineValues();
            }
            xDrawValues = splineLineSeries.xSplineValues;
            yDrawValues = isRunningAnimation ? splineLineSeries.yAnimationValues : splineLineSeries.ySplineValues;
        }
        else {
            xDrawValues = isCategoryAxis ? dataSeries.getNativeIndexes() : xValues;
            yDrawValues = isRunningAnimation ? this.parentSeries.yAnimationValues : dataSeries.getNativeYValues();
        }
        args.count = yDrawValues.size();
        // Stroke paletting per point
        super.applyStrokePaletting(linesPen);
        if (this.palettingState.palettedColors) {
            args.SetPalettedColors(this.palettingState.palettedColors);
        }
        const nativeContext = renderContext.getNativeContext();
        this.drawLines(renderContext, nativeContext, xDrawValues, yDrawValues, renderPassData.xCoordinateCalculator.nativeCalculator, renderPassData.yCoordinateCalculator.nativeCalculator, args, this.parentSeries.parentSurface.seriesViewRect);
        args.delete();
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.linesPenCache = Deleter_1.deleteSafe(this.linesPenCache);
        this.nativeDrawingProvider = Deleter_1.deleteSafe(this.nativeDrawingProvider);
        super.delete();
    }
    drawLines(renderContext, nativeContext, xValues, yValues, xCoordCalc, yCoordCalc, args, viewRect) {
        nativeContext.PushMatrix();
        nativeContext.PushState();
        nativeContext.Translate(viewRect.x, viewRect.y);
        nativeContext.SetClipRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
        this.nativeDrawingProvider.DrawLinesVec(nativeContext, xValues, yValues, xCoordCalc, yCoordCalc, args);
        nativeContext.PopMatrix();
        nativeContext.PopState();
    }
}
exports.LineSeriesDrawingProvider = LineSeriesDrawingProvider;
