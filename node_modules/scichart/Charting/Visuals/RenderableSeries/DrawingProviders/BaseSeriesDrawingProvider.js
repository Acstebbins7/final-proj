"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSeriesDrawingProvider = void 0;
const Deleter_1 = require("../../../../Core/Deleter");
const Guard_1 = require("../../../../Core/Guard");
const colorUtil_1 = require("../../../../utils/colorUtil");
const number_1 = require("../../../../utils/number");
const parseColor_1 = require("../../../../utils/parseColor");
const PaletteCache_1 = require("../../../Drawing/PaletteCache");
const IPaletteProvider_1 = require("../../../Model/IPaletteProvider");
const createSolidBrush_1 = require("../../Helpers/createSolidBrush");
const constants_1 = require("../constants");
/**
 * Used internally - a drawing provider performs drawing for a specific chart-type or series using
 * our WebAssembly WebGL rendering engine
 */
class BaseSeriesDrawingProvider {
    /**
     * Creates an instance of the {@link BaseSeriesDrawingProvider}
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param parentSeries the parent {@link IRenderableSeries | Renderable Series} which this drawing provider is attached to
     */
    constructor(webAssemblyContext, parentSeries) {
        var _a;
        Guard_1.Guard.notNull(webAssemblyContext, "webAssemblyContext");
        Guard_1.Guard.notNull(parentSeries, "parentSeries");
        this.webAssemblyContext = webAssemblyContext;
        this.parentSeries = parentSeries;
        this.palettingState = {
            palettedColors: undefined,
            palettedColorsHashCode: 0,
            gradientPaletting: false,
            paletteTextureCache: new PaletteCache_1.PaletteCache(webAssemblyContext),
        };
        this.seriesHasDataChanges = this.seriesHasDataChanges.bind(this);
        this.parentDataSeries = this.parentSeries.dataSeries;
        (_a = this.parentDataSeries) === null || _a === void 0 ? void 0 : _a.dataChanged.subscribe(this.seriesHasDataChanges);
    }
    /**
     * Helper function to apply color-paletting to a {@link UIntVector} - where each element in the vector
     * is an ARGB color that defines stroke of the series
     * @param strokePen the current pen, as type {@link SCRTPen}
     * @returns the new {@link UIntVector} with ARGB colors
     */
    applyStrokePaletting(strokePen) {
        if (this.parentSeries.hasStrokePaletteProvider()) {
            const strokeColorArgb = colorUtil_1.uintArgbColorMultiplyOpacity(parseColor_1.parseColorToUIntArgb(this.parentSeries.stroke), this.parentSeries.opacity);
            if (isNaN(strokeColorArgb)) {
                throw Error("applyStrokePaletting(): renderSeries.stroke " +
                    this.parentSeries.stroke +
                    " cannot be converted to a valid color");
            }
            const strokePaletteProvider = this.parentSeries.paletteProvider;
            const dataSeries = this.parentSeries.dataSeries;
            if (!this.palettingState.palettedColors ||
                this.palettingState.palettedColors.size() !== dataSeries.count()) {
                Deleter_1.deleteSafe(this.palettingState.palettedColors);
                this.palettingState.palettedColors = new this.webAssemblyContext.UIntVector();
                this.palettingState.palettedColors.reserve(dataSeries.count());
            }
            strokePen.m_bGradient = strokePaletteProvider.strokePaletteMode === IPaletteProvider_1.EStrokePaletteMode.GRADIENT;
            // For paletted series, we must pass 0xFFFFFFFF (white) to pen line
            strokePen.m_uiColor = 0xffffffff;
            const xValues = dataSeries.getNativeXValues();
            const yValues = dataSeries.getNativeYValues();
            for (let index = 0; index < dataSeries.count(); index++) {
                const overrideColor = strokePaletteProvider.overrideStrokeArgb(xValues.get(index), yValues.get(index), index);
                this.parentSeries.pushPalettedColors(overrideColor ? overrideColor : strokeColorArgb, this.palettingState);
            }
        }
        else {
            this.palettingState.palettedColors = Deleter_1.deleteSafe(this.palettingState.palettedColors);
            if (this.palettingState.originalPenColor) {
                strokePen.m_uiColor = this.palettingState.originalPenColor;
                this.palettingState.originalPenColor = undefined;
            }
        }
        // Due to pass-by-pointer limitations of WASM binding, we pass an empty vector rather than null
        if (!this.palettingState.palettedColors) {
            this.palettingState.palettedColors = new this.webAssemblyContext.UIntVector();
        }
    }
    applyStrokeFillPaletting(stroke, strokePen, fill, fillBrush, opacity, usePalette = false, resetPenBrushColors = true) {
        const hasStrokePaletteProvider = this.parentSeries.hasStrokePaletteProvider();
        const hasFillPaletteProvider = this.parentSeries.hasFillPaletteProvider();
        const hasPointMarkerPaletteProvider = this.parentSeries.hasPointMarkerPaletteProvider();
        const strokePaletteProvider = this.parentSeries.paletteProvider;
        const pointMarkerPaletteProvider = this.parentSeries.paletteProvider;
        const fillPaletteProvider = this.parentSeries.paletteProvider;
        if (hasStrokePaletteProvider || hasFillPaletteProvider || hasPointMarkerPaletteProvider) {
            let strokeColor;
            let fillColor;
            if (usePalette) {
                strokeColor = fillColor = this.webAssemblyContext.SCRTPalette.GetNoOverrideColorCode();
            }
            else {
                const hasOpacity = opacity !== undefined;
                strokeColor =
                    stroke && hasOpacity ? colorUtil_1.uintArgbColorMultiplyOpacity(parseColor_1.parseColorToUIntArgb(stroke), 1) : 0xffffffff;
                fillColor =
                    fill && hasOpacity ? colorUtil_1.uintArgbColorMultiplyOpacity(parseColor_1.parseColorToUIntArgb(fill), 1) : 0xffffffff;
            }
            if (isNaN(strokeColor)) {
                throw Error("updatePalette(): parentSeries.stroke " + stroke + " cannot be converted to a valid color");
            }
            if (isNaN(fillColor)) {
                throw Error("updatePalette(): fillColor " + fillColor + " cannot be converted to a valid color");
            }
            const dataSeries = this.parentSeries.dataSeries;
            if (!this.palettingState.palettedColors ||
                this.palettingState.palettedColors.size() !== dataSeries.count()) {
                Deleter_1.deleteSafe(this.palettingState.palettedColors);
                this.palettingState.palettedColors = new this.webAssemblyContext.UIntVector();
                this.palettingState.palettedColors.reserve(dataSeries.count() * 2);
                this.palettingState.paletteTextureCache.reset();
            }
            if (resetPenBrushColors) {
                if (strokePen) {
                    // For paletted series, we must pass 0xFFFFFFFF (white) to pen line
                    this.palettingState.originalPenColor = strokePen.m_uiColor;
                    strokePen.m_uiColor = 0xffffffff;
                    this.palettingState.originalPenGradient = strokePen.m_bGradient;
                    if (hasStrokePaletteProvider) {
                        strokePen.m_bGradient = strokePaletteProvider.strokePaletteMode === IPaletteProvider_1.EStrokePaletteMode.GRADIENT;
                    }
                    else if (hasPointMarkerPaletteProvider) {
                        strokePen.m_bGradient =
                            pointMarkerPaletteProvider.strokePaletteMode === IPaletteProvider_1.EStrokePaletteMode.GRADIENT;
                    }
                }
                if (fillBrush) {
                    this.palettingState.originalBrushColor = fillBrush.GetColor();
                    fillBrush.SetColor(0xffffffff);
                }
            }
            const xValues = dataSeries.getNativeXValues();
            const yValues = dataSeries.getNativeYValues();
            let hashCode = 0;
            for (let index = 0; index < dataSeries.count(); index++) {
                const xValue = xValues.get(index);
                const yValue = yValues.get(index);
                let overrideStrokeColor = strokeColor;
                if (hasStrokePaletteProvider) {
                    const curStrokeColor = strokePaletteProvider.overrideStrokeArgb(xValue, yValue, index, opacity);
                    if (curStrokeColor) {
                        overrideStrokeColor = curStrokeColor;
                    }
                }
                let overrideFillColor = fillColor;
                if (hasFillPaletteProvider) {
                    const curFillColor = fillPaletteProvider.overrideFillArgb(xValue, yValue, index, opacity);
                    if (curFillColor) {
                        overrideFillColor = curFillColor;
                    }
                }
                if (hasPointMarkerPaletteProvider) {
                    const curFillStrokeColor = pointMarkerPaletteProvider.overridePointMarkerArgb(xValue, yValue, index, opacity);
                    if (curFillStrokeColor) {
                        overrideStrokeColor = curFillStrokeColor.stroke;
                        overrideFillColor = curFillStrokeColor.fill;
                    }
                }
                this.palettingState.palettedColors.push_back(overrideStrokeColor);
                this.palettingState.palettedColors.push_back(overrideFillColor);
                hashCode = number_1.numericHashCode(hashCode, overrideStrokeColor);
                hashCode = number_1.numericHashCode(hashCode, overrideFillColor);
            }
            if (usePalette) {
                if (this.palettingState.palettedColorsHashCode !== hashCode) {
                    this.palettingState.paletteTextureCache.reset();
                }
                this.palettingState.paletteTextureCache.create(this.palettingState.palettedColors);
            }
            this.palettingState.palettedColorsHashCode = hashCode;
        }
        else {
            this.palettingState.palettedColors = Deleter_1.deleteSafe(this.palettingState.palettedColors);
            this.palettingState.paletteTextureCache.reset();
            if (strokePen) {
                if (this.palettingState.originalPenColor) {
                    strokePen.m_uiColor = this.palettingState.originalPenColor;
                    this.palettingState.originalPenColor = undefined;
                }
                if (this.palettingState.originalPenGradient) {
                    strokePen.m_bGradient = this.palettingState.originalPenGradient;
                    this.palettingState.originalPenGradient = undefined;
                }
            }
            if (fillBrush && this.palettingState.originalBrushColor) {
                fillBrush.SetColor(this.palettingState.originalBrushColor);
                this.palettingState.originalBrushColor = undefined;
            }
        }
        // Due to pass-by-pointer limitations of WASM binding, we pass an empty vector rather than null
        if (!this.palettingState.palettedColors) {
            this.palettingState.palettedColors = new this.webAssemblyContext.UIntVector();
        }
        this.palettingState.gradientPaletting =
            (hasStrokePaletteProvider && strokePaletteProvider.strokePaletteMode === IPaletteProvider_1.EStrokePaletteMode.GRADIENT) ||
                (hasFillPaletteProvider && fillPaletteProvider.fillPaletteMode === IPaletteProvider_1.EFillPaletteMode.GRADIENT) ||
                (hasPointMarkerPaletteProvider &&
                    pointMarkerPaletteProvider.strokePaletteMode === IPaletteProvider_1.EStrokePaletteMode.GRADIENT);
    }
    /**
     * Creates a native {@link SCRTBrush} Solid Color Brush from html color code string passed in
     * @param htmlColorCode The HTML Color code
     * @param opacity The opacity factor
     */
    createSolidBrush(htmlColorCode, opacity) {
        return createSolidBrush_1.createSolidBrush(this.webAssemblyContext, htmlColorCode, opacity);
    }
    /**
     * @inheritDoc
     */
    delete() {
        if (this.palettingState.palettedColors) {
            this.palettingState.palettedColors = Deleter_1.deleteSafe(this.palettingState.palettedColors);
        }
        this.palettingState.paletteTextureCache = Deleter_1.deleteSafe(this.palettingState.paletteTextureCache);
    }
    /**
     * @inheritDoc
     */
    onSeriesPropertyChange(propertyName) {
        var _a, _b;
        if (propertyName === constants_1.PROPERTY.DATA_SERIES) {
            (_a = this.parentDataSeries) === null || _a === void 0 ? void 0 : _a.dataChanged.unsubscribe(this.seriesHasDataChanges);
            this.parentDataSeries = this.parentSeries.dataSeries;
            (_b = this.parentDataSeries) === null || _b === void 0 ? void 0 : _b.dataChanged.subscribe(this.seriesHasDataChanges);
        }
    }
    /**
     * @inheritDoc
     */
    onAttachSeries() {
        // Override in derived class to be notified of series being attached to sciChartSurface
    }
    /**
     * @inheritDoc
     */
    onDetachSeries() {
        // Override in derived class to be notified of series being detached from sciChartSurface
    }
    /**
     * Internal method that runs on each animation tick
     * @param progress The current animation progress, a value from 0 to 1
     * @param animation The current animation type
     */
    onAnimate(progress, animation) {
        // Override in derived class to do necessary calculations in drawing providers
    }
    seriesHasDataChanges() {
        // TODO override in derived class.
    }
}
exports.BaseSeriesDrawingProvider = BaseSeriesDrawingProvider;
