"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniformContoursRenderableSeries = exports.EContourColorMapMode = exports.COLOR_MAP_PREFIX = void 0;
const SeriesType_1 = require("../../../types/SeriesType");
const isRealNumber_1 = require("../../../utils/isRealNumber");
const AxisCore_1 = require("../Axis/AxisCore");
const BaseRenderableSeries_1 = require("./BaseRenderableSeries");
const constants_1 = require("./constants");
const UniformContoursDrawingProvider_1 = require("./DrawingProviders/UniformContoursDrawingProvider");
/** @ignore */
exports.COLOR_MAP_PREFIX = "colorMap.";
var EContourColorMapMode;
(function (EContourColorMapMode) {
    /**
     *  Applies the Gradient Colors from {@link UniformContoursRenderableSeries} ColorMap individually,
     *  ignoring offsets, e.g. with Gradient Stops Red, Green, Blue then
     *  contour lines will appear Red Green or Blue
     */
    EContourColorMapMode[EContourColorMapMode["AlternateColors"] = 0] = "AlternateColors";
    /**
     * Applies the Gradient Colors from {@link UniformContoursRenderableSeries} ColorMap according to the data on the chart
     */
    EContourColorMapMode[EContourColorMapMode["GradientColors"] = 1] = "GradientColors";
})(EContourColorMapMode = exports.EContourColorMapMode || (exports.EContourColorMapMode = {}));
class UniformContoursRenderableSeries extends BaseRenderableSeries_1.BaseRenderableSeries {
    // private drawingModeProperty: EContourDrawingMode;
    /**
     * Creates an instance of the {@link UniformHeatmapRenderableSeries}
     * @param webAssemblyContext The {@link TSciChart | SciChart WebAssembly Context} containing
     * native methods and access to our WebGL2 WebAssembly Drawing Engine
     * @param options optional parameters of type {@link IHeatmapRenderableSeriesOptions} applied when constructing the series type
     */
    constructor(webAssemblyContext, options) {
        var _a;
        super(webAssemblyContext, options);
        this.type = SeriesType_1.ESeriesType.UniformContoursSeries;
        this.colorMapPropertyChanged = this.colorMapPropertyChanged.bind(this);
        this.colorMap = options === null || options === void 0 ? void 0 : options.colorMap;
        this.dataSeries = options === null || options === void 0 ? void 0 : options.dataSeries;
        this.xAxisId = (_a = options === null || options === void 0 ? void 0 : options.xAxisId) !== null && _a !== void 0 ? _a : AxisCore_1.AxisCore.DEFAULT_AXIS_ID;
        this.xAxisId = (options === null || options === void 0 ? void 0 : options.yAxisId) || AxisCore_1.AxisCore.DEFAULT_AXIS_ID;
        this.zMin = (options === null || options === void 0 ? void 0 : options.zMin) || NaN;
        this.zMax = (options === null || options === void 0 ? void 0 : options.zMax) || NaN;
        this.zStep = (options === null || options === void 0 ? void 0 : options.zStep) || NaN;
        this.majorLineStyle = (options === null || options === void 0 ? void 0 : options.majorLineStyle) || UniformContoursRenderableSeries.DEFAULT_MAJOR_LINE_STYLE;
        this.minorLineStyle = (options === null || options === void 0 ? void 0 : options.minorLineStyle) || UniformContoursRenderableSeries.DEFAULT_MINOR_LINE_STYLE;
        this.minorsPerMajor = (options === null || options === void 0 ? void 0 : options.minorsPerMajor) || 0;
        this.drawingProviders = [];
        this.drawingProviders.push(new UniformContoursDrawingProvider_1.UniformContoursDrawingProvider(webAssemblyContext, this));
    }
    get zMin() {
        return this.zMinProperty;
    }
    set zMin(zMin) {
        this.zMinProperty = zMin;
        this.notifyPropertyChanged(constants_1.PROPERTY.Z_MIN);
    }
    get zMax() {
        return this.zMaxProperty;
    }
    set zMax(zMax) {
        this.zMaxProperty = zMax;
        this.notifyPropertyChanged(constants_1.PROPERTY.Z_MAX);
    }
    get zStep() {
        return this.zStepProperty;
    }
    set zStep(zStep) {
        this.zStepProperty = zStep;
        this.notifyPropertyChanged(constants_1.PROPERTY.Z_STEP);
    }
    /**
     * Gets or sets the {@link HeatmapColorMap}, which maps heatmap z-values to colors
     */
    get colorMap() {
        return this.colorMapProperty;
    }
    /**
     * Gets or sets the {@link HeatmapColorMap}, which maps heatmap z-values to colors
     */
    set colorMap(colorMap) {
        var _a, _b;
        (_a = this.colorMapProperty) === null || _a === void 0 ? void 0 : _a.propertyChanged.unsubscribe(this.colorMapPropertyChanged);
        this.colorMapProperty = colorMap;
        (_b = this.colorMapProperty) === null || _b === void 0 ? void 0 : _b.propertyChanged.subscribe(this.colorMapPropertyChanged);
        this.notifyPropertyChanged(constants_1.PROPERTY.COLOR_MAP);
    }
    get colorMapMode() {
        return this.colorMapModeProperty;
    }
    set colorMapMode(colorMapMode) {
        this.colorMapModeProperty = colorMapMode;
        this.notifyPropertyChanged(constants_1.PROPERTY.CONTOUR_COLOR_MAP_MODE);
    }
    get majorLineStyle() {
        return this.majorLineStyleProperty;
    }
    set majorLineStyle(majorLineStyle) {
        this.majorLineStyleProperty = majorLineStyle;
        this.notifyPropertyChanged(constants_1.PROPERTY.CONTOUR_MAJOR_LINE_STYLE);
    }
    get minorLineStyle() {
        return this.minorLineStyleProperty;
    }
    set minorLineStyle(minorLineStyle) {
        this.minorLineStyleProperty = minorLineStyle;
        this.notifyPropertyChanged(constants_1.PROPERTY.CONTOUR_MINOR_LINE_STYLE);
    }
    get minorsPerMajor() {
        return this.minorsPerMajorProperty;
    }
    set minorsPerMajor(minorsPerMajor) {
        this.minorsPerMajorProperty = minorsPerMajor;
        this.notifyPropertyChanged(constants_1.PROPERTY.CONTOUR_MINORS_PER_MAJOR);
    }
    getContourDrawingParams() {
        var _a, _b;
        const heatmapSeries = this.dataSeries;
        const dataZRange = heatmapSeries.zRange;
        let zMin = this.zMin && isRealNumber_1.isRealNumber(this.zMin) ? this.zMin : dataZRange.min;
        let zMax = this.zMax && isRealNumber_1.isRealNumber(this.zMax) ? this.zMax : dataZRange.max;
        zMin = Math.max(zMin, dataZRange.min);
        zMax = Math.min(zMax, dataZRange.max);
        const majorStepZ = this.zStep && isRealNumber_1.isRealNumber(this.zStep)
            ? this.zStep
            : Math.abs(zMax - zMin) / UniformContoursRenderableSeries.DEFAULT_CONTOURS_COUNT;
        const minorStepZ = this.minorsPerMajor && this.minorsPerMajor > 0 ? majorStepZ / (this.minorsPerMajor + 1) : majorStepZ;
        const minorLineStyle = (_a = this.minorLineStyle) !== null && _a !== void 0 ? _a : {
            strokeThickness: this.strokeThickness,
            color: this.stroke
        };
        const majorLineStyle = (_b = this.majorLineStyle) !== null && _b !== void 0 ? _b : {
            strokeThickness: this.strokeThickness,
            color: this.stroke
        };
        const result = {
            xMax: heatmapSeries.xMax,
            yMin: heatmapSeries.yMin,
            yMax: heatmapSeries.yMax,
            xMin: heatmapSeries.xMin,
            zMin,
            zMax,
            majorStepZ,
            minorStepZ,
            minorLineStyle,
            majorLineStyle
        };
        return result;
    }
    /**
     * Called when a property changes on {@link HeatmapColorMap}, and notifies the parent {@link SciChartSurface}
     * that a redraw is required.
     * @param args
     */
    colorMapPropertyChanged(args) {
        this.notifyPropertyChanged(exports.COLOR_MAP_PREFIX + args.propertyName);
    }
    newHitTestProvider() {
        return undefined;
    }
}
exports.UniformContoursRenderableSeries = UniformContoursRenderableSeries;
UniformContoursRenderableSeries.DEFAULT_CONTOURS_COUNT = 15;
UniformContoursRenderableSeries.DEFAULT_MAJOR_LINE_STYLE = {
    strokeThickness: 2,
    color: "white"
};
UniformContoursRenderableSeries.DEFAULT_MINOR_LINE_STYLE = {
    strokeThickness: 1,
    color: "white"
};
