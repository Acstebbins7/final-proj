"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackedMountainRenderableSeries = void 0;
const Deleter_1 = require("../../../Core/Deleter");
const SeriesType_1 = require("../../../types/SeriesType");
const BrushCache_1 = require("../../Drawing/BrushCache");
const Pen2DCache_1 = require("../../Drawing/Pen2DCache");
const BaseStackedRenderableSeries_1 = require("./BaseStackedRenderableSeries");
const constants_1 = require("./constants");
const StackedMountainSeriesHitTestProvider_1 = require("./HitTest/StackedMountainSeriesHitTestProvider");
/**
 * @summary The {@link StackedMountainRenderableSeries} allows creating JavaScript Stacked Mountain charts
 * @description
 * Multiple {@link StackedMountainRenderableSeries} are required to create a stacked column chart type in SciChart.
 * These are grouped with a {@link StackedMountainCollection}, which implements {@link IRenderableSeries} and may be added
 * directly to a {@link SciChartSurface.renderableSeries} collection.
 *
 * Code sample below for creating a stacked mountain chart
 * ```ts
 * const stackedMountain0 = new StackedMountainRenderableSeries(wasmContext);
 * // .. configure mountain 1, including set dataSeries
 * const stackedMountain1 = new StackedMountainRenderableSeries(wasmContext);
 * // .. configure mountain 2, including set dataSeries
 * const stackedMountain2 = new StackedMountainRenderableSeries(wasmContext);
 * // .. configure mountain 3, including set dataSeries
 * const stackedMountainCollection = new StackedMountainCollection(wasmContext);
 * stackedMountainCollection.add(stackedMountain0, stackedMountain1, stackedMountain2);
 *
 * sciChartSurface.renderableSeries.add(stackedMountainCollection);
 * ````
 * @remarks
 * Do not add the {@link StackedMountainRenderableSeries} directly to {@link SciChartSurface.renderableSeries} array, instead,
 * use a {@link StackedMountainCollection} to group / stack the mountains.
 */
class StackedMountainRenderableSeries extends BaseStackedRenderableSeries_1.BaseStackedRenderableSeries {
    /**
     * Creates an instance of the {@link StackedMountainRenderableSeries}
     * @param webAssemblyContext The {@link TSciChart | SciChart WebAssembly Context} containing
     * native methods and access to our WebGL2 WebAssembly Drawing Engine
     */
    constructor(webAssemblyContext) {
        super(webAssemblyContext);
        this.type = SeriesType_1.ESeriesType.StackedMountainSeries;
        this.fillProperty = "#7e8486";
        this.strokePenCache = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.fillBrushCache = new BrushCache_1.BrushCache(webAssemblyContext);
    }
    // PUBLIC
    /**
     * @inheritDoc
     */
    delete() {
        this.strokePenCache = Deleter_1.deleteSafe(this.strokePenCache);
        this.fillBrushCache = Deleter_1.deleteSafe(this.fillBrushCache);
        super.delete();
    }
    /**
     * Called internally when the {@link StackedMountainRenderableSeries} is attached to a parent {@link StackedMountainCollection}
     * @param parentCollection the parent {@link BaseStackedCollection}
     * @param getParentSurfaceFn function to get the parent {@link SciChartSurface}
     * @param notifyPropertyChangedFn function to notify property has changed
     */
    onAttachToParentCollection(parentCollection, getParentSurfaceFn, notifyPropertyChangedFn) {
        if (this.parentCollection) {
            throw new Error("Invalid operation in StackedMountainRenderableSeries.onAttachToParentCollection, this series has been already attached to collection. Please detach it from the collection before attaching to another");
        }
        this.parentCollection = parentCollection;
        this.getParentSurfaceFn = getParentSurfaceFn;
        this.notifyParentPropertyChangedFn = notifyPropertyChangedFn;
        const { stroke, strokeThickness, fill, opacity } = this;
        Pen2DCache_1.createPenInCache(this.strokePenCache, stroke, strokeThickness, opacity);
        BrushCache_1.createBrushInCache(this.fillBrushCache, fill, opacity);
    }
    /**
     * Gets the fill brush of the mountain as an HTML color code
     */
    getFillBrush() {
        return BrushCache_1.getScrtBrushFromCache(this.fillBrushCache);
    }
    /**
     * Gets the stroke of the mountain as an HTML color code
     */
    getStrokePen() {
        return Pen2DCache_1.getScrtPenFromCache(this.strokePenCache);
    }
    /**
     * @inheritDoc
     */
    notifyPropertyChanged(propertyName) {
        super.notifyPropertyChanged(propertyName);
        if (propertyName === constants_1.PROPERTY.STROKE ||
            propertyName === constants_1.PROPERTY.STROKE_THICKNESS ||
            propertyName === constants_1.PROPERTY.OPACITY) {
            Pen2DCache_1.createPenInCache(this.strokePenCache, this.stroke, this.strokeThickness, this.opacity);
        }
        if (propertyName === constants_1.PROPERTY.FILL || propertyName === constants_1.PROPERTY.OPACITY) {
            BrushCache_1.createBrushInCache(this.fillBrushCache, this.fill, this.opacity);
        }
    }
    // PROPERTIES
    /**
     * Gets or sets the fill brush of the mountain as an HTML color code
     */
    get fill() {
        return this.fillProperty;
    }
    /**
     * Gets or sets the fill brush of the mountain as an HTML color code
     */
    set fill(fill) {
        this.fillProperty = fill;
        this.notifyPropertyChanged(constants_1.PROPERTY.FILL);
    }
    // PROPERTIES END
    // PROTECTED
    /**
     * @inheritDoc
     */
    newHitTestProvider() {
        return new StackedMountainSeriesHitTestProvider_1.StackedMountainSeriesHitTestProvider(this);
    }
}
exports.StackedMountainRenderableSeries = StackedMountainRenderableSeries;
