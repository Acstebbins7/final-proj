"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.drawAxisMarkerAnnotation = exports.drawLineAnnotation = exports.drawModifiersAxisLabel = void 0;
const AxisAlignment_1 = require("../../../types/AxisAlignment");
const AxisType_1 = require("../../../types/AxisType");
const LabelPlacement_1 = require("../../../types/LabelPlacement");
exports.drawModifiersAxisLabel = (currentAxis, renderContext, labelCoord, fill, stroke) => {
    const formattedDataValue = getLabelValue(currentAxis, labelCoord);
    const textStyle = Object.assign(Object.assign({}, currentAxis.labelStyle), { color: stroke });
    currentAxis.axisRenderer.drawModifiersAxisLabel(renderContext, formattedDataValue, labelCoord, currentAxis.axisAlignment, textStyle, fill);
};
/**
 * Function to draw Vertical or Horizontal Line annotations with labels
 */
exports.drawLineAnnotation = (currentAxis, renderContext, labelPlacement, displayValue, x1Coord, x2Coord, y1Coord, y2Coord, textStyle, fill, strokePen, viewRect, showLabel, opacity) => {
    const nativeContext = renderContext.getNativeContext();
    const { axisAlignment } = currentAxis;
    const displayVertically = (axisAlignment === AxisAlignment_1.EAxisAlignment.Top || axisAlignment === AxisAlignment_1.EAxisAlignment.Bottom)
        && ![
            LabelPlacement_1.ELabelPlacement.Top,
            LabelPlacement_1.ELabelPlacement.Bottom,
            LabelPlacement_1.ELabelPlacement.Auto,
            LabelPlacement_1.ELabelPlacement.Axis,
        ].includes(labelPlacement);
    const displayMirrored = [
        LabelPlacement_1.ELabelPlacement.Right,
        LabelPlacement_1.ELabelPlacement.TopRight,
        LabelPlacement_1.ELabelPlacement.BottomRight,
    ].includes(labelPlacement);
    const annotationCoord = (axisAlignment === AxisAlignment_1.EAxisAlignment.Top || axisAlignment === AxisAlignment_1.EAxisAlignment.Bottom)
        ? x1Coord
        : y1Coord;
    const text = displayValue || getLabelValue(currentAxis, annotationCoord);
    const isLabelOnAxis = labelPlacement === LabelPlacement_1.ELabelPlacement.Auto || labelPlacement === LabelPlacement_1.ELabelPlacement.Axis;
    const labelBackgroundColor = isLabelOnAxis ? fill : null;
    const labelTextStyle = isLabelOnAxis ? textStyle : Object.assign(Object.assign({}, textStyle), { color: fill });
    let labelHeight = 0;
    let labelWidth = 0;
    if (showLabel) {
        const { bitmapTexture, textureHeight, textureWidth } = currentAxis.axisRenderer.createAnnotationLabelTexture(text, labelTextStyle, labelBackgroundColor, displayVertically, displayMirrored, opacity);
        const { xPosition, yPosition } = getLabelCoordinates(currentAxis, labelPlacement, x1Coord, x2Coord, y1Coord, y2Coord, textureHeight, textureWidth);
        labelHeight = textureHeight;
        labelWidth = textureWidth;
        nativeContext.DrawTexture(bitmapTexture, xPosition, yPosition, textureWidth, textureHeight);
        bitmapTexture.delete();
    }
    const { x1LineCoord, y1LineCoord, x2LineCoord, y2LineCoord } = getLineCoordinates(x1Coord, y1Coord, x2Coord, y2Coord, labelHeight, labelWidth, labelPlacement, currentAxis);
    renderContext.drawLine(x1LineCoord, y1LineCoord, x2LineCoord, y2LineCoord, strokePen, viewRect);
};
exports.drawAxisMarkerAnnotation = (currentAxis, renderContext, displayValue, markerCoordinate, x1Coord, y1Coord, textStyle, fill, opacity) => {
    const nativeContext = renderContext.getNativeContext();
    const { axisAlignment } = currentAxis;
    const text = displayValue || getLabelValue(currentAxis, markerCoordinate);
    const labelBackgroundColor = fill;
    const labelTextStyle = textStyle;
    const { bitmapTexture, textureHeight, textureWidth } = currentAxis.axisRenderer.createAxisMarker(axisAlignment, text, labelTextStyle, labelBackgroundColor, opacity);
    const { xPosition, yPosition } = getLabelCoordinates(currentAxis, LabelPlacement_1.ELabelPlacement.Axis, x1Coord, x1Coord, y1Coord, y1Coord, textureHeight, textureWidth);
    nativeContext.DrawTexture(bitmapTexture, xPosition, yPosition, textureWidth, textureHeight);
    bitmapTexture.delete();
};
/**
 * Calculates coordinates of the annotation label.
 * The coordinates are defined as an absolute position on the SciChartSurface.
 */
const getLabelCoordinates = (currentAxis, labelPlacement, x1Coord, x2Coord, y1Coord, y2Coord, textureHeight, textureWidth) => {
    const { axisAlignment, parentSurface: { seriesViewRect }, viewRect: axisViewRect } = currentAxis;
    let xPosition = 0;
    let yPosition = 0;
    const centerVertically = () => {
        switch (axisAlignment) {
            case AxisAlignment_1.EAxisAlignment.Right:
            case AxisAlignment_1.EAxisAlignment.Left:
                yPosition = seriesViewRect.top + y1Coord - textureHeight / 2;
                break;
            case AxisAlignment_1.EAxisAlignment.Top:
                yPosition = seriesViewRect.top + y2Coord / 2 - textureHeight / 2;
                break;
            case AxisAlignment_1.EAxisAlignment.Bottom:
                yPosition = seriesViewRect.top + y1Coord + (y2Coord - y1Coord) / 2 - textureHeight / 2;
                break;
        }
    };
    const centerHorizontally = () => {
        switch (axisAlignment) {
            case AxisAlignment_1.EAxisAlignment.Right:
                xPosition = seriesViewRect.left + x2Coord + (x1Coord - x2Coord) / 2 - textureWidth / 2;
                break;
            case AxisAlignment_1.EAxisAlignment.Left:
                xPosition = seriesViewRect.left + x2Coord / 2 - textureWidth / 2;
                break;
            case AxisAlignment_1.EAxisAlignment.Top:
            case AxisAlignment_1.EAxisAlignment.Bottom:
                xPosition = seriesViewRect.left + x2Coord - textureWidth / 2;
                break;
        }
    };
    const alignRight = () => {
        switch (axisAlignment) {
            case AxisAlignment_1.EAxisAlignment.Right:
                xPosition = seriesViewRect.left + x1Coord - textureWidth;
                break;
            case AxisAlignment_1.EAxisAlignment.Left:
                xPosition = seriesViewRect.left + x2Coord - textureWidth;
                break;
            case AxisAlignment_1.EAxisAlignment.Top:
            case AxisAlignment_1.EAxisAlignment.Bottom:
                xPosition = seriesViewRect.left + x1Coord;
                break;
        }
    };
    const alignLeft = () => {
        switch (axisAlignment) {
            case AxisAlignment_1.EAxisAlignment.Right:
                xPosition = seriesViewRect.left + x2Coord;
                break;
            case AxisAlignment_1.EAxisAlignment.Left:
                xPosition = seriesViewRect.left;
                break;
            case AxisAlignment_1.EAxisAlignment.Top:
            case AxisAlignment_1.EAxisAlignment.Bottom:
                xPosition = seriesViewRect.left + x1Coord - textureWidth;
                break;
        }
    };
    const alignTop = () => {
        switch (axisAlignment) {
            case AxisAlignment_1.EAxisAlignment.Right:
            case AxisAlignment_1.EAxisAlignment.Left:
                yPosition = seriesViewRect.top + y1Coord - textureHeight;
                break;
            case AxisAlignment_1.EAxisAlignment.Top:
                yPosition = seriesViewRect.top;
                break;
            case AxisAlignment_1.EAxisAlignment.Bottom:
                yPosition = seriesViewRect.top + y2Coord;
                break;
        }
    };
    const alignBottom = () => {
        switch (axisAlignment) {
            case AxisAlignment_1.EAxisAlignment.Right:
            case AxisAlignment_1.EAxisAlignment.Left:
                yPosition = seriesViewRect.top + y1Coord;
                break;
            case AxisAlignment_1.EAxisAlignment.Top:
                yPosition = seriesViewRect.top + y2Coord - textureHeight;
                break;
            case AxisAlignment_1.EAxisAlignment.Bottom:
                yPosition = seriesViewRect.top + y1Coord - textureHeight;
                break;
        }
    };
    const alignOnAxis = () => {
        switch (axisAlignment) {
            case AxisAlignment_1.EAxisAlignment.Right:
                centerVertically();
                xPosition = axisViewRect.width < textureWidth
                    ? xPosition = axisViewRect.right - textureWidth
                    : axisViewRect.left;
                break;
            case AxisAlignment_1.EAxisAlignment.Left:
                centerVertically();
                xPosition = axisViewRect.width < textureWidth
                    ? xPosition = axisViewRect.left
                    : axisViewRect.right - textureWidth;
                break;
            case AxisAlignment_1.EAxisAlignment.Top:
                yPosition = axisViewRect.height < textureHeight
                    ? axisViewRect.top
                    : axisViewRect.bottom - textureHeight;
                centerHorizontally();
                break;
            case AxisAlignment_1.EAxisAlignment.Bottom:
                yPosition = axisViewRect.height < textureHeight
                    ? axisViewRect.bottom - textureHeight
                    : axisViewRect.top;
                centerHorizontally();
                break;
        }
    };
    switch (labelPlacement) {
        case LabelPlacement_1.ELabelPlacement.Right:
            centerVertically();
            alignRight();
            break;
        case LabelPlacement_1.ELabelPlacement.TopRight:
            alignTop();
            alignRight();
            break;
        case LabelPlacement_1.ELabelPlacement.BottomRight:
            alignBottom();
            alignRight();
            break;
        case LabelPlacement_1.ELabelPlacement.Bottom:
            alignBottom();
            centerHorizontally();
            break;
        case LabelPlacement_1.ELabelPlacement.Left:
            centerVertically();
            alignLeft();
            break;
        case LabelPlacement_1.ELabelPlacement.TopLeft:
            alignTop();
            alignLeft();
            break;
        case LabelPlacement_1.ELabelPlacement.BottomLeft:
            alignBottom();
            alignLeft();
            break;
        case LabelPlacement_1.ELabelPlacement.Top:
            alignTop();
            centerHorizontally();
            break;
        case LabelPlacement_1.ELabelPlacement.Axis:
        case LabelPlacement_1.ELabelPlacement.Auto:
            alignOnAxis();
            break;
        default:
            throw Error("Unexpected LabelPlacement " + labelPlacement);
    }
    // prevent label from overflowing axes
    if (labelPlacement !== LabelPlacement_1.ELabelPlacement.Auto && labelPlacement !== LabelPlacement_1.ELabelPlacement.Axis) {
        if (yPosition < seriesViewRect.top) {
            yPosition = seriesViewRect.top;
        }
        if (yPosition + textureHeight > seriesViewRect.bottom) {
            yPosition = seriesViewRect.bottom - textureHeight;
        }
        if (xPosition < seriesViewRect.left) {
            xPosition = seriesViewRect.left;
        }
        if (xPosition + textureWidth > seriesViewRect.right) {
            xPosition = seriesViewRect.right - textureWidth;
        }
    }
    return { xPosition, yPosition };
};
/**
 * Calculates annotation line coordinates accordingly to axis alignment and label placement.
 * Returns coordinates relative to seriesViewRect.
 */
const getLineCoordinates = (x1Coord, y1Coord, x2Coord, y2Coord, labelHeight, labelWidth, labelPlacement, currentAxis) => {
    const { axisAlignment, parentSurface: { seriesViewRect }, viewRect: axisViewRect } = currentAxis;
    let x1LineCoord = x1Coord;
    let y1LineCoord = y1Coord;
    let x2LineCoord = x2Coord;
    let y2LineCoord = y2Coord;
    switch (labelPlacement) {
        case LabelPlacement_1.ELabelPlacement.Right:
            switch (axisAlignment) {
                case AxisAlignment_1.EAxisAlignment.Right:
                    x1LineCoord = Math.abs(x1Coord - x2Coord) < labelWidth
                        ? x2LineCoord
                        : x1Coord - labelWidth;
                    break;
                case AxisAlignment_1.EAxisAlignment.Left:
                    x2LineCoord = x2Coord > seriesViewRect.width
                        ? seriesViewRect.width - labelWidth
                        : x2Coord - labelWidth;
                    break;
            }
            break;
        case LabelPlacement_1.ELabelPlacement.Bottom:
            switch (axisAlignment) {
                case AxisAlignment_1.EAxisAlignment.Top:
                    y2LineCoord = y2Coord > seriesViewRect.height
                        ? seriesViewRect.height - labelHeight
                        : y2Coord - labelHeight;
                    break;
                case AxisAlignment_1.EAxisAlignment.Bottom:
                    y1LineCoord = Math.abs(y1Coord - y2Coord) < labelHeight
                        ? y2LineCoord
                        : y1Coord - labelHeight;
                    break;
            }
            break;
        case LabelPlacement_1.ELabelPlacement.Left:
            switch (axisAlignment) {
                case AxisAlignment_1.EAxisAlignment.Right:
                    x2LineCoord = x2Coord < 0
                        ? labelWidth
                        : x2Coord + labelWidth;
                    break;
                case AxisAlignment_1.EAxisAlignment.Left:
                    x1LineCoord = Math.abs(x1Coord - x2Coord) < labelWidth
                        ? x2LineCoord
                        : x1Coord + labelWidth;
                    break;
            }
            break;
        case LabelPlacement_1.ELabelPlacement.Top:
            switch (axisAlignment) {
                case AxisAlignment_1.EAxisAlignment.Top:
                    y1LineCoord = Math.abs(y1Coord - y2Coord) < labelHeight
                        ? y2LineCoord
                        : y1Coord + labelHeight;
                    break;
                case AxisAlignment_1.EAxisAlignment.Bottom:
                    y2LineCoord = y2Coord < 0
                        ? labelHeight
                        : y2Coord + labelHeight;
                    break;
            }
            break;
        case LabelPlacement_1.ELabelPlacement.Auto:
        case LabelPlacement_1.ELabelPlacement.Axis:
            switch (axisAlignment) {
                case AxisAlignment_1.EAxisAlignment.Right:
                    x1LineCoord = axisViewRect.width < labelWidth
                        ? seriesViewRect.width + axisViewRect.width - labelWidth
                        : seriesViewRect.width;
                    if (x2LineCoord > x1LineCoord) {
                        x2LineCoord = x1LineCoord;
                    }
                    break;
                case AxisAlignment_1.EAxisAlignment.Left:
                    x1LineCoord = axisViewRect.width < labelWidth
                        ? labelWidth - axisViewRect.width
                        : 0;
                    if (x2LineCoord < x1LineCoord) {
                        x2LineCoord = x1LineCoord;
                    }
                    break;
                case AxisAlignment_1.EAxisAlignment.Top:
                    y1LineCoord = axisViewRect.height < labelHeight
                        ? labelHeight - axisViewRect.height
                        : 0;
                    if (y2LineCoord < y1LineCoord) {
                        y2LineCoord = y1LineCoord;
                    }
                    break;
                case AxisAlignment_1.EAxisAlignment.Bottom:
                    y1LineCoord = axisViewRect.height < labelHeight
                        ? axisViewRect.bottom - labelHeight
                        : seriesViewRect.bottom;
                    if (y2LineCoord > y1LineCoord) {
                        y2LineCoord = y1LineCoord;
                    }
                    break;
            }
            break;
    }
    return {
        x1LineCoord,
        y1LineCoord,
        x2LineCoord,
        y2LineCoord,
    };
};
const getLabelValue = (currentAxis, labelCoord) => {
    const isCategotyAxis = currentAxis.type === AxisType_1.EAxisType.CategoryAxis;
    let dataValue;
    const coordCalc = currentAxis.getCurrentCoordinateCalculator();
    if (isCategotyAxis) {
        const index = coordCalc.getDataValue(labelCoord);
        dataValue = coordCalc.transformIndexToData(index);
    }
    else {
        dataValue = coordCalc.getDataValue(labelCoord);
    }
    return currentAxis.labelProvider.formatLabel(dataValue);
};
