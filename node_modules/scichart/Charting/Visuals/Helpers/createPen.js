"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSCRTPen = void 0;
const app_1 = require("../../../constants/app");
const colorUtil_1 = require("../../../utils/colorUtil");
const parseColor_1 = require("../../../utils/parseColor");
/**
 * Helper function to create a {@link SCRTPen} native pen
 * access to our WebGL2 Engine and WebAssembly numerical methods
 * @param wasmContext The {@link TSciChart | SciChart WebAssembly Context} containing
 * native methods and access to our WebGL2 WebAssembly Drawing Engine
 * @param htmlColorCode Html color code in the format "#fff", "#ff0000", "rgba(255,255,0,1)", "#11333333"
 * @param strokeThickness the stroke thickness of the pen in pixels
 * @param opacity The opacity factor
 * @param strokeDashArray the StrokeDashArray which defines any dash e.g. [2,2] means dash for 2pts, gap for 2pts (or undefined = solid line).
 */
exports.createSCRTPen = (wasmContext, htmlColorCode, strokeThickness, opacity, strokeDashArray, antiAliased = true) => {
    if (app_1.IS_TEST_ENV || !htmlColorCode) {
        return undefined;
    }
    // the logic for calculating an opacity should be consistent when creating new and updating an existing pen or brush
    const colorArgb = colorUtil_1.uintArgbColorMultiplyOpacity(parseColor_1.parseColorToUIntArgb(htmlColorCode), opacity);
    if (isNaN(colorArgb)) {
        throw new Error(`Color code ${htmlColorCode} cannot be converted to an ARGB integer`);
    }
    if (strokeDashArray && strokeDashArray.length) {
        // Create a dashed pen
        const strokeDashFloatVector = new wasmContext.FloatVector();
        strokeDashArray.forEach(item => strokeDashFloatVector.push_back(item));
        return wasmContext.SCRTCreateDahedPen(colorArgb, strokeThickness, antiAliased, strokeDashFloatVector);
    }
    // Create a normal pen
    return new wasmContext.SCRTPen(colorArgb, strokeThickness, antiAliased);
};
