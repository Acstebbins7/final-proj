"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxisRenderer = void 0;
const app_1 = require("../../../constants/app");
const Rect_1 = require("../../../Core/Rect");
const AxisAlignment_1 = require("../../../types/AxisAlignment");
const AxisAlignment_2 = require("../../../types/AxisAlignment");
const WebGlRenderContext2D_1 = require("../../Drawing/WebGlRenderContext2D");
const TextureManager_1 = require("../TextureManager/TextureManager");
/**
 * Draws an axis using our WebGL Rendering engine
 */
class AxisRenderer {
    constructor(webAssemblyContext) {
        this.viewRect = Rect_1.Rect.createZero();
        this.desiredLabelsSize = 0;
        this.desiredTicksSize = 0;
        this.desiredHeightProperty = 0;
        this.desiredWidthProperty = 0;
        this.webAssemblyContext = webAssemblyContext;
        this.textureManager = new TextureManager_1.TextureManager(webAssemblyContext);
        if (!app_1.IS_TEST_ENV) {
            this.measureTextCanvas = document.createElement("canvas");
            this.measureTextCanvas.width = 1;
            this.measureTextCanvas.height = 1;
        }
    }
    measure(isHorizontalAxis, labelStyle, majorTicks, ticksSize, labelsPadding, labelProvider, drawLabels, drawTicks) {
        // TODO: Michael
        // Assume for now that vertical axis labels are drawn horizontally but later we may add
        // CSS Transforms to labelStyle to allow rotation etc...
        //
        // With your measured text now you can return desired size
        if (drawLabels) {
            const { fontFamily, fontSize, fontWeight, fontStyle } = labelStyle;
            const ctx = this.measureTextCanvas.getContext("2d");
            ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
            let desiredLabelsSize = 0;
            if (isHorizontalAxis) {
                desiredLabelsSize = TextureManager_1.measureTextHeight(fontSize) + (labelsPadding === null || labelsPadding === void 0 ? void 0 : labelsPadding.top) + (labelsPadding === null || labelsPadding === void 0 ? void 0 : labelsPadding.bottom);
            }
            else {
                majorTicks.forEach(tick => {
                    const labelText = labelProvider.formatLabel(tick);
                    const labelWidth = TextureManager_1.measureTextWidth(ctx, labelText) + (labelsPadding === null || labelsPadding === void 0 ? void 0 : labelsPadding.left) + (labelsPadding === null || labelsPadding === void 0 ? void 0 : labelsPadding.right);
                    desiredLabelsSize = labelWidth > desiredLabelsSize ? labelWidth : desiredLabelsSize;
                });
            }
            this.desiredLabelsSize = desiredLabelsSize;
        }
        else {
            this.desiredLabelsSize = 0;
        }
        this.desiredTicksSize = drawTicks ? ticksSize : 0;
        const desiredSize = this.desiredLabelsSize + this.desiredTicksSize;
        if (isHorizontalAxis) {
            this.desiredHeightProperty = desiredSize;
        }
        else {
            this.desiredWidthProperty = desiredSize;
        }
    }
    get desiredHeight() {
        return this.desiredHeightProperty;
    }
    set desiredHeight(height) {
        this.desiredHeightProperty = height;
    }
    get desiredWidth() {
        return this.desiredWidthProperty;
    }
    set desiredWidth(width) {
        this.desiredWidthProperty = width;
    }
    layout(rect) {
        this.viewRect = rect;
        // TODO: arrange ticks and labels
        // TODO: Andrew
        // Create canvasTexture at the viewrect size
        // During draw, reuse this canvastexture unless size changed
    }
    drawLabels(renderContext, axisAlignment, ticksLabels, tickCoords, labelStyle, isVerticalChart, isFlippedCoordinates) {
        const { viewRect, textureManager } = this;
        const nativeContext = renderContext.getNativeContext();
        const isAxisFlipped = isVerticalChart ? AxisAlignment_1.getIsHorizontal(axisAlignment) : AxisAlignment_2.getIsVertical(axisAlignment);
        const { bitmapTexture, textureHeight, textureWidth } = textureManager.createAxisLabelsTexture(ticksLabels, tickCoords, labelStyle, viewRect.width, viewRect.height, isAxisFlipped, axisAlignment, this.desiredTicksSize, isFlippedCoordinates);
        // Logger.log(`${getIsHorizontal(axisAlignment) ? "XAxis" : "YAxis"} Texture size: w=${textureWidth}, h=${textureHeight}`);
        nativeContext.DrawTexture(bitmapTexture, viewRect.x, viewRect.y, textureWidth, textureHeight);
        bitmapTexture.delete();
    }
    drawTicks(renderContext, axisAlignment, tickCoords, pen, tickStyle) {
        const { viewRect } = this;
        const { tickSize } = tickStyle;
        const vertices = new this.webAssemblyContext.VectorColorVertex();
        const isHorizontal = AxisAlignment_1.getIsHorizontal(axisAlignment);
        if (isHorizontal === undefined) {
            return;
        }
        tickCoords.forEach(tc => {
            let x1, x2, y1, y2;
            if (isHorizontal) {
                x1 = tc;
                x2 = tc;
                y1 = axisAlignment === AxisAlignment_1.EAxisAlignment.Bottom ? 0 : viewRect.height;
                y2 = axisAlignment === AxisAlignment_1.EAxisAlignment.Bottom ? tickSize : viewRect.height - tickSize;
            }
            else {
                x1 = axisAlignment === AxisAlignment_1.EAxisAlignment.Right ? 0 : viewRect.width;
                x2 = axisAlignment === AxisAlignment_1.EAxisAlignment.Right ? tickSize : viewRect.width - tickSize;
                y1 = tc;
                y2 = tc;
            }
            const vertex = new this.webAssemblyContext.SCRTColorVertex(x1, y1);
            vertices.push_back(vertex);
            vertex.delete();
            const vertex2 = new this.webAssemblyContext.SCRTColorVertex(x2, y2);
            vertices.push_back(vertex2);
            vertex2.delete();
        });
        renderContext.drawLinesNative(vertices, pen, WebGlRenderContext2D_1.ELineDrawMode.DiscontinuousLine, viewRect.left, viewRect.top);
        vertices.delete();
    }
    drawModifiersAxisLabel(renderContext, displayValue, coord, axisAlignment, textStyle, fill) {
        if (!displayValue)
            return;
        const nativeContext = renderContext.getNativeContext();
        const { fontStyle, fontWeight, fontSize, fontFamily, color } = textStyle;
        const { bitmapTexture, textureHeight, textureWidth } = this.textureManager.createTextTexture(displayValue, fontStyle, fontWeight, fontSize, fontFamily, color, 2, fill);
        let xPosition, yPosition;
        if (axisAlignment === AxisAlignment_1.EAxisAlignment.Bottom) {
            xPosition = this.viewRect.x + coord - textureWidth / 2;
            yPosition = this.viewRect.y;
        }
        else if (axisAlignment === AxisAlignment_1.EAxisAlignment.Top) {
            xPosition = this.viewRect.x + coord - textureWidth / 2;
            yPosition = this.viewRect.y + this.viewRect.height - textureHeight;
        }
        else if (axisAlignment === AxisAlignment_1.EAxisAlignment.Left) {
            xPosition = this.viewRect.x + this.viewRect.width - textureWidth;
            yPosition = this.viewRect.y + coord - textureHeight / 2;
        }
        else if (axisAlignment === AxisAlignment_1.EAxisAlignment.Right) {
            xPosition = this.viewRect.x;
            yPosition = this.viewRect.y + coord - textureHeight / 2;
        }
        nativeContext.DrawTexture(bitmapTexture, xPosition, yPosition, textureWidth, textureHeight);
        bitmapTexture.delete();
    }
    createAxisMarker(axisAlignment, text, textStyle, backgroundColor, opacity) {
        const { fontStyle, fontWeight, fontSize, fontFamily, color } = textStyle;
        return this.textureManager.createAxisMarkerTexture(axisAlignment, text, fontStyle, fontWeight, fontSize, fontFamily, color, 2, backgroundColor, opacity);
    }
    createAnnotationLabelTexture(text, textStyle, backgroundColor, displayVertically, displayMirrored, opacity) {
        const { fontStyle, fontWeight, fontSize, fontFamily, color } = textStyle;
        return this.textureManager.createTextTexture(text, fontStyle, fontWeight, fontSize, fontFamily, color, 2, backgroundColor, displayVertically, displayMirrored, opacity);
    }
}
exports.AxisRenderer = AxisRenderer;
