"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxisBase2D = exports.EClipMode = void 0;
const EasingFunctions_1 = require("../../../Core/Animations/EasingFunctions");
const Deleter_1 = require("../../../Core/Deleter");
const NumberRange_1 = require("../../../Core/NumberRange");
const Thickness_1 = require("../../../Core/Thickness");
const AxisAlignment_1 = require("../../../types/AxisAlignment");
const AxisType_1 = require("../../../types/AxisType");
const RenderLayer_1 = require("../../../types/RenderLayer");
const XyDirection_1 = require("../../../types/XyDirection");
const parseColor_1 = require("../../../utils/parseColor");
const Pen2DCache_1 = require("../../Drawing/Pen2DCache");
const SolidBrushCache_1 = require("../../Drawing/SolidBrushCache");
const WebGlRenderContext2D_1 = require("../../Drawing/WebGlRenderContext2D");
const defaultThemeColors_1 = require("../../Themes/defaultThemeColors");
const createNativeRect_1 = require("../Helpers/createNativeRect");
const drawBorder_1 = require("../Helpers/drawBorder");
const AxisCore_1 = require("./AxisCore");
const AxisLayoutState_1 = require("./AxisLayoutState");
const AxisRenderer_1 = require("./AxisRenderer");
const AxisTitleRenderer_1 = require("./AxisTitleRenderer");
const constants_1 = require("./constants");
/**
 * Defines the clipping mode for scrolling operations found on {@link AxisBase2D.scroll}
 */
var EClipMode;
(function (EClipMode) {
    /**
     * Do not clip when scrolling the Axis
     * @remarks
     * Use this to resolve issues such as scaling or stretching
     * when the user pans or scrolls outside of the range of the data.
     */
    EClipMode[EClipMode["None"] = 0] = "None";
    /**
     * Stretch the {@link AxisBase2D.visibleRange} when scrolling past the extents of the data.
     */
    EClipMode[EClipMode["StretchAtExtents"] = 1] = "StretchAtExtents";
    /**
     * Clips the {@link AxisBase2D.visibleRange} to not allow scrolling past the minimum of the Axis range
     */
    EClipMode[EClipMode["ClipAtMin"] = 2] = "ClipAtMin";
    /**
     * Clips the {@link AxisBase2D.visibleRange} to not allow scrolling past the maximum of the Axis range
     */
    EClipMode[EClipMode["ClipAtMax"] = 3] = "ClipAtMax";
    /**
     * Clips the {@link AxisBase2D.visibleRange} to not allow scrolling past the minimum or maximum of the Axis range
     */
    EClipMode[EClipMode["ClipAtExtents"] = 4] = "ClipAtExtents";
})(EClipMode = exports.EClipMode || (exports.EClipMode = {}));
/**
 * The base class for 2D Chart Axis within SciChart - High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}.
 * @description
 * AxisBase2D is a base class for both 2D Axis types in SciChart. Concrete types include:
 *
 *  - {@link NumericAxis}: a Numeric 2D value-axis
 *  - {@link CategoryAxis}: A category 2D axis used for stock chart applications
 *
 *  Set axis on the {@link SciChartSurface.xAxes} or {@link SciChartSurface.yAxes} collections in 2D Charts.
 */
class AxisBase2D extends AxisCore_1.AxisCore {
    /**
     * Creates an instance of the {@link AxisBase2D}
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param options Optional parameters of type {@link IAxisBase2dOptions} used to configure the axis at instantiation time
     */
    constructor(webAssemblyContext, options) {
        var _a, _b, _c, _d, _e;
        super(options);
        /**
         * Gets the {@link AxisLayoutState} class which manages layout
         */
        this.axisLayoutState = new AxisLayoutState_1.AxisLayoutState();
        this.labelStyleProperty = {
            fontSize: 14,
            fontFamily: "Arial",
            color: defaultThemeColors_1.defaultThemeColors.tickTextBrush,
            fontWeight: "normal",
            fontStyle: "normal",
            padding: Thickness_1.Thickness.fromNumber(4)
        };
        this.isCenterAxisProperty = false;
        this.isPrimaryAxisProperty = false;
        this.axisBorderProperty = {
            borderBottom: 0,
            borderLeft: 0,
            borderRight: 0,
            borderTop: 0,
            color: defaultThemeColors_1.defaultThemeColors.axisBorder,
            border: 0
        };
        this.webAssemblyContext2D = webAssemblyContext;
        this.penCacheForMajorGridLines = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.penCacheForMinorGridLines = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.penCacheForMajorTickLines = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.penCacheForMinorTickLines = new Pen2DCache_1.Pen2DCache(webAssemblyContext);
        this.solidBrushCacheAxisBands = new SolidBrushCache_1.SolidBrushCache(webAssemblyContext);
        this.axisRenderer = new AxisRenderer_1.AxisRenderer(webAssemblyContext);
        this.axisTitleRenderer = new AxisTitleRenderer_1.AxisTitleRenderer(webAssemblyContext);
        this.visibleRangeLimit = (_a = options === null || options === void 0 ? void 0 : options.visibleRangeLimit) !== null && _a !== void 0 ? _a : this.visibleRangeLimit;
        this.axisAlignment = (_b = options === null || options === void 0 ? void 0 : options.axisAlignment) !== null && _b !== void 0 ? _b : this.axisAlignment;
        this.axisTitle = (_c = options === null || options === void 0 ? void 0 : options.axisTitle) !== null && _c !== void 0 ? _c : this.axisTitle;
        this.labelStyle = (_d = options === null || options === void 0 ? void 0 : options.labelStyle) !== null && _d !== void 0 ? _d : this.labelStyle;
        this.axisBorder = (_e = options === null || options === void 0 ? void 0 : options.axisBorder) !== null && _e !== void 0 ? _e : this.axisBorder;
        this.solidBrushCacheBorder = new SolidBrushCache_1.SolidBrushCache(webAssemblyContext);
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        const previousThemeProvider = this.parentSurface.previousThemeProvider;
        if (this.axisBandsFill === previousThemeProvider.axisBandsFill) {
            this.axisBandsFill = themeProvider.axisBandsFill;
        }
        if (this.labelStyle.color === previousThemeProvider.tickTextBrush) {
            this.labelStyle = { color: themeProvider.tickTextBrush };
        }
        if (this.minorGridLineStyle.color === previousThemeProvider.minorGridLineBrush) {
            this.minorGridLineStyle = { color: themeProvider.minorGridLineBrush };
        }
        if (this.majorGridLineStyle.color === previousThemeProvider.majorGridLineBrush) {
            this.majorGridLineStyle = { color: themeProvider.majorGridLineBrush };
        }
        if (this.minorTickLineStyle.color === previousThemeProvider.minorGridLineBrush) {
            this.minorTickLineStyle = { color: themeProvider.minorGridLineBrush };
        }
        if (this.majorTickLineStyle.color === previousThemeProvider.majorGridLineBrush) {
            this.majorTickLineStyle = { color: themeProvider.majorGridLineBrush };
        }
        if (this.axisTitleStyle.color === previousThemeProvider.axisTitleColor) {
            this.axisTitleStyle = { color: themeProvider.axisTitleColor };
        }
    }
    /**
     * Gets whether the axis is currently horizontal or not
     */
    get isHorizontalAxis() {
        return AxisAlignment_1.getIsHorizontal(this.axisAlignment);
    }
    /**
     * Gets whether the axis is flipped or not
     */
    get isAxisFlipped() {
        if (this.isXAxis) {
            return false;
        }
        else {
            return true;
        }
    }
    /**
     * Gets or sets the Axis Alignment. See {@link EAxisAlignment} for a list of values
     * @remarks use this property to set whether the axis is on the Left, Right, Bottom Top of the chart.
     * SciChart also supports XAxis on the left and YAxis on the top to rotate / create vertical charts.
     */
    get axisAlignment() {
        return this.axisAlignmentProperty;
    }
    /**
     * Gets or sets the Axis Alignment. See {@link EAxisAlignment} for a list of values
     * @remarks use this property to set whether the axis is on the Left, Right, Bottom Top of the chart.
     * SciChart also supports XAxis on the left and YAxis on the top to rotate / create vertical charts.
     */
    set axisAlignment(axisAlignment) {
        this.axisAlignmentProperty = axisAlignment;
        this.notifyPropertyChanged(constants_1.PROPERTY.AXIS_ALIGNMENT);
    }
    /**
     * Gets or sets a property which limits {@link AxisCore.visibleRange}, meaning the chart cannot autorange outside that range
     */
    get visibleRangeLimit() {
        return this.visibleRangeLimitProperty;
    }
    /**
     * Gets or sets a property which limits {@link AxisCore.visibleRange}, meaning the chart cannot autorange outside that range
     */
    set visibleRangeLimit(visibleRangeLimit) {
        this.visibleRangeLimitProperty = visibleRangeLimit;
        this.notifyPropertyChanged(constants_1.PROPERTY.VISIBLE_RANGE_LIMIT);
    }
    /**
     * Gets or sets whether this axis is the Primary axis on the chart
     * @remarks In SciChart 2D Charts, multiple X,Y Axis are supported, but only one can draw gridlines.
     * The primary axis is the one which draws the gridlines. By default, this is the first axis in the collection
     */
    get isPrimaryAxis() {
        return this.isPrimaryAxisProperty;
    }
    /**
     * Gets or sets whether this axis is the Primary axis on the chart
     * @remarks In SciChart 2D Charts, multiple X,Y Axis are supported, but only one can draw gridlines.
     * The primary axis is the one which draws the gridlines. By default, this is the first axis in the collection
     */
    set isPrimaryAxis(value) {
        if (value === true) {
            if (this.isXAxis && this.parentSurface.xAxes.size() > 1) {
                this.parentSurface.xAxes.asArray().forEach(el => (el.isPrimaryAxisProperty = false));
            }
            if (!this.isXAxis && this.parentSurface.yAxes.size() > 1) {
                this.parentSurface.yAxes.asArray().forEach(el => (el.isPrimaryAxisProperty = false));
            }
            this.isPrimaryAxisProperty = value;
            this.notifyPropertyChanged(constants_1.PROPERTY.IS_PRIMARY_AXIS);
        }
    }
    /**
     * Gets whether the parent {@link SciChartSurface} is a vertical chart, when the XAxis is on the Left or Right,
     * and YAxis is on the Top or Bottom
     */
    get isVerticalChart() {
        if (this.isXAxis) {
            return !![AxisAlignment_1.EAxisAlignment.Left, AxisAlignment_1.EAxisAlignment.Right].includes(this.axisAlignment);
        }
        else {
            return !![AxisAlignment_1.EAxisAlignment.Top, AxisAlignment_1.EAxisAlignment.Bottom].includes(this.axisAlignment);
        }
    }
    /**
     * Gets or sets a {@link TTextStyle} object for styling axis labels
     */
    get labelStyle() {
        return this.labelStyleProperty;
    }
    /**
     * Gets or sets a {@link TTextStyle} object for styling axis labels
     */
    set labelStyle(textStyle) {
        this.labelStyleProperty = Object.assign(Object.assign({}, this.labelStyle), textStyle);
        this.notifyPropertyChanged(constants_1.PROPERTY.TEXT_STYLE);
    }
    /**
     * Gets or sets the Axis Border properties
     */
    get axisBorder() {
        return this.axisBorderProperty;
    }
    /**
     * Gets or sets the Axis Border properties
     */
    set axisBorder(border) {
        var _a, _b, _c, _d, _e, _f;
        this.axisBorder.borderTop = (_a = border.borderTop) !== null && _a !== void 0 ? _a : this.axisBorder.borderTop;
        this.axisBorder.borderLeft = (_b = border.borderLeft) !== null && _b !== void 0 ? _b : this.axisBorder.borderLeft;
        this.axisBorder.borderBottom = (_c = border.borderBottom) !== null && _c !== void 0 ? _c : this.axisBorder.borderBottom;
        this.axisBorder.borderRight = (_d = border.borderRight) !== null && _d !== void 0 ? _d : this.axisBorder.borderRight;
        this.axisBorder.border = (_e = border.border) !== null && _e !== void 0 ? _e : this.axisBorder.border;
        this.axisBorder.color = (_f = border.color) !== null && _f !== void 0 ? _f : this.axisBorder.color;
        this.notifyPropertyChanged(constants_1.PROPERTY.BORDER);
    }
    /**
     * Called internally - measures the axis as part of the layout phase
     */
    measure() {
        var _a;
        // TODO: updateTickProvider, updateLabelProvider
        // TODO: measure for category axes
        if (this.isVisible) {
            const { majorTicks } = this.getTicks();
            const drawTicks = this.drawMinorTickLines || this.drawMajorTickLines;
            this.axisRenderer.measure(this.isHorizontalAxis, this.labelStyle, majorTicks, this.getTicksMaxSize(), (_a = this.labelStyle) === null || _a === void 0 ? void 0 : _a.padding, this.labelProvider, this.drawLabels, drawTicks);
            this.axisTitleRenderer.measure(this.axisTitleStyle, this.isHorizontalAxis);
        }
        else {
            this.axisRenderer.desiredHeight = 0;
            this.axisRenderer.desiredWidth = 0;
            this.axisTitleRenderer.desiredHeight = 0;
            this.axisTitleRenderer.desiredWidth = 0;
        }
    }
    /**
     * Called internally - prepares render data before a draw operation
     */
    prepareRenderData() {
        Deleter_1.deleteSafe(this.coordCalcCache);
        this.coordCalcCache = this.getCurrentCoordinateCalculatorInternal();
    }
    /**
     * Called internally - draws the current axis using the {@link WebGL2RenderingContext}
     */
    draw(renderContext) {
        // Draw the Axis borders
        drawBorder_1.drawBorder(renderContext, this.webAssemblyContext2D, this.solidBrushCacheBorder, this.viewRect, this.axisBorder.borderLeft, this.axisBorder.borderTop, this.axisBorder.borderRight, this.axisBorder.borderBottom, this.axisBorder.color);
        if (!this.getIsValidForDrawing()) {
            return;
        }
        const tickObject = this.getTickCoordsAndLabels();
        const penForMinorGridlines = getPenForLines(this.penCacheForMinorGridLines, this.minorGridLineStyle.color, this.minorGridLineStyle.strokeThickness, this.minorGridLineStyle.strokeDasharray);
        const penForMajorGridlines = getPenForLines(this.penCacheForMajorGridLines, this.majorGridLineStyle.color, this.majorGridLineStyle.strokeThickness, this.majorGridLineStyle.strokeDasharray);
        const penForMinorTickLines = getPenForLines(this.penCacheForMinorTickLines, this.minorTickLineStyle.color, this.minorTickLineStyle.strokeThickness);
        const penForMajorTickLines = getPenForLines(this.penCacheForMajorTickLines, this.majorTickLineStyle.color, this.majorTickLineStyle.strokeThickness);
        // TODO HERE
        // pass tick pens to drawTicks, and then adjust this function to draw ticks as well as gridlines
        if (this.isPrimaryAxis) {
            // Draw axes and gridlines
            this.drawAxisBandsAndGridLines(renderContext, tickObject, penForMinorGridlines, penForMajorGridlines);
        }
        // Draw axis labels
        if (this.drawLabels) {
            this.axisRenderer.drawLabels(renderContext, this.axisAlignment, tickObject.majorTickLabels, tickObject.majorTickCoords, this.labelStyle, this.isVerticalChart, this.flippedCoordinates);
        }
        // Draw ticks
        if (this.drawMinorTickLines) {
            this.axisRenderer.drawTicks(renderContext, this.axisAlignment, tickObject.minorTickCoords, penForMinorTickLines, this.minorTickLineStyle);
        }
        if (this.drawMajorTickLines) {
            this.axisRenderer.drawTicks(renderContext, this.axisAlignment, tickObject.majorTickCoords, penForMajorTickLines, this.majorTickLineStyle);
        }
        // Draw axis title
        this.axisTitleRenderer.draw(renderContext, this.axisTitleStyle, this.axisAlignment, this.parentSurface.debugRendering);
    }
    /**
     * Function to draw axis areas with red color
     * @param renderContext
     */
    drawDebug(renderContext) {
        const drawTickViewRects = () => {
            const viewRect = this.axisRenderer.viewRect;
            const vecRects = new this.webAssemblyContext2D.VectorRectVertex();
            const brush = new this.webAssemblyContext2D.SCRTSolidBrush(parseColor_1.parseColorToUIntArgb("rgba(255,0,0,0.7)"), false);
            const nativeRect = createNativeRect_1.createNativeRect(this.webAssemblyContext2D, 0, 0, viewRect.width, viewRect.height);
            vecRects.push_back(nativeRect);
            renderContext.drawRects(vecRects, brush, viewRect.left, viewRect.top);
            nativeRect.delete();
            brush.delete();
            vecRects.delete();
        };
        drawTickViewRects();
        const drawTitleViewRects = () => {
            const viewRect = this.axisTitleRenderer.viewRect;
            const vecRects = new this.webAssemblyContext2D.VectorRectVertex();
            const brush = new this.webAssemblyContext2D.SCRTSolidBrush(parseColor_1.parseColorToUIntArgb("rgba(0,255,0,0.7)"), false);
            const nativeRect = createNativeRect_1.createNativeRect(this.webAssemblyContext2D, 0, 0, viewRect.width, viewRect.height);
            vecRects.push_back(nativeRect);
            renderContext.drawRects(vecRects, brush, viewRect.left, viewRect.top);
            nativeRect.delete();
            brush.delete();
            vecRects.delete();
        };
        drawTitleViewRects();
    }
    /**
     * @inheritDoc
     */
    getDefaultNonZeroRange() {
        return new NumberRange_1.NumberRange(0, 10);
    }
    /**
     * @Summary Part of AutoRanging - Gets the maximum range on this axis
     * @description The getMaximumRange function computes the {@link visibleRange} min and max that this axis must
     * have to display all the data in the chart.
     */
    getMaximumRange() {
        let maximumRange;
        if (this.parentSurface && this.parentSurface.renderableSeries.size() > 0) {
            maximumRange = this.isXAxis ? this.getMaxXRange() : this.getWindowedYRange(undefined);
        }
        const currentVisibleRange = this.visibleRange || this.getDefaultNonZeroRange();
        return maximumRange || currentVisibleRange;
    }
    /**
     * @summary Part of AutoRanging - gets the windowed maximum range for Y-Axes
     * @description Returns the max range only for that axis (by the data-series on it),
     * based on associated XAxis visible range of series on the same axis
     * @param xRanges (optional) if provided, we use previously calculated XAxis ranges
     * keyed by AxisId rather than calculate them again
     */
    getWindowedYRange(xRanges) {
        let maxRange;
        if (this.parentSurface) {
            const visibleSeries = this.parentSurface.renderableSeries
                .asArray()
                .filter(s => s.yAxisId === this.id && s.isVisible && s.hasDataSeriesValues());
            visibleSeries.forEach(rSeries => {
                // Get pre-calculated XRange if exists, otherwise, fetch from the axis for this series
                const xVisibleRange = (xRanges === null || xRanges === void 0 ? void 0 : xRanges.containsKey(rSeries.xAxisId)) ? xRanges.item(rSeries.xAxisId)
                    : this.getXVisibleRange(rSeries.xAxisId);
                const isXCategoryAxis = this.getIsXCategoryAxis(rSeries.xAxisId);
                if (xVisibleRange) {
                    const range = rSeries.getYRange(xVisibleRange, isXCategoryAxis);
                    if (range) {
                        maxRange = maxRange ? maxRange.union(range) : range;
                    }
                }
            });
        }
        if (maxRange === null || maxRange === void 0 ? void 0 : maxRange.isZero()) {
            maxRange = this.coerceZeroVisibleRange(maxRange);
        }
        if (this.growBy && maxRange) {
            maxRange = maxRange.growBy(this.growBy);
        }
        if (this.visibleRangeLimit && maxRange) {
            maxRange = maxRange.clip(this.visibleRangeLimit);
        }
        return maxRange || new NumberRange_1.NumberRange();
    }
    /**
     * Programmatically scrolls the axis by a number of pixels
     * @param pixelsToScroll The number of pixels to scroll
     * @param clipMode The clipping mode. See {@link EClipMode} for a list of values
     */
    scroll(pixelsToScroll, clipMode) {
        const startVisibleRange = this.visibleRange;
        if (startVisibleRange === undefined) {
            return false;
        }
        const translatedRange = this.getCurrentCoordinateCalculator().translateBy(pixelsToScroll, startVisibleRange);
        if (this.visibleRangeLimit) {
            if (translatedRange.min < this.visibleRangeLimit.min || translatedRange.max > this.visibleRangeLimit.max) {
                return false;
            }
        }
        this.visibleRange = translatedRange;
        return true;
    }
    /**
     * Programmatically zooms the axis by a min and max fraction
     * @param minFraction The Min fraction, e.g. 0.1 will zoom the lower part of the range 10%
     * @param maxFraction The Max fraction, e.g. 0.1 will zoom the upper part of the range 10%
     */
    zoomBy(minFraction, maxFraction) {
        const coordCalc = this.getCurrentCoordinateCalculator();
        const translatedRange = coordCalc.zoomTranslateBy(minFraction, maxFraction, this.visibleRange);
        if (translatedRange.max < translatedRange.min) {
            return;
        }
        if (this.visibleRangeLimit) {
            this.visibleRange = translatedRange.clip(this.visibleRangeLimit);
        }
        else {
            this.visibleRange = translatedRange;
        }
    }
    /**
     * @summary Programmatically zooms the axis with a from and to coordinate
     * @description Used by the {@link RubberBandXyZoomModifier}, which allows the user to draw a rectangle on the chart
     * to zoom in. The from / too coordinate are the x or y components of the rectangle corners used to zoom in
     * @param fromCoord a pixel coordinate to zoom from
     * @param toCoord a pixel coordinate to zoom to
     * @param duration The duration of animation in milliseconds. Pass 0 for no animation.
     * @param easingFunction An optional easing function passed to specify animation easing. See {@link TEasing} for a list of values
     */
    zoom(fromCoord, toCoord, duration = 0, easingFunction = EasingFunctions_1.easing.outExpo) {
        const coordCalc = this.getCurrentCoordinateCalculator();
        const fromValue = coordCalc.getDataValue(fromCoord);
        const toValue = coordCalc.getDataValue(toCoord);
        const min = fromValue < toValue ? fromValue : toValue;
        const max = fromValue < toValue ? toValue : fromValue;
        this.animateVisibleRange(new NumberRange_1.NumberRange(min, max), duration, easingFunction);
    }
    /**
     * @inheritDoc
     */
    delete() {
        super.delete();
        this.penCacheForMajorGridLines = Deleter_1.deleteSafe(this.penCacheForMajorGridLines);
        this.penCacheForMinorGridLines = Deleter_1.deleteSafe(this.penCacheForMinorGridLines);
        this.penCacheForMajorTickLines = Deleter_1.deleteSafe(this.penCacheForMajorTickLines);
        this.penCacheForMinorTickLines = Deleter_1.deleteSafe(this.penCacheForMinorTickLines);
    }
    /**
     * Returns the max size for major/minor ticks. Used in layout and passed to AxisRenderer
     * @protected
     */
    getTicksMaxSize() {
        var _a, _b, _c, _d;
        const majorTickSize = (_b = (_a = this.majorTickLineStyle) === null || _a === void 0 ? void 0 : _a.tickSize) !== null && _b !== void 0 ? _b : 0;
        const minorTickSize = (_d = (_c = this.minorTickLineStyle) === null || _c === void 0 ? void 0 : _c.tickSize) !== null && _d !== void 0 ? _d : 0;
        return Math.max(majorTickSize, minorTickSize);
    }
    /**
     * When true, the axis is valid for drawing
     */
    getIsValidForDrawing() {
        return this.isVisible;
    }
    /**
     * Called internally - draws the Axis Bands and Gridlines
     * @param renderContext The {@link WebGL2RenderingContext} used for drawing
     * @param tickObject The {@link TTickObject} contains the major, minor tick numeric values, coordinates and labels for drawing
     * @param penForMinorGridLines The {@link SCRTPen} for drawing minor gridlines in our WebGL graphics engine
     * @param penForMajorGridLines The {@link SCRTPen} for drawing major gridlines in our WebGL graphics engine
     */
    drawAxisBandsAndGridLines(renderContext, tickObject, penForMinorGridLines, penForMajorGridLines) {
        // Draw axis bands
        if (this.drawMajorBands) {
            const solidBrush = this.solidBrushCacheAxisBands.newBrush(this.axisBandsFill, true);
            renderContext.enqueueLayeredDraw(() => this.drawAxisBands(renderContext, tickObject.majorTicks, tickObject.majorTickCoords, solidBrush), RenderLayer_1.ERenderLayer.First);
        }
        // Draw minor grid lines
        if (this.drawMinorGridLines) {
            renderContext.enqueueLayeredDraw(() => this.drawGridLines(renderContext, tickObject.minorTickCoords, penForMinorGridLines), RenderLayer_1.ERenderLayer.Second);
        }
        // Draw major grid lines
        if (this.drawMajorGridLines) {
            renderContext.enqueueLayeredDraw(() => this.drawGridLines(renderContext, tickObject.majorTickCoords, penForMajorGridLines), RenderLayer_1.ERenderLayer.Third);
        }
    }
    /**
     * Called internally - draws the Axis Bands
     * @param renderContext The {@link WebGL2RenderingContext} used for drawing
     * @param ticks An array of tick numeric values
     * @param tickCoords An array of tick coordinates
     * @param brush The {@link SCRTSolidBrush} used to fill the axis band area in our WebGL graphics engine
     */
    drawAxisBands(renderContext, ticks, tickCoords, brush) {
        const { seriesViewRect } = this.parentSurface;
        const direction = this.isHorizontalAxis ? XyDirection_1.EXyDirection.XDirection : XyDirection_1.EXyDirection.YDirection;
        let min = 0;
        let max = this.isHorizontalAxis ? seriesViewRect.width : seriesViewRect.height;
        // Case where the axis is flipped, swap the min/max coords so we draw bands correctly
        const isFlipped = this.isAxisFlipped !== this.flippedCoordinates;
        if (isFlipped) {
            const temp = max;
            max = min;
            min = temp;
        }
        // Even/Odd calculation helps preserve order of bands as you scroll
        const firstTickIndex = this.getMajorTickIndex(ticks[0]);
        let isEven = firstTickIndex % 2 === 0;
        const vecRects = new this.webAssemblyContext2D.VectorRectVertex();
        const drawBand = (coord0, coord1, isThisBandEven) => {
            if (!isThisBandEven) {
                return;
            }
            const nativeRect = createNativeRect_1.createNativeRect(this.webAssemblyContext2D, direction === XyDirection_1.EXyDirection.YDirection ? 0 : coord0, direction === XyDirection_1.EXyDirection.YDirection ? coord0 : 0, direction === XyDirection_1.EXyDirection.YDirection ? seriesViewRect.width : coord1, direction === XyDirection_1.EXyDirection.YDirection ? coord1 : seriesViewRect.height);
            vecRects.push_back(nativeRect);
            nativeRect.delete();
        };
        ticks.forEach((mt, index) => {
            const coord0 = index === 0 ? min : tickCoords[index - 1];
            const coord1 = tickCoords[index];
            drawBand(coord0, coord1, isEven);
            isEven = !isEven;
        });
        // Draw the last band to the edge of the screen
        drawBand(max, tickCoords[ticks.length - 1], isEven);
        renderContext.drawRects(vecRects, brush, seriesViewRect.left, seriesViewRect.top);
        vecRects.delete();
    }
    /**
     * Called internally - draws the Axis Grid Lines
     * @param renderContext The {@link WebGL2RenderingContext} used for drawing
     * @param tickCoords An array of tick coordinates
     * @param linesPen The {@link SCRTPen} used to draw the axis gridlines in our WebGL graphics engine
     */
    drawGridLines(renderContext, tickCoords, linesPen) {
        const { seriesViewRect } = this.parentSurface;
        const vertices = new this.webAssemblyContext2D.VectorColorVertex();
        tickCoords.forEach(tc => {
            const x1 = this.isHorizontalAxis ? tc : 0;
            const x2 = this.isHorizontalAxis ? tc : seriesViewRect.width;
            const y1 = this.isHorizontalAxis ? 0 : tc;
            const y2 = this.isHorizontalAxis ? seriesViewRect.height : tc;
            const vertex = new this.webAssemblyContext2D.SCRTColorVertex(x1, y1);
            vertices.push_back(vertex);
            vertex.delete();
            const vertex2 = new this.webAssemblyContext2D.SCRTColorVertex(x2, y2);
            vertices.push_back(vertex2);
            vertex2.delete();
        });
        renderContext.drawLinesNative(vertices, linesPen, WebGlRenderContext2D_1.ELineDrawMode.DiscontinuousLine, seriesViewRect.left, seriesViewRect.top);
        vertices.delete();
    }
    getXVisibleRange(xAxisId) {
        return this.parentSurface.getXAxisById(xAxisId).visibleRange;
    }
    getIsXCategoryAxis(xAxisId) {
        return this.parentSurface.getXAxisById(xAxisId).type === AxisType_1.EAxisType.CategoryAxis;
    }
    /**
     * Returns an array of label strings for an array of major tick numeric values
     * @param majorTicks The major tick numeric values
     */
    getLabels(majorTicks) {
        return majorTicks.map(tick => this.labelProvider.formatLabel(tick));
    }
    /**
     * Gets the total range on the XAxis required to display all the series zoomed to fit on this axis
     */
    getXDataRange() {
        let maxRange;
        if (this.parentSurface) {
            const visibleSeries = this.parentSurface.renderableSeries
                .asArray()
                .filter(s => s.xAxisId === this.id && s.isVisible && s.hasDataSeriesValues());
            visibleSeries.forEach(rSeries => {
                const xRange = rSeries.getXRange();
                if (xRange) {
                    maxRange = !maxRange ? xRange : maxRange.union(xRange);
                }
            });
        }
        return maxRange;
    }
    /**
     * @inheritDoc
     */
    notifyPropertyChanged(propertyName) {
        if (propertyName === constants_1.PROPERTY.AXIS_TITLE && this.axisTitleRenderer) {
            this.axisTitleRenderer.text = this.axisTitle;
        }
        if (propertyName === constants_1.PROPERTY.IS_XAXIS) {
            if (this.axisAlignmentProperty === undefined) {
                this.axisAlignmentProperty = this.isXAxisProperty ? AxisAlignment_1.EAxisAlignment.Bottom : AxisAlignment_1.EAxisAlignment.Right;
            }
        }
        super.notifyPropertyChanged(propertyName);
    }
    getMajorTickIndex(tick) {
        const step = this.majorDeltaProperty;
        const index = tick / step;
        // TODO: Add IsLogarithmicAxis logic from AxisBase.cs
        // TODO: Add Category axis logic from AxisBase.cs
        return Math.round(index);
    }
    getMaxXRange() {
        let maximumRange = this.getXDataRange();
        // TODO: Coerce a zero range
        if (this.growBy) {
            maximumRange = maximumRange.growBy(this.growBy);
        }
        if (this.visibleRangeLimit) {
            maximumRange = maximumRange.clip(this.visibleRangeLimit);
        }
        return maximumRange;
    }
    getTicks() {
        const maxAutoTicks = this.getMaxAutoTicks();
        if (this.autoTicks) {
            const delta = this.deltaCalculator.getDeltaFromRange(this.visibleRange.min, this.visibleRange.max, this.minorsPerMajor, maxAutoTicks);
            this.minorDeltaProperty = delta.min;
            this.majorDeltaProperty = delta.max;
        }
        const majorTicks = this.tickProvider.getMajorTicks(this.minorDeltaProperty, this.majorDeltaProperty, this.visibleRange);
        const minorTicks = this.tickProvider.getMinorTicks(this.minorDeltaProperty, this.majorDeltaProperty, this.visibleRange);
        return {
            majorTicks,
            minorTicks
        };
    }
    getTickCoordsAndLabels() {
        const coordCalc = this.getCurrentCoordinateCalculator();
        const getTickCoords = (ticks) => ticks.map(el => coordCalc.getCoordinate(el));
        const { majorTicks, minorTicks } = this.getTicks();
        const majorTickLabels = this.getLabels(majorTicks);
        const majorTickCoords = getTickCoords(majorTicks);
        const minorTickCoords = getTickCoords(minorTicks);
        return {
            majorTicks,
            majorTickLabels,
            majorTickCoords,
            minorTicks,
            minorTickCoords
        };
    }
}
exports.AxisBase2D = AxisBase2D;
/** @ignore */
const getPenForLines = (penCache, stroke, strokeThickness, strokeDashArray) => {
    const penFromCache = penCache === null || penCache === void 0 ? void 0 : penCache.create({ stroke, strokeThickness, strokeDashArray });
    return penFromCache.scrtPen;
};
