"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxisCore = void 0;
const EasingFunctions_1 = require("../../../Core/Animations/EasingFunctions");
const NumberRangeAnimator_1 = require("../../../Core/Animations/NumberRangeAnimator");
const EventHandler_1 = require("../../../Core/EventHandler");
const Guard_1 = require("../../../Core/Guard");
const NumberRange_1 = require("../../../Core/NumberRange");
const Thickness_1 = require("../../../Core/Thickness");
const AutoRange_1 = require("../../../types/AutoRange");
const isRealNumber_1 = require("../../../utils/isRealNumber");
const defaultThemeColors_1 = require("../../Themes/defaultThemeColors");
const constants_1 = require("./constants");
const VisibleRangeChangedArgs_1 = require("./VisibleRangeChangedArgs");
/** @ignore */
const ZeroRangeGrowBy = 0.01;
/**
 * The base class for Axis within SciChart - High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}.
 * @description
 * AxisCore is a base class for both 2D & 3D Axis types in SciChart. Concrete types include:
 *
 *  - {@link NumericAxis}: a Numeric 2D value-axis
 *  - {@link CategoryAxis}: A category 2D axis used for stock chart applications
 *  - {@link NumericAxis3D}: A numeric 3D value-axis
 *
 *  Set axis on the {@link SciChartSurface.xAxes} or {@link SciChartSurface.yAxes} collections in 2D Charts.
 *  Set axis on the {@link SciChart3DSurface.xAxis}, {@link SciChart3DSurface.yAxis} or {@link SciChart3DSurface.zAxis} collections in 3D Charts.
 */
class AxisCore {
    /**
     * Creates an instance of an {@link AxisCore}
     * @param options Optional parameters of type {@link IAxisCoreOptions} used to define properties at instantiation time
     */
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        /**
         * An {@link EventHandler} which fires a callback when the {@link AxisCore.visibleRange} property changes.
         * @desc
         */
        this.visibleRangeChanged = new EventHandler_1.EventHandler();
        /**
         * Internal backing property for {@link AxisCore.id}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.idProperty = AxisCore.DEFAULT_AXIS_ID;
        /**
         * Internal backing property for {@link AxisCore.isAxis}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.isXAxisProperty = true;
        /**
         * Internal backing property for {@link AxisCore.minorsPerMajor}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.minorsPerMajorProperty = 5;
        /**
         * Internal backing property for {@link AxisCore.drawMajorGridLines}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.drawMajorGridLinesProperty = true;
        /**
         * Internal backing property for {@link AxisCore.drawMinorGridLines}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.drawMinorGridLinesProperty = true;
        /**
         * Internal backing property for {@link AxisCore.drawMajorTickLines}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.drawMajorTickLinesProperty = true;
        /**
         * Internal backing property for {@link AxisCore.drawMinorTickLines}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.drawMinorTickLinesProperty = true;
        /**
         * Internal backing property for {@link AxisCore.drawMajorBands}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.drawMajorBandsProperty = true;
        /**
         * Internal backing property for {@link AxisCore.drawLabels}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.drawLabelsProperty = true;
        /**
         * Internal backing property for {@link AxisCore.flippedCoordinates}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.flippedCoordinatesProperty = false;
        /**
         * Internal backing property for {@link AxisCore.tickTextBrush}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.tickTextBrushProperty = defaultThemeColors_1.defaultThemeColors.tickTextBrush;
        /**
         * Internal backing property for {@link AxisCore.axisBandsFill}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.axisBandsFillProperty = defaultThemeColors_1.defaultThemeColors.axisBandsFill;
        /**
         * Internal backing property for {@link AxisCore.autoRange}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.autoRangeProperty = AutoRange_1.EAutoRange.Once;
        /**
         * Internal backing property for {@link AxisCore.majorTickLineStyle}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.majorTickLineStyleProperty = {
            tickSize: 5,
            strokeThickness: 1,
            color: defaultThemeColors_1.defaultThemeColors.majorGridLineBrush
        };
        /**
         * Internal backing property for {@link AxisCore.minorTickLineStyle}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.minorTickLineStyleProperty = {
            tickSize: 3,
            strokeThickness: 1,
            color: defaultThemeColors_1.defaultThemeColors.minorGridLineBrush
        };
        /**
         * Internal backing property for {@link AxisCore.majorGridLineStyle}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.majorGridLineStyleProperty = {
            strokeThickness: 1,
            color: defaultThemeColors_1.defaultThemeColors.majorGridLineBrush,
            strokeDasharray: undefined
        };
        /**
         * Internal backing property for {@link AxisCore.minorGridLineStyle}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.minorGridLineStyleProperty = {
            strokeThickness: 1,
            color: defaultThemeColors_1.defaultThemeColors.minorGridLineBrush,
            strokeDasharray: undefined
        };
        /**
         * Internal backing property for {@link AxisCore.axisTitleStyle}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.axisTitleStyleProperty = {
            fontSize: 24,
            fontFamily: "Arial",
            color: defaultThemeColors_1.defaultThemeColors.axisTitleColor,
            fontStyle: "normal",
            fontWeight: "normal",
            padding: Thickness_1.Thickness.fromNumber(6)
        };
        /**
         * Internal backing property for {@link AxisCore.isVisible}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.isVisibleProperty = true;
        /**
         * Internal backing property for {@link AxisCore.autoTicks}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.autoTicksProperty = true;
        /**
         * Internal backing property for {@link AxisCore.maxAutoTicks}. To fire {@link AxisCore.invalidateParentCallback}, set the public property
         */
        this.maxAutoTicksProperty = 10;
        this.defaultVisibleRange = new NumberRange_1.NumberRange(0, 10);
        this.visibleRange = (_a = options === null || options === void 0 ? void 0 : options.visibleRange) !== null && _a !== void 0 ? _a : this.defaultVisibleRange;
        this.id = (_b = options === null || options === void 0 ? void 0 : options.id) !== null && _b !== void 0 ? _b : this.id;
        this.growBy = (_c = options === null || options === void 0 ? void 0 : options.growBy) !== null && _c !== void 0 ? _c : this.growBy;
        this.autoRange = (_d = options === null || options === void 0 ? void 0 : options.autoRange) !== null && _d !== void 0 ? _d : this.autoRange;
        this.isVisible = (_e = options === null || options === void 0 ? void 0 : options.isVisible) !== null && _e !== void 0 ? _e : this.isVisible;
        this.axisTitle = (_f = options === null || options === void 0 ? void 0 : options.axisTitle) !== null && _f !== void 0 ? _f : this.axisTitle;
        this.axisTitleStyle = (_g = options === null || options === void 0 ? void 0 : options.axisTitleStyle) !== null && _g !== void 0 ? _g : this.axisTitleStyle;
        // When we set this.isAxis the Alignment is set as well, so we set this.isXAxisProperty
        this.isXAxisProperty = (_h = options === null || options === void 0 ? void 0 : options.isXAxis) !== null && _h !== void 0 ? _h : this.isXAxisProperty;
        this.autoTicksProperty = (_j = options === null || options === void 0 ? void 0 : options.autoTicks) !== null && _j !== void 0 ? _j : this.autoTicksProperty;
        this.maxAutoTicksProperty = (_k = options === null || options === void 0 ? void 0 : options.maxAutoTicks) !== null && _k !== void 0 ? _k : this.maxAutoTicksProperty;
        this.drawLabelsProperty = (_l = options === null || options === void 0 ? void 0 : options.drawLabels) !== null && _l !== void 0 ? _l : this.drawLabelsProperty;
        this.drawMajorTickLinesProperty = (_m = options === null || options === void 0 ? void 0 : options.drawMajorTickLines) !== null && _m !== void 0 ? _m : this.drawMajorTickLinesProperty;
        this.drawMinorTickLinesProperty = (_o = options === null || options === void 0 ? void 0 : options.drawMinorTickLines) !== null && _o !== void 0 ? _o : this.drawMinorTickLinesProperty;
        this.majorGridLineStyleProperty = (_p = options === null || options === void 0 ? void 0 : options.majorGridLineStyle) !== null && _p !== void 0 ? _p : this.majorGridLineStyleProperty;
        this.minorGridLineStyleProperty = (_q = options === null || options === void 0 ? void 0 : options.minorGridLineStyle) !== null && _q !== void 0 ? _q : this.minorGridLineStyleProperty;
        this.majorTickLineStyleProperty = (_r = options === null || options === void 0 ? void 0 : options.majorTickLineStyle) !== null && _r !== void 0 ? _r : this.majorTickLineStyleProperty;
        this.minorTickLineStyleProperty = (_s = options === null || options === void 0 ? void 0 : options.minorTickLineStyle) !== null && _s !== void 0 ? _s : this.minorTickLineStyleProperty;
        this.drawMajorBandsProperty = (_t = options === null || options === void 0 ? void 0 : options.drawMajorBands) !== null && _t !== void 0 ? _t : this.drawMajorBandsProperty;
        this.axisBandsFillProperty = (_u = options === null || options === void 0 ? void 0 : options.axisBandsFill) !== null && _u !== void 0 ? _u : this.axisBandsFillProperty;
        this.flippedCoordinatesProperty = (_v = options === null || options === void 0 ? void 0 : options.flippedCoordinates) !== null && _v !== void 0 ? _v : this.flippedCoordinatesProperty;
    }
    /**
     * SET INTERNALLY. Gets or sets whether this axis is an XAxis or not
     * @remarks
     * See {@link AxisBase2D.axisAlignment} if you want to set a 2D Axis alignment to the left, right, top or bottom
     */
    get isXAxis() {
        return this.isXAxisProperty;
    }
    /**
     * SET INTERNALLY. Gets or sets whether this axis is an XAxis or not
     * @remarks
     * See {@link AxisBase2D.axisAlignment} if you want to set a 2D Axis alignment to the left, right, top or bottom
     */
    set isXAxis(isXAxis) {
        this.isXAxisProperty = isXAxis;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_XAXIS);
    }
    /**
     * When true, the axis has a valid {@link AxisCore.visibleRange} which can be drawn
     * @remarks
     * {@link AxisCore.visibleRange} undefined, or NAN, or infinite, or {@link AxisCore.visibleRange} min greater than max
     * will result in this property being false.
     */
    get hasValidVisibleRange() {
        if (this.visibleRange === undefined) {
            return false;
        }
        const rangeIsZero = this.visibleRange.diff === 0;
        return !rangeIsZero && isRealNumber_1.isRealNumber(this.visibleRange.max) && isRealNumber_1.isRealNumber(this.visibleRange.min);
    }
    /**
     * When true, the axis has the default {@link AxisCore.visibleRange}.
     * @remarks
     * This property is used internally when autoranging. If the range is default and {@link AxisCore.autoRange} is {@link EAutoRange.Once}
     * then the axis will autorange once.
     */
    get hasDefaultVisibleRange() {
        return this.visibleRange === this.defaultVisibleRange;
    }
    /**
     * Gets or sets the unique Axis Id
     * @description
     * By default all axis in SciChart have Id={@link AxisCore.DEFAULT_AXIS_ID}. Also, all {@link BaseRenderableSeries | RenderableSeries}
     * have an xAxisId and yAxisId property set to {@link AxisCore.DEFAULT_AXIS_ID}. {@link AnnotationBase | Annotations} also have an xAxisId and
     * yAxisId also set to {@link AxisCore.DEFAULT_AXIS_ID}. Some {@link ChartModifierBase | Chart Modifiers} have an x,yAxisId property to filter
     * their operations to an axis.
     *
     * In multi-axis scenarios you will need to set the xAxisId/yAxisId properties of series, annotations, modifiers to match that of the axis
     * you want them to be registered on.
     */
    get id() {
        return this.idProperty;
    }
    /**
     * Gets or sets the unique Axis Id
     * @description
     * By default all axis in SciChart have Id={@link AxisCore.DEFAULT_AXIS_ID}. Also, all {@link BaseRenderableSeries | RenderableSeries}
     * have an xAxisId and yAxisId property set to {@link AxisCore.DEFAULT_AXIS_ID}. {@link AnnotationBase | Annotations} also have an xAxisId and
     * yAxisId also set to {@link AxisCore.DEFAULT_AXIS_ID}. Some {@link ChartModifierBase | Chart Modifiers} have an x,yAxisId property to filter
     * their operations to an axis.
     *
     * In multi-axis scenarios you will need to set the xAxisId/yAxisId properties of series, annotations, modifiers to match that of the axis
     * you want them to be registered on.
     */
    set id(id) {
        this.idProperty = id;
        this.notifyPropertyChanged(constants_1.PROPERTY.ID);
    }
    /**
     * When true, the axis is visible. Default value is also true for the axis
     * @remarks
     * An invisible axis can be used to scale series to the viewport. For example:
     *
     *  - have a chart with two-YAxis
     *  - have one series on the first axis and another series on the second axis
     *  - set second {@link AxisCore.isVisible} = false, and {@link AxisCore.autoRange} = {@link EAutoRange.Always}
     *
     *  This will scale the series on the second axis to the viewport, on an invisible, auto-ranged axis
     */
    get isVisible() {
        return this.isVisibleProperty;
    }
    /**
     * When true, the axis is visible. Default value is also true for the axis
     * @remarks
     * An invisible axis can be used to scale series to the viewport. For example:
     *
     *  - have a chart with two-YAxis
     *  - have one series on the first axis and another series on the second axis
     *  - set second {@link AxisCore.isVisible} = false, and {@link AxisCore.autoRange} = {@link EAutoRange.Always}
     *
     *  This will scale the series on the second axis to the viewport, on an invisible, auto-ranged axis
     */
    set isVisible(isVisible) {
        this.isVisibleProperty = isVisible;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_VISIBLE);
    }
    /**
     * Gets or sets the GrowBy: a padding factor on the axis
     * @description
     * Growby factor is a padding factor set on the axis. For example if you want to have a constant padding above and below the axis,
     * the following code will result in a 10% (min) and 20% (max) padding outside of the datarange.
     * ```ts
     * axis.growBy = new NumberRange(0.1, 0.2);
     * ```
     */
    get growBy() {
        return this.growByProperty;
    }
    /**
     * Gets or sets the GrowBy: a padding factor on the axis
     * @description
     * Growby factor is a padding factor set on the axis. For example if you want to have a constant padding above and below the axis,
     * the following code will result in a 10% (min) and 20% (max) padding outside of the datarange.
     * ```ts
     * axis.growBy = new NumberRange(0.1, 0.2);
     * ```
     */
    set growBy(growBy) {
        this.growByProperty = growBy;
        this.notifyPropertyChanged(constants_1.PROPERTY.GROW_BY);
    }
    /**
     * The VisibleRange is the range of the Axis (min to max).
     * @description
     * For example, if you have data-values from 0 to 100 in your {@link XyDataSeries | DataSeries}, but you only want to show
     * values from 15-25 on the axis, then set the visibleRange as follows:
     * ```ts
     * axis.visibleRange = new NumberRange(15, 25);
     * ```
     * @remarks
     * The visibleRange is a data-value for {@link NumericAxis}, @{link NumericAxis3D} but refers to an **index** to the data
     * for {@link CategoryAxis} types.
     */
    get visibleRange() {
        return this.visibleRangeProperty;
    }
    /**
     * The VisibleRange is the range of the Axis (min to max).
     * @description
     * For example, if you have data-values from 0 to 100 in your {@link XyDataSeries | DataSeries}, but you only want to show
     * values from 15-25 on the axis, then set the visibleRange as follows:
     * ```ts
     * axis.visibleRange = new NumberRange(15, 25);
     * ```
     * @remarks
     * The visibleRange is a data-value for {@link NumericAxis}, @{link NumericAxis3D} but refers to an **index** to the data
     * for {@link CategoryAxis} types.
     */
    set visibleRange(visibleRange) {
        if (this.visibleRangeProperty !== visibleRange) {
            this.visibleRangeProperty = visibleRange;
            this.visibleRangeChanged.raiseEvent(new VisibleRangeChangedArgs_1.VisibleRangeChangedArgs(visibleRange));
            this.notifyPropertyChanged(constants_1.PROPERTY.VISIBLE_RANGE);
        }
    }
    /**
     * Sets and animates the visibleRange of the axis from the current value to the provided value over the duration and with
     * {@link TEasing | Easing Function} provided
     * @param visibleRange the {@link NumberRange} which we wish to animate {@link AxisCore.visibleRange} to
     * @param durationMs the duration of the animation in milliseconds
     * @param easingFunction the {@link TEasing | Easing Function to use}. Default value is outCubic
     * @param onCompleted the callback function
     */
    animateVisibleRange(visibleRange, durationMs, easingFunction = EasingFunctions_1.easing.outCubic, onCompleted = () => { }) {
        var _a;
        if (durationMs <= 0) {
            this.visibleRange = visibleRange;
            onCompleted();
            return undefined;
        }
        (_a = this.visibleRangeAnimationToken) === null || _a === void 0 ? void 0 : _a.cancelAnimation();
        this.visibleRangeAnimationToken = NumberRangeAnimator_1.NumberRangeAnimator.animate(this.visibleRange, visibleRange, durationMs, range => {
            this.visibleRange = range;
        }, onCompleted, easingFunction);
        return this.visibleRangeAnimationToken;
    }
    /**
     * The MajorDelta is the spacing between major gridlines and axis labels.
     * @remarks
     * This is internally computed via the {@link AxisCore.deltaCalculator | Delta Calculator}, however it can be explicitly set here
     * in which case you should also set {@link AxisCore.minorDelta} and {@link AxisCore.autoTicks} = false.
     *
     * It is also possible to override and create custom implementations of the {@link DeltaCalculator} for full control over axis gridline
     * spacing.
     */
    get majorDelta() {
        return this.majorDeltaProperty;
    }
    /**
     * The MajorDelta is the spacing between major gridlines and axis labels.
     * @remarks
     * This is internally computed via the {@link AxisCore.deltaCalculator | Delta Calculator}, however it can be explicitly set here
     * in which case you should also set {@link AxisCore.minorDelta} and {@link AxisCore.autoTicks} = false.
     *
     * It is also possible to override and create custom implementations of the {@link DeltaCalculator} for full control over axis gridline
     * spacing.
     */
    set majorDelta(majorDelta) {
        this.majorDeltaProperty = majorDelta;
        this.notifyPropertyChanged(constants_1.PROPERTY.MAJOR_DELTA);
    }
    /**
     * The MinorDelta is the spacing between minor gridlines.
     * @remarks
     * This is internally computed via the {@link AxisCore.deltaCalculator | Delta Calculator}, however it can be explicitly set here
     * in which case you should also set {@link AxisCore.majorDelta} and {@link AxisCore.autoTicks} = false.
     *
     * It is also possible to override and create custom implementations of the {@link DeltaCalculator} for full control over axis gridline
     * spacing.
     */
    get minorDelta() {
        return this.minorDeltaProperty;
    }
    /**
     * The MinorDelta is the spacing between minor gridlines.
     * @remarks
     * This is internally computed via the {@link AxisCore.deltaCalculator | Delta Calculator}, however it can be explicitly set here
     * in which case you should also set {@link AxisCore.majorDelta} and {@link AxisCore.autoTicks} = false.
     *
     * It is also possible to override and create custom implementations of the {@link DeltaCalculator} for full control over axis gridline
     * spacing.
     */
    set minorDelta(minorDelta) {
        this.minorDeltaProperty = minorDelta;
        this.notifyPropertyChanged(constants_1.PROPERTY.MINOR_DELTA);
    }
    /**
     * When {@link AxisCore.autoTicks} is true, minorsPerMajor is a hint of how many minor gridlines should be drawn between each major gridline
     */
    get minorsPerMajor() {
        return this.minorsPerMajorProperty;
    }
    /**
     * When {@link AxisCore.autoTicks} is true, minorsPerMajor is a hint of how many minor gridlines should be drawn between each major gridline
     */
    set minorsPerMajor(minorDelta) {
        this.minorsPerMajorProperty = minorDelta;
        this.notifyPropertyChanged(constants_1.PROPERTY.MINORS_PER_MAJOR);
    }
    // TODO: These need to be implemented or removed
    get textFormatting() {
        return this.textFormattingProperty;
    }
    set textFormatting(textFormatting) {
        this.textFormattingProperty = textFormatting;
        this.notifyPropertyChanged(constants_1.PROPERTY.TEXT_FORMATTING);
    }
    get cursorTextFormatting() {
        return this.cursorTextFormattingProperty;
    }
    set cursorTextFormatting(cursorTextFormatting) {
        this.cursorTextFormattingProperty = cursorTextFormatting;
        this.notifyPropertyChanged(constants_1.PROPERTY.CURSOR_TEXT_FORMATTING);
    }
    /**
     * When true, major gridlines (lines inside the chart viewport area) are drawn, else they are not drawn
     * @description
     * SciChart makes a distinction between axis Gridlines (drawn inside the chart) and axis ticks (small marks drawn outside the chart).
     *
     * Also, an Axis draws its own gridlines, for example a YAxis, which is vertical in a 2D Chart, draws gridlines horizontally at y-spacings.
     *
     * Similarly, an XAxis, which is horizontal in a 2D chart, draws gridlines vertically at X-spacings.
     * @remarks
     * See also {@link AxisCore.majorGridLineStyle} to style the major gridlines
     */
    get drawMajorGridLines() {
        return this.drawMajorGridLinesProperty;
    }
    /**
     * When true, major gridlines (lines inside the chart viewport area) are drawn, else they are not drawn
     * @description
     * SciChart makes a distinction between axis Gridlines (drawn inside the chart) and axis ticks (small marks drawn outside the chart).
     *
     * Also, an Axis draws its own gridlines, for example a YAxis, which is vertical in a 2D Chart, draws gridlines horizontally at y-spacings.
     *
     * Similarly, an XAxis, which is horizontal in a 2D chart, draws gridlines vertically at X-spacings.
     * @remarks
     * See also {@link AxisCore.majorGridLineStyle} to style the major gridlines
     */
    set drawMajorGridLines(drawMajorGridLines) {
        this.drawMajorGridLinesProperty = drawMajorGridLines;
        this.notifyPropertyChanged(constants_1.PROPERTY.DRAW_MAJOR_GRID_LINES);
    }
    /**
     * When true, minor gridlines (lines inside the chart viewport area) are drawn, else they are not drawn
     * @description
     * SciChart makes a distinction between axis Gridlines (drawn inside the chart) and axis ticks (small marks drawn outside the chart).
     *
     * Also, an Axis draws its own gridlines, for example a YAxis, which is vertical in a 2D Chart, draws gridlines horizontally at y-spacings.
     *
     * Similarly, an XAxis, which is horizontal in a 2D chart, draws gridlines vertically at X-spacings.
     * @remarks
     * See also {@link AxisCore.minorGridLineStyle} to style the minor gridlines
     */
    get drawMinorGridLines() {
        return this.drawMinorGridLinesProperty;
    }
    /**
     * When true, minor gridlines (lines inside the chart viewport area) are drawn, else they are not drawn
     * @description
     * SciChart makes a distinction between axis Gridlines (drawn inside the chart) and axis ticks (small marks drawn outside the chart).
     *
     * Also, an Axis draws its own gridlines, for example a YAxis, which is vertical in a 2D Chart, draws gridlines horizontally at y-spacings.
     *
     * Similarly, an XAxis, which is horizontal in a 2D chart, draws gridlines vertically at X-spacings.
     * @remarks
     * See also {@link AxisCore.minorGridLineStyle} to style the minor gridlines
     */
    set drawMinorGridLines(drawMinorGridLines) {
        this.drawMinorGridLinesProperty = drawMinorGridLines;
        this.notifyPropertyChanged(constants_1.PROPERTY.DRAW_MINOR_GRID_LINES);
    }
    /**
     * When true, major gridlines (small lines outside the chart viewport area) are drawn, else they are not drawn
     * @description
     * SciChart makes a distinction between axis Gridlines (drawn inside the chart) and axis ticks (small marks drawn outside the chart).
     *
     * Also, an Axis draws its own ticklines, for example a YAxis, which is vertical in a 2D Chart, draws ticklines horizontally at y-spacings.
     *
     * Similarly, an XAxis, which is horizontal in a 2D chart, draws ticklines vertically at X-spacings.
     * @remarks
     * See also {@link AxisCore.majorTickLineStyle} to style the major tick lines
     */
    get drawMajorTickLines() {
        return this.drawMajorTickLinesProperty;
    }
    /**
     * When true, major gridlines (small lines outside the chart viewport area) are drawn, else they are not drawn
     * @description
     * SciChart makes a distinction between axis Gridlines (drawn inside the chart) and axis ticks (small marks drawn outside the chart).
     *
     * Also, an Axis draws its own ticklines, for example a YAxis, which is vertical in a 2D Chart, draws ticklines horizontally at y-spacings.
     *
     * Similarly, an XAxis, which is horizontal in a 2D chart, draws ticklines vertically at X-spacings.
     * @remarks
     * See also {@link AxisCore.majorTickLineStyle} to style the major tick lines
     */
    set drawMajorTickLines(drawMajorTickLines) {
        this.drawMajorTickLinesProperty = drawMajorTickLines;
        this.notifyPropertyChanged(constants_1.PROPERTY.DRAW_MAJOR_TICK_LINES);
    }
    /**
     * When true, minor gridlines (small lines outside the chart viewport area) are drawn, else they are not drawn
     * @description
     * SciChart makes a distinction between axis Gridlines (drawn inside the chart) and axis ticks (small marks drawn outside the chart).
     *
     * Also, an Axis draws its own ticklines, for example a YAxis, which is vertical in a 2D Chart, draws ticklines horizontally at y-spacings.
     *
     * Similarly, an XAxis, which is horizontal in a 2D chart, draws ticklines vertically at X-spacings.
     * @remarks
     * See also {@link AxisCore.minorTickLineStyle} to style the minor tick lines
     */
    get drawMinorTickLines() {
        return this.drawMinorTickLinesProperty;
    }
    /**
     * When true, minor gridlines (small lines outside the chart viewport area) are drawn, else they are not drawn
     * @description
     * SciChart makes a distinction between axis Gridlines (drawn inside the chart) and axis ticks (small marks drawn outside the chart).
     *
     * Also, an Axis draws its own ticklines, for example a YAxis, which is vertical in a 2D Chart, draws ticklines horizontally at y-spacings.
     *
     * Similarly, an XAxis, which is horizontal in a 2D chart, draws ticklines vertically at X-spacings.
     * @remarks
     * See also {@link AxisCore.minorTickLineStyle} to style the minor tick lines
     */
    set drawMinorTickLines(drawMinorTickLines) {
        this.drawMinorTickLinesProperty = drawMinorTickLines;
        this.notifyPropertyChanged(constants_1.PROPERTY.DRAW_MINOR_TICK_LINES);
    }
    /**
     * When true, draws bands, a solid color fill between alternative major gridlines, else they are not drawn
     * @remarks
     * See also the {@link AxisCore.axisBandsFill} property to style this element
     */
    get drawMajorBands() {
        return this.drawMajorBandsProperty;
    }
    /**
     * When true, draws bands, a solid color fill between alternative major gridlines, else they are not drawn
     * @remarks
     * See also the {@link AxisCore.axisBandsFill} property to style this element
     */
    set drawMajorBands(drawMajorBands) {
        this.drawMajorBandsProperty = drawMajorBands;
        this.notifyPropertyChanged(constants_1.PROPERTY.DRAW_MAJOR_BANDS);
    }
    // TODO: We need a way to set Font family, style and color for axis labels and add @remarks here like other properties
    /**
     * When true, draws labels on the axis, else they are not drawn
     */
    get drawLabels() {
        return this.drawLabelsProperty;
    }
    // TODO: We need a way to set Font family, style and color for axis labels and add @remarks here like other properties
    /**
     * When true, draws labels on the axis, else they are not drawn
     */
    set drawLabels(drawLabels) {
        this.drawLabelsProperty = drawLabels;
        this.notifyPropertyChanged(constants_1.PROPERTY.DRAW_LABELS);
    }
    /**
     * When true, axis coordinates are flipped, e.g. a {@link NumericAxis} with @{link AxisCore.visibleRange | VisibleRange}
     * 0..10 will render from 10 to 0
     */
    get flippedCoordinates() {
        return this.flippedCoordinatesProperty;
    }
    /**
     * When true, axis coordinates are flipped, e.g. a {@link NumericAxis} with @{link AxisCore.visibleRange | VisibleRange}
     * 0..10 will render from 10 to 0
     */
    set flippedCoordinates(flippedCoordinates) {
        this.flippedCoordinatesProperty = flippedCoordinates;
        this.notifyPropertyChanged(constants_1.PROPERTY.FLIPPED_COORDINATES);
    }
    /**
     * Gets or sets the Axis Bands fill as an HTML Color code
     * @remarks See {@link AxisCore.drawMajorBands} to switch band drawing on and off
     */
    get axisBandsFill() {
        return this.axisBandsFillProperty;
    }
    /**
     * Gets or sets the Axis Bands fill as an HTML Color code
     * @remarks See {@link AxisCore.drawMajorBands} to switch band drawing on and off
     */
    set axisBandsFill(axisBandsFill) {
        this.axisBandsFillProperty = axisBandsFill;
        this.notifyPropertyChanged(constants_1.PROPERTY.AXIS_BANDS_FILL);
    }
    /**
     * gets or sets the Auto-Ranging behaviour on the axis. See {@link EAutoRange} for a list of values. The default value is
     * {@link EAutoRange.Once}
     */
    get autoRange() {
        return this.autoRangeProperty;
    }
    /**
     * gets or sets the Auto-Ranging behaviour on the axis. See {@link EAutoRange} for a list of values. The default value is
     * {@link EAutoRange.Once}
     */
    set autoRange(autoRange) {
        this.autoRangeProperty = autoRange;
        this.notifyPropertyChanged(constants_1.PROPERTY.AUTO_RANGE);
    }
    /**
     * @summary Gets or sets the Major Tick lines style
     * @remarks See {@link TTickLineStyle} for the type which contains style options
     */
    get majorTickLineStyle() {
        return this.majorTickLineStyleProperty;
    }
    /**
     * @summary Gets or sets the Major Tick lines style
     * @remarks See {@link TTickLineStyle} for the type which contains style options
     */
    set majorTickLineStyle(majorTickLineStyle) {
        this.majorTickLineStyleProperty = Object.assign(Object.assign({}, this.majorTickLineStyle), majorTickLineStyle);
        this.notifyPropertyChanged(constants_1.PROPERTY.MAJOR_TICK_LINE_STYLE);
    }
    /**
     * @summary Gets or sets the Minor Tick lines style
     * @remarks See {@link TTickLineStyle} for the type which contains style options
     */
    get minorTickLineStyle() {
        return this.minorTickLineStyleProperty;
    }
    /**
     * @summary Gets or sets the Minor Tick lines style
     * @remarks See {@link TTickLineStyle} for the type which contains style options
     */
    set minorTickLineStyle(minorTickLineStyle) {
        this.minorTickLineStyleProperty = Object.assign(Object.assign({}, this.minorTickLineStyle), minorTickLineStyle);
        this.notifyPropertyChanged(constants_1.PROPERTY.MINOR_TICK_LINE_STYLE);
    }
    /**
     * @summary Gets or sets the Major gridlines style
     * @remarks See {@link TGridLineStyle} for the type which contains style options
     */
    get majorGridLineStyle() {
        return this.majorGridLineStyleProperty;
    }
    /**
     * @summary Gets or sets the Major gridlines style
     * @remarks See {@link TGridLineStyle} for the type which contains style options
     */
    set majorGridLineStyle(majorGridLineStyle) {
        this.majorGridLineStyleProperty = Object.assign(Object.assign({}, this.majorGridLineStyle), majorGridLineStyle);
        this.notifyPropertyChanged(constants_1.PROPERTY.MAJOR_GRID_LINE_STYLE);
    }
    /**
     * @summary Gets or sets the Minor gridlines style
     * @remarks See {@link TGridLineStyle} for the type which contains style options
     */
    get minorGridLineStyle() {
        return this.minorGridLineStyleProperty;
    }
    /**
     * @summary Gets or sets the Minor gridlines style
     * @remarks See {@link TGridLineStyle} for the type which contains style options
     */
    set minorGridLineStyle(minorGridLineStyle) {
        this.minorGridLineStyleProperty = Object.assign(Object.assign({}, this.minorGridLineStyle), minorGridLineStyle);
        this.notifyPropertyChanged(constants_1.PROPERTY.MINOR_GRID_LINE_STYLE);
    }
    /**
     * @summary Gets or sets the Axis Title style
     * @remarks See {@link TTextStyle} for the type which contains style options
     */
    get axisTitleStyle() {
        return this.axisTitleStyleProperty;
    }
    /**
     * @summary Gets or sets the Axis Title style
     * @remarks See {@link TTextStyle} for the type which contains style options
     */
    set axisTitleStyle(textStyle) {
        this.axisTitleStyleProperty = Object.assign(Object.assign({}, this.axisTitleStyle), textStyle);
        this.notifyPropertyChanged(constants_1.PROPERTY.TEXT_STYLE);
    }
    /**
     * Gets or sets the Axis title string
     */
    get axisTitle() {
        return this.axisTitleProperty;
    }
    /**
     * Gets or sets the Axis title string
     */
    set axisTitle(axisTitle) {
        this.axisTitleProperty = axisTitle;
        this.notifyPropertyChanged(constants_1.PROPERTY.AXIS_TITLE);
    }
    /**
     * Gets or sets a {@link TickProvider} - a class which calculates ticks (interval between major and minor gridlines, ticks and labels)
     */
    get tickProvider() {
        return this.tickProviderProperty;
    }
    /**
     * Gets or sets a {@link TickProvider} - a class which calculates ticks (interval between major and minor gridlines, ticks and labels)
     * @param tickProvider
     */
    set tickProvider(tickProvider) {
        this.tickProviderProperty = tickProvider;
        this.notifyPropertyChanged(constants_1.PROPERTY.TICK_PROVIDER);
    }
    /**
     * Gets or sets a {@link LabelProvider} - a class which is responsible for formatting axis labels and cursor labels from numeric values
     */
    get labelProvider() {
        return this.labelProviderProperty;
    }
    /**
     * Gets or sets a {@link LabelProvider} - a class which is responsible for formatting axis labels and cursor labels from numeric values
     */
    set labelProvider(labelProvider) {
        this.labelProviderProperty = labelProvider;
        this.notifyPropertyChanged(constants_1.PROPERTY.LABEL_PROVIDER);
    }
    /**
     * Gets or sets a {@link DeltaCalculator} - a class which is responsible for calculating the Major and Minor delta,
     * which are used for gridline spacing
     */
    get deltaCalculator() {
        return this.deltaCalculatorProperty;
    }
    /**
     * Gets or sets a {@link DeltaCalculator} - a class which is responsible for calculating the Major and Minor delta,
     * which are used for gridline spacing
     */
    set deltaCalculator(deltaCalculator) {
        this.deltaCalculatorProperty = deltaCalculator;
        this.notifyPropertyChanged(constants_1.PROPERTY.DELTA_CALCULATOR);
    }
    /**
     * Gets or sets the max-auto-ticks. A hint which limits the number of major gridlines and labels (aka major ticks) on the axis
     * at any one time. This value is a hint, and actual value of ticks may be lower than this
     */
    get maxAutoTicks() {
        return this.maxAutoTicksProperty;
    }
    /**
     * Gets or sets the max-auto-ticks. A hint which limits the number of major gridlines and labels (aka major ticks) on the axis
     * at any one time. This value is a hint, and actual value of ticks may be lower than this
     */
    set maxAutoTicks(value) {
        this.maxAutoTicksProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.MAX_AUTO_TICKS);
    }
    /**
     * A boolean flag, when true, the axis will automatically calculate its Major and Minor delta.
     * When false, the user can specify or set these properties for overriding axis gridline spacing
     */
    get autoTicks() {
        return this.autoTicksProperty;
    }
    /**
     * A boolean flag, when true, the axis will automatically calculate its Major and Minor delta.
     * When false, the user can specify or set these properties for overriding axis gridline spacing
     */
    set autoTicks(value) {
        this.autoTicksProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.AUTO_TICKS);
    }
    /**
     * Gets the current {@link CoordinateCalculatorBase} instance. Valid for this render-pass only, the coordinate-calculator
     * allows you to transform between pixel and data coordinates (and vice versa)
     */
    getCurrentCoordinateCalculator() {
        if (!this.coordCalcCache) {
            this.coordCalcCache = this.getCurrentCoordinateCalculatorInternal();
        }
        return this.coordCalcCache;
    }
    /**
     * @inheritDoc
     */
    delete() {
        // Nothing to delete
    }
    /**
     * Tests whether the range passed in is valid
     * @param range The range
     */
    isValidRange(range) {
        const isInvalid = !range || !range.isDefined() || range.min > range.max;
        return !isInvalid;
    }
    coerceZeroVisibleRange(range) {
        Guard_1.Guard.notNull(range, "range");
        if (range.isZero()) {
            return range.growBy(new NumberRange_1.NumberRange(ZeroRangeGrowBy, ZeroRangeGrowBy));
        }
        return range;
    }
    /**
     * Notifies listeners to {@link AxisCore.invalidateParentCallback} that a property has changed and the parent chart needs to be redrawn.
     * @remarks Override this in derived classes if you want to notified of a specific property change
     * @param propertyName The property name which has changed.
     */
    notifyPropertyChanged(propertyName) {
        var _a, _b, _c;
        if (propertyName === constants_1.PROPERTY.DELTA_CALCULATOR) {
            (_a = this.deltaCalculator) === null || _a === void 0 ? void 0 : _a.attachedToAxis(this);
        }
        if (propertyName === constants_1.PROPERTY.TICK_PROVIDER) {
            (_b = this.tickProvider) === null || _b === void 0 ? void 0 : _b.attachedToAxis(this);
        }
        if (propertyName === constants_1.PROPERTY.LABEL_PROVIDER) {
            (_c = this.labelProvider) === null || _c === void 0 ? void 0 : _c.attachedToAxis(this);
        }
        if (this.invalidateParentCallback) {
            this.invalidateParentCallback();
        }
    }
    getMaxAutoTicks() {
        return Math.max(1, this.maxAutoTicks);
    }
}
exports.AxisCore = AxisCore;
/**
 * The Default {@link AxisCore.id}
 * @description
 * By default all axis in SciChart have Id={@link AxisCore.DEFAULT_AXIS_ID}. Also, all {@link BaseRenderableSeries | RenderableSeries}
 * have an xAxisId and yAxisId property set to {@link AxisCore.DEFAULT_AXIS_ID}. {@link AnnotationBase | Annotations} also have an xAxisId and
 * yAxisId also set to {@link AxisCore.DEFAULT_AXIS_ID}. Some {@link ChartModifierBase | Chart Modifiers} have an x,yAxisId property to filter
 * their operations to an axis.
 *
 * In multi-axis scenarios you will need to set the xAxisId/yAxisId properties of series, annotations, modifiers to match that of the axis
 * you want them to be registered on.
 */
AxisCore.DEFAULT_AXIS_ID = "DefaultAxisId";
