"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CategoryAxis = void 0;
const Deleter_1 = require("../../../Core/Deleter");
const NumberRange_1 = require("../../../Core/NumberRange");
const AxisType_1 = require("../../../types/AxisType");
const NumericFormat_1 = require("../../../types/NumericFormat");
const CategoryCoordinateCalculator_1 = require("../../Numerics/CoordinateCalculators/CategoryCoordinateCalculator");
const FlippedCategoryCoordinateCalculator_1 = require("../../Numerics/CoordinateCalculators/FlippedCategoryCoordinateCalculator");
const NumericTickProvider_1 = require("../../Numerics/TickProviders/NumericTickProvider");
const AxisBase2D_1 = require("./AxisBase2D");
const NumericDeltaCalculator_1 = require("./DeltaCalculator/NumericDeltaCalculator");
const NumericLabelProvider_1 = require("./LabelProvider/NumericLabelProvider");
/**
 * @summary A 2D Chart Category Axis type
 * @description A category axis uses the X-index not the X-value to measure data-points on the XAxis.
 * For example this can be used in stock chart applications to ensure weekend or overnight gaps are collapsed
 * and each data-point is spaced equidistantly
 * @remarks
 * Set a {@link CategoryAxis} on the {@link SciChartSurface.xAxes} property. This axis type is not valid for YAxis
 */
class CategoryAxis extends AxisBase2D_1.AxisBase2D {
    /**
     * Creates an instance of a {@link CategoryAxis}
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param options Optional parameters of type {@link ICategoryAxisOptions} used to configure the axis at instantiation time
     */
    constructor(webAssemblyContext, options) {
        super(webAssemblyContext, options);
        this.type = AxisType_1.EAxisType.CategoryAxis;
        this.tickProvider = new NumericTickProvider_1.NumericTickProvider(this.webAssemblyContext2D);
        this.labelProvider = new NumericLabelProvider_1.NumericLabelProvider(NumericFormat_1.ENumericFormat.Date_DDMMYYYY);
        this.deltaCalculator = new NumericDeltaCalculator_1.NumericDeltaCalculator(this.webAssemblyContext2D);
    }
    /**
     * @inheritDoc
     */
    prepareRenderData() {
        Deleter_1.deleteSafe(this.coordCalcCache);
        const coordCalc = this.getCurrentCoordinateCalculatorInternal();
        const scs = this.parentSurface;
        const renderableSeries = scs.renderableSeries.asArray().find(rs => rs.xAxisId === this.id);
        if (!renderableSeries) {
            throw new Error(`category x axis with id=${this.id} should have renderable series`);
        }
        if (!renderableSeries.hasDataSeries()) {
            throw new Error(`category x axis with id=${this.id} should have data series`);
        }
        const dataSeriesLength = renderableSeries.getDataSeriesValuesCount();
        if (dataSeriesLength === 0) {
            throw new Error(`category x axis with id=${this.id} should have data series count > 0`);
        }
        coordCalc.baseXValues = renderableSeries.getBaseXValues();
        this.coordCalcCache = coordCalc;
    }
    /**
     * @inheritDoc
     */
    getCurrentCoordinateCalculatorInternal() {
        const { seriesViewRect } = this.parentSurface;
        const min = this.visibleRange.min;
        const max = this.visibleRange.max;
        const size = this.isHorizontalAxis ? seriesViewRect.width : seriesViewRect.height;
        const shouldFlip = !(this.isXAxis !== this.flippedCoordinates);
        return shouldFlip
            ? new FlippedCategoryCoordinateCalculator_1.FlippedCategoryCoordinateCalculator(this.webAssemblyContext2D, size, 0, 0, min, max)
            : new CategoryCoordinateCalculator_1.CategoryCoordinateCalculator(this.webAssemblyContext2D, size, 0, 0, min, max);
    }
    /**
     * @inheritDoc
     */
    getXDataRange() {
        let maxRange;
        if (this.parentSurface) {
            const visibleSeries = this.parentSurface.renderableSeries
                .asArray()
                .filter(s => s.xAxisId === this.id && s.isVisible && s.hasDataSeriesValues());
            visibleSeries.forEach(rSeries => {
                // using indices instead of xValues
                const indicesCount = rSeries.getDataSeriesValuesCount();
                const additionalValue = 1 / 2;
                const xRange = new NumberRange_1.NumberRange(0 - additionalValue, indicesCount - 1 + additionalValue);
                if (xRange) {
                    maxRange = !maxRange ? xRange : maxRange.union(xRange);
                }
            });
        }
        return maxRange;
    }
    /**
     * @inheritDoc
     */
    getLabels(majorTicks) {
        const coordCalc = this.getCurrentCoordinateCalculator();
        return majorTicks.map(tick => this.labelProvider.formatLabel(coordCalc.transformIndexToData(tick)));
    }
}
exports.CategoryAxis = CategoryAxis;
