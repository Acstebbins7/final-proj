"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxisTitleRenderer = void 0;
const Rect_1 = require("../../../Core/Rect");
const AxisAlignment_1 = require("../../../types/AxisAlignment");
const TextureManager_1 = require("../TextureManager/TextureManager");
const TextureManager_2 = require("../TextureManager/TextureManager");
const parseColor_1 = require("../../../utils/parseColor");
const WebGlPen_1 = require("../../Drawing/WebGlPen");
/** @ignore */
const PADDING = {
    // TOP: 13,
    // BOTTOM: 8,
    NO_TITLE: 0
};
/**
 * Draws an axis title using our WebGL Rendering engine
 */
class AxisTitleRenderer {
    constructor(webAssemblyContext) {
        this.viewRect = Rect_1.Rect.createZero();
        this.text = "";
        this.desiredHeightProperty = 0;
        this.desiredWidthProperty = 0;
        this.webAssemblyContext = webAssemblyContext;
        this.textureManager = new TextureManager_1.TextureManager(webAssemblyContext);
    }
    measure(textStyle, isHorizontal) {
        var _a, _b, _c, _d;
        if (isHorizontal) {
            this.desiredHeightProperty = this.text
                ? TextureManager_2.measureTextHeight(textStyle.fontSize) + ((_a = textStyle === null || textStyle === void 0 ? void 0 : textStyle.padding) === null || _a === void 0 ? void 0 : _a.bottom) + ((_b = textStyle === null || textStyle === void 0 ? void 0 : textStyle.padding) === null || _b === void 0 ? void 0 : _b.top)
                : PADDING.NO_TITLE;
        }
        else {
            this.desiredWidthProperty = this.text
                ? TextureManager_2.measureTextHeight(textStyle.fontSize) + ((_c = textStyle === null || textStyle === void 0 ? void 0 : textStyle.padding) === null || _c === void 0 ? void 0 : _c.left) + ((_d = textStyle === null || textStyle === void 0 ? void 0 : textStyle.padding) === null || _d === void 0 ? void 0 : _d.right)
                : PADDING.NO_TITLE;
        }
    }
    get desiredHeight() {
        return this.desiredHeightProperty;
    }
    set desiredHeight(value) {
        this.desiredHeightProperty = value;
    }
    get desiredWidth() {
        return this.desiredWidthProperty;
    }
    set desiredWidth(value) {
        this.desiredWidthProperty = value;
    }
    layout(rect) {
        this.viewRect = rect;
        // TODO: arrange ticks and labels
    }
    draw(renderContext, textStyle, axisAlignment, debugRendering) {
        if (!this.text)
            return;
        const nativeContext = renderContext.getNativeContext();
        const { fontStyle, fontWeight, fontSize, fontFamily, color, padding } = textStyle;
        const { bitmapTexture, textureHeight, textureWidth } = this.textureManager.createTextTexture(this.text, fontStyle, fontWeight, fontSize, fontFamily, color, 0);
        if (axisAlignment === AxisAlignment_1.EAxisAlignment.Top || axisAlignment === AxisAlignment_1.EAxisAlignment.Bottom) {
            const deltaToCenter = (this.viewRect.width - textureWidth) / 2;
            const xPositionCenter = this.viewRect.x + deltaToCenter;
            const yPosition = this.viewRect.y + (padding === null || padding === void 0 ? void 0 : padding.top);
            // (axisAlignment === EAxisAlignment.Bottom ? padding?.top : padding?.bottom);
            nativeContext.DrawTexture(bitmapTexture, xPositionCenter, yPosition, textureWidth, textureHeight);
            // for debugging width and height measure
            if (debugRendering) {
                const pen = new WebGlPen_1.WebGlPen(new this.webAssemblyContext.SCRTPen(parseColor_1.parseColorToUIntArgb("Red"), 1, true));
                renderContext.drawRect(new Rect_1.Rect(xPositionCenter, yPosition, textureWidth, textureHeight), Rect_1.Rect.create(0, 0, 999, 999), pen);
                pen.delete();
            }
            // End debug
        }
        if (axisAlignment === AxisAlignment_1.EAxisAlignment.Left) {
            nativeContext.PushMatrix();
            nativeContext.Rotate(-90);
            const deltaToCenter = (this.viewRect.height - textureWidth) / 2;
            const xPositionCenter = -(this.viewRect.y + this.viewRect.height) + deltaToCenter;
            nativeContext.Translate(xPositionCenter, this.viewRect.x + (padding === null || padding === void 0 ? void 0 : padding.left));
            nativeContext.DrawTexture(bitmapTexture, 0, 0, textureWidth, textureHeight);
            nativeContext.PopMatrix();
        }
        if (axisAlignment === AxisAlignment_1.EAxisAlignment.Right) {
            nativeContext.PushMatrix();
            nativeContext.Rotate(90);
            const deltaToCenter = (this.viewRect.height - textureWidth) / 2;
            const xPositionCenter = this.viewRect.y + deltaToCenter;
            nativeContext.Translate(xPositionCenter, -(this.viewRect.x + this.viewRect.width) + (padding === null || padding === void 0 ? void 0 : padding.right));
            nativeContext.DrawTexture(bitmapTexture, 0, 0, textureWidth, textureHeight);
            nativeContext.PopMatrix();
        }
        bitmapTexture.delete();
    }
}
exports.AxisTitleRenderer = AxisTitleRenderer;
