"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ECanvasType;
(function (ECanvasType) {
    ECanvasType[ECanvasType["canvasWebGL"] = 0] = "canvasWebGL";
    ECanvasType[ECanvasType["canvas2D"] = 1] = "canvas2D";
    ECanvasType[ECanvasType["svg"] = 2] = "svg";
})(ECanvasType || (ECanvasType = {}));
const getCanvas2dId = (divElementId) => `${divElementId}_2D`;
const getCanvasSizes = (divWidth, divHeight, maxHeight, aspectWidth = 0, aspectHeight = 0) => {
    let aspectRatio;
    if (aspectWidth && aspectHeight) {
        aspectRatio = aspectWidth / aspectHeight;
    }
    else if (divWidth && divHeight) {
        // We do not use aspect ratio if width and height is defined
        aspectRatio = undefined;
    }
    else {
        aspectRatio = 3 / 2;
    }
    const width = Math.round(divWidth || 600);
    if (aspectRatio) {
        let height = Math.round(width / aspectRatio);
        if (height > maxHeight) {
            height = maxHeight;
        }
        return { width, height, aspectRatio };
    }
    else {
        const height = Math.round(divHeight);
        return { width, height, aspectRatio };
    }
};
const getChartRootDomElement = (divElementId) => {
    const chartRoot = document.querySelector(`#${divElementId}`);
    if (!chartRoot) {
        throw new Error(`Check div element with id "${divElementId}" exists`);
    }
    if (chartRoot.nodeName.toLowerCase() !== "div") {
        throw new Error(`Element with id "${divElementId}" should be of type div`);
    }
    return chartRoot;
};
const getMaxHeight = (divElement) => {
    const styleMaxHeight = divElement.style.maxHeight;
    if (styleMaxHeight) {
        const isPx = styleMaxHeight.includes("px");
        if (isPx) {
            const maxHeight = parseInt(styleMaxHeight.replace("px", ""), 10);
            if (!isNaN(maxHeight)) {
                return maxHeight;
            }
        }
    }
    return undefined;
};
/**
 * Initialize SciChart canvases.
 * @param divElementId
 * @param aspectWidth - aspect ratio width, if set to 0 is auto-calculated
 * @param aspectHeight - aspect ratio height, if set to 0 is auto-calculated
 * @param activeCanvas - ECanvasType.canvasWebGL for sciChartSurface.createSingle, ECanvasType.canvas2D for copy canvas,
 * ECanvasType.svg for SciChartPieSurface
 */
const initCanvas = (divElementId, aspectWidth, aspectHeight, activeCanvas = ECanvasType.canvasWebGL) => {
    const chartRoot = getChartRootDomElement(divElementId);
    chartRoot.innerHTML = "";
    const { offsetWidth: divWidth, offsetHeight: divHeight } = chartRoot;
    const maxHeight = getMaxHeight(chartRoot);
    const { width, height, aspectRatio } = getCanvasSizes(divWidth, divHeight, maxHeight, aspectWidth, aspectHeight);
    let canvasWebGL;
    if (activeCanvas === ECanvasType.canvasWebGL) {
        // WebGL Canvas
        canvasWebGL = document.createElement("canvas");
        canvasWebGL.id = `${divElementId}_WebGL`;
        canvasWebGL.style.position = "absolute";
        canvasWebGL.style.display = "block";
        chartRoot.appendChild(canvasWebGL);
    }
    // 2D Canvas
    const canvas2D = document.createElement("canvas");
    canvas2D.id = getCanvas2dId(divElementId);
    canvas2D.width = width;
    canvas2D.height = height;
    canvas2D.style.position = "absolute";
    canvas2D.style.display = "block";
    if (activeCanvas !== ECanvasType.canvas2D) {
        canvas2D.style.pointerEvents = "none";
    }
    chartRoot.appendChild(canvas2D);
    canvas2D.onselectstart = () => false;
    // SVG Root Element
    const svgRootElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svgRootElement.id = `${divElementId}_SVG`;
    svgRootElement.setAttribute("width", width.toString());
    svgRootElement.setAttribute("height", height.toString());
    svgRootElement.setAttribute("role", "img");
    svgRootElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svgRootElement.style.position = "absolute";
    svgRootElement.style.display = "block";
    if (activeCanvas !== ECanvasType.svg) {
        svgRootElement.style.pointerEvents = "none";
    }
    chartRoot.appendChild(svgRootElement);
    // SVG Adorner Layer
    const svgAdornerLayer = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svgAdornerLayer.id = `${divElementId}_Adorner`;
    svgAdornerLayer.setAttribute("width", width.toString());
    svgAdornerLayer.setAttribute("height", height.toString());
    svgAdornerLayer.setAttribute("role", "img");
    svgAdornerLayer.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svgAdornerLayer.style.position = "absolute";
    svgAdornerLayer.style.display = "block";
    svgAdornerLayer.style.pointerEvents = "none";
    chartRoot.appendChild(svgAdornerLayer);
    // Root Div Element
    const divRootElement = document.createElement("div");
    divRootElement.id = `${divElementId}_div`;
    divRootElement.style.width = "100%";
    divRootElement.style.height = `${height}px`;
    divRootElement.style.position = "relative";
    divRootElement.style.pointerEvents = "none";
    divRootElement.style.textAlign = "center";
    chartRoot.appendChild(divRootElement);
    if (activeCanvas === ECanvasType.canvasWebGL) {
        canvasWebGL.addEventListener("webglcontextlost", event => {
            console.warn("WebGL context lost. Reloading the page.");
            event.preventDefault();
            location.reload();
        }, !1);
    }
    return {
        domChartRoot: chartRoot,
        domCanvasWebGL: canvasWebGL,
        domCanvas2D: canvas2D,
        domSvgContainer: svgRootElement,
        domSvgAdornerLayer: svgAdornerLayer,
        domDivContainer: divRootElement,
        aspect: aspectRatio
    };
};
var EWebGLSupport;
(function (EWebGLSupport) {
    EWebGLSupport["WebGL2"] = "WebGL 2";
    EWebGLSupport["WebGL1"] = "WebGL 1";
    EWebGLSupport["NoWebGL"] = "No WebGL support";
})(EWebGLSupport || (EWebGLSupport = {}));
const checkWebGLSupport = () => {
    const canvas = document.createElement("canvas");
    if (canvas.getContext("webgl2")) {
        return EWebGLSupport.WebGL2;
    }
    else if (canvas.getContext("webgl")) {
        return EWebGLSupport.WebGL1;
    }
    else {
        return EWebGLSupport.NoWebGL;
    }
};
const subscribeToResize = (chartRoot, aspect, sciChartSurface) => {
    // @ts-ignore
    const resizeObserver = new ResizeObserver(entries => {
        for (const entry of entries) {
            let newWidth, newHeight;
            if (entry.contentRect) {
                newWidth = entry.contentRect.width;
                newHeight = entry.contentRect.height;
            }
            else if (entry.contentBoxSize) {
                // @ts-ignore
                if (entry.contentBoxSize.inlineSize) {
                    // @ts-ignore
                    newWidth = entry.contentBoxSize.inlineSize;
                }
                else if (entry.contentBoxSize[0]) {
                    newWidth = entry.contentBoxSize[0].inlineSize;
                }
            }
            else {
                console.error("ResizeObserver is not supported");
                newWidth = 900;
            }
            // if aspect ration is defined we use is to calc height
            if (aspect) {
                newHeight = Math.round(newWidth / aspect);
            }
            else if (!newHeight) {
                // hardcoded aspect ration if newHeight is not defined
                newHeight = (newWidth * 2) / 3;
            }
            // check max-height
            const maxHeight = getMaxHeight(chartRoot);
            if (maxHeight && newHeight > maxHeight) {
                newHeight = maxHeight;
            }
            const isNotZero = newWidth !== 0 && newHeight !== 0;
            const isChanged = sciChartSurface.domCanvas2D.width !== newWidth || sciChartSurface.domCanvas2D.height !== newHeight;
            if (isNotZero && isChanged) {
                // We use setTimeout to fix "ResizeObserver loop limit exceeded" issue which occurs in Electron app
                setTimeout(() => {
                    sciChartSurface.changeViewportSize(newWidth, newHeight);
                }, 0);
            }
        }
    });
    resizeObserver.observe(chartRoot);
};
/**
 * Check DOM element with specified ID exists and unique
 * @param divElementId
 */
const checkChartDivExists = (divElementId) => {
    const numberOfElements = document.querySelectorAll(`[id=${divElementId}]`).length;
    if (numberOfElements > 1) {
        console.error(`Please provide the unique ID for each chart div element, this ID is not unique ${divElementId}`);
    }
    else if (numberOfElements === 0) {
        console.error(`Chart div element with the ID "${divElementId}" is not present in the DOM`);
    }
};
const sciChartInitCommon = {
    checkChartDivExists,
    checkWebGLSupport,
    ECanvasType,
    EWebGLSupport,
    getCanvas2dId,
    initCanvas,
    subscribeToResize
};
exports.default = sciChartInitCommon;
