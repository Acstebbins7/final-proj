"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addEventListenerToPieSegment = exports.SciChartPieSurface = exports.EPieType = exports.ESizingMode = void 0;
const app_1 = require("../../../constants/app");
const ObservableArray_1 = require("../../../Core/ObservableArray");
const Rect_1 = require("../../../Core/Rect");
const defaultThemeColors_1 = require("../../Themes/defaultThemeColors");
const SciChartJSDarkTheme_1 = require("../../Themes/SciChartJSDarkTheme");
const SciChartPieLegend_1 = require("../Legend/SciChartPieLegend");
const sciChartInitCommon_1 = require("../sciChartInitCommon");
const constants_1 = require("./constants");
const PieSegment_1 = require("./PieSegment/PieSegment");
/** @ignore */
const DEG_TO_RAD = Math.PI / 180;
/** @ignore */
const START_ANGLE = 90;
var ESizingMode;
(function (ESizingMode) {
    /**
     * The size value is specified as absolute value ( e.g. 1px, 10dp etc)
     */
    ESizingMode[ESizingMode["Absolute"] = 0] = "Absolute";
    /**
     * The size value is specified as relative value ( e.g. 10% from available size )
     */
    ESizingMode[ESizingMode["Relative"] = 1] = "Relative";
})(ESizingMode = exports.ESizingMode || (exports.ESizingMode = {}));
var EPieType;
(function (EPieType) {
    EPieType["Pie"] = "Pie";
    EPieType["Donut"] = "Donut";
})(EPieType = exports.EPieType || (exports.EPieType = {}));
/**
 * @summary The {@link SciChartPieSurface} is the root Pie and Donut Chart control in SciChart's High Performance Real-time
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Chart Library}
 * @description
 * To create a Pie chart using SciChart, declare a {@link SciChartPieSurface} using {@link SciChartPieSurface.create},
 *
 * Next, add a pie segments by adding a {@link PieSegment} to the {@link SciChartPieSurface.pieSegments} collection.
 *
 * You can create a donut chart by setting the {@link SciChartPieSurface.holeRadius} property.
 *
 * You can add and configure a legend by setting the {@link SciChartPieSurface.legend} property.
 * @remarks
 * It is possible to have more than one {@link SciChartPieSurface} on screen at the same time.
 * {@link SciChartPieSurface | SciChartPieSurfaces} scale to fit the parent DIV where they are hosted. Use CSS to position the DIV.
 */
class SciChartPieSurface {
    constructor(canvases = {}) {
        this.animate = true;
        this.pieTypeProperty = EPieType.Pie;
        this.holeRadiusProperty = 0.5;
        this.holeRadiusSizingModeProperty = ESizingMode.Relative;
        this.seriesSpacingProperty = 0;
        this.titleDivs = [];
        this.sweepAnimationDone = false;
        this.suspendUpdate = false;
        this.themeProviderProperty = new SciChartJSDarkTheme_1.SciChartJSDarkTheme();
        this.previousThemeProviderProperty = new SciChartJSDarkTheme_1.SciChartJSDarkTheme();
        this.domChartRoot = canvases.domChartRoot;
        this.domCanvas2D = canvases.domCanvas2D;
        this.domSvgContainer = canvases.domSvgContainer;
        this.domDivContainer = canvases.domDivContainer;
        this.viewRect = new Rect_1.Rect(0, 0, this.domCanvas2D.width, this.domCanvas2D.height);
        this.drawChart = this.drawChart.bind(this);
        this.delete = this.delete.bind(this);
        this.invalidateElement = this.invalidateElement.bind(this);
        this.detachPieSegment = this.detachPieSegment.bind(this);
        this.attachPieSegment = this.attachPieSegment.bind(this);
        this.pieSegments = new ObservableArray_1.ObservableArray();
        this.pieSegments.collectionChanged.subscribe(args => {
            var _a, _b;
            (_a = args.getOldItems()) === null || _a === void 0 ? void 0 : _a.forEach(this.detachPieSegment);
            (_b = args.getNewItems()) === null || _b === void 0 ? void 0 : _b.forEach(this.attachPieSegment);
        });
        this.applySciChartBackground(defaultThemeColors_1.defaultThemeColors.sciChartBackground);
        this.legend = new SciChartPieLegend_1.SciChartPieLegend();
        this.legend.setRootDiv(this.domDivContainer);
        this.legend.setPieSegmentArray(this.pieSegments.asArray());
        this.legend.setInvalidateParentSurface(this.invalidateElement);
        this.legend.setParentSurface(this);
    }
    /**
     * Creates a {@link SciChartPieSurface} and {@link TSciChart | WebAssembly Context} to occupy the div by element ID in your DOM.
     * @remarks This method is async and must be awaited
     * @param divElementId The Div Element ID where the {@link SciChartPieSurface} will reside
     * @param width Optional - the width of the {@link SciChartPieSurface} in pixels. By default SciChart will scale to fit the parent Div
     * @param height Optional - the height of the {@link SciChartPieSurface} in pixels. By default SciChart will scale to fit the parent Div
     */
    static create(divElementId, width = 0, height = 0) {
        const canvases = sciChartInitCommon_1.default.initCanvas(divElementId, width, height, sciChartInitCommon_1.default.ECanvasType.svg);
        return new Promise(resolve => {
            const scps = new SciChartPieSurface(canvases);
            sciChartInitCommon_1.default.subscribeToResize(canvases.domChartRoot, canvases.aspect, scps);
            // setTimeout is used to make function async like createSciChartSurface, to have a consistent API
            setTimeout(() => resolve(scps), 0);
        });
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        this.previousThemeProviderProperty = this.themeProviderProperty;
        this.themeProviderProperty = themeProvider;
        this.applySciChartBackground(themeProvider.sciChartBackground);
        this.invalidateElement();
    }
    /**
     * Used internally - gets the previous {@link IThemeProvider}
     */
    get themeProvider() {
        return this.themeProviderProperty;
    }
    /**
     * Used internally - gets the previous {@link IThemeProvider}
     */
    get previousThemeProvider() {
        return this.previousThemeProviderProperty;
    }
    /**
     * Call invalidateElement() to trigger a redraw of the {@link SciChartPieSurface}. SciChart's rendering
     * engine will schedule a redraw a the next time the renderer is free.
     */
    invalidateElement() {
        if (this.isValidToDraw()) {
            this.update();
        }
    }
    /**
     * Called internally - Updates and draws the Pie Chart
     */
    update() {
        if (!this.suspendUpdate) {
            this.draw();
            this.legend.setSeriesViewRect(this.viewRect);
            this.legend.update();
        }
    }
    /**
     * @inheritDoc
     */
    delete() {
        if (this.svg) {
            this.domSvgContainer.removeChild(this.svg);
            this.svg = undefined;
        }
        this.titleDivs.forEach(divEl => {
            this.domDivContainer.removeChild(divEl);
        });
        this.titleDivs = [];
    }
    /**
     * @inheritDoc
     */
    changeViewportSize(width, height) {
        this.viewRect = new Rect_1.Rect(0, 0, width, height);
        this.changeDomViewportSize(width, height);
        this.invalidateElement();
    }
    // GETTERS AND SETTERS FOR PROPERTIES
    /**
     * Gets or sets the type of the pie chart. See {@link EPieType} for a list of values
     * @remarks See also {@link holeRadius} which is required for Donut charts and {@link holeRadiusSizingMode}
     * which defines whether the Donut hole is relative or absolute.
     */
    get pieType() {
        return this.pieTypeProperty;
    }
    /**
     * Gets or sets the type of the pie chart. See {@link EPieType} for a list of values
     * @remarks See also {@link holeRadius} which is required for Donut charts and {@link holeRadiusSizingMode}
     * which defines whether the Donut hole is relative or absolute.
     */
    set pieType(value) {
        this.pieTypeProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.PIE_TYPE);
    }
    /**
     * Gets or sets the hole radius, which allows you to create Donut charts instead of Pie.
     * @remarks See also {@link EPieType} which is required to change from Pie to Donut and {@link holeRadiusSizingMode}
     * which defines whether the Donut hole is relative or absolute.
     */
    get holeRadius() {
        return this.holeRadiusProperty;
    }
    /**
     * Gets or sets the hole radius, which allows you to create Donut charts instead of Pie.
     * @remarks See also {@link EPieType} which is required to change from Pie to Donut and {@link holeRadiusSizingMode}
     * which defines whether the Donut hole is relative or absolute.
     */
    set holeRadius(holeRadius) {
        this.holeRadiusProperty = holeRadius;
        this.notifyPropertyChanged(constants_1.PROPERTY.HOLE_RADIUS);
    }
    /**
     * Gets or sets the hole radius size mode for Donut charts. See {@link ESizingMode} for a list of values
     * @remarks See also {@link EPieType} which is required to change from Pie to Donut, and {@link holeRadius}
     * which sets the size of a Donut Chart hole
     */
    get holeRadiusSizingMode() {
        return this.holeRadiusSizingModeProperty;
    }
    /**
     * Gets or sets the hole radius size mode for Donut charts. See {@link ESizingMode} for a list of values
     * @remarks See also {@link EPieType} which is required to change from Pie to Donut, and {@link holeRadius}
     * which sets the size of a Donut Chart hole
     */
    set holeRadiusSizingMode(holeRadiusSizingMode) {
        this.holeRadiusSizingModeProperty = holeRadiusSizingMode;
        this.notifyPropertyChanged(constants_1.PROPERTY.HOLE_RADIUS_SIZING_MODE);
    }
    get seriesSpacing() {
        return this.seriesSpacingProperty;
    }
    set seriesSpacing(value) {
        this.seriesSpacingProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.SERIES_SPACING);
    }
    /**
     * Changes the size of the DOM element where the {@link SciChartSurfaceBase} resides.
     * @param width
     * @param height
     */
    changeDomViewportSize(width, height) {
        if (this.domChartRoot) {
            this.domChartRoot.style.height = `${height}px`;
        }
        if (this.domCanvas2D) {
            this.domCanvas2D.width = width;
            this.domCanvas2D.height = height;
        }
        if (this.domSvgContainer) {
            this.domSvgContainer.setAttribute("width", width.toString());
            this.domSvgContainer.setAttribute("height", height.toString());
        }
        if (this.domDivContainer) {
            this.domDivContainer.style.height = `${height}px`;
        }
    }
    // PRIVATE
    notifyPropertyChanged(propertyName) {
        this.invalidateElement();
    }
    isValidToDraw() {
        // TODO
        return true;
    }
    detachPieSegment(pieSegment) {
        pieSegment.onDetach();
        this.invalidateElement();
    }
    attachPieSegment(pieSegment) {
        pieSegment.onAttach(this);
        this.invalidateElement();
    }
    draw() {
        if (this.sweepAnimationDone) {
            this.delete();
            this.drawChart();
        }
        else {
            const frames = 30;
            this.suspendUpdate = true;
            const setSuspendUpdateFalse = () => (this.suspendUpdate = false);
            const setSweepAnimationDone = () => (this.sweepAnimationDone = true);
            const callInvalidateElement = this.invalidateElement;
            const callDrawChart = this.drawChart;
            const callDelete = this.delete;
            (function myLoop(k) {
                setTimeout(() => {
                    const animationProgress = k / frames;
                    callDelete();
                    callDrawChart(animationProgress);
                    if (k === frames) {
                        setSuspendUpdateFalse();
                        setSweepAnimationDone();
                        callInvalidateElement();
                    }
                    if (++k <= frames)
                        myLoop(k);
                }, 20);
            })(1);
        }
        // ADD EVENT LISTENERS
        if (!app_1.IS_TEST_ENV) {
            this.pieSegments.asArray().forEach(ps => {
                const el = document.getElementById(ps.id);
                exports.addEventListenerToPieSegment(ps, el, this.animate);
            });
        }
        this.drawSegmentTitles();
    }
    /**
     * @description Draws pie chart itself
     * @param animationProgress - Current progress from 0 to 1, is being used for sweep animation on start.
     */
    drawChart(animationProgress = 1) {
        const strokeWidth = 2;
        const strokeColor = this.themeProviderProperty.sciChartBackground;
        const segments = this.pieSegments.asArray();
        const totalValue = this.pieSegmentsTotalValue();
        const outerRadius = (Math.min(this.viewRect.width, this.viewRect.height) * 0.8) / 2;
        let innerRadius = 0;
        if (this.pieType === EPieType.Donut) {
            innerRadius =
                this.holeRadiusSizingMode === ESizingMode.Absolute ? this.holeRadius : outerRadius * this.holeRadius;
        }
        const xCoord = this.viewRect.width / 2;
        const yCoord = this.viewRect.height / 2;
        // CREATING SVG STRING
        let gradientsBlock = `<defs>`;
        let pathsBlock = "";
        let currentValue = 0;
        segments.forEach(el => {
            const newValue = el.value * animationProgress;
            const hasGradient = !!el.colorLinearGradient;
            const gradientId = `grad${el.id}`;
            if (hasGradient) {
                const x1 = el.colorLinearGradient.startPoint.x * 100;
                const y1 = el.colorLinearGradient.startPoint.y * 100;
                const x2 = el.colorLinearGradient.endPoint.x * 100;
                const y2 = el.colorLinearGradient.endPoint.y * 100;
                let gradientBlock = `<linearGradient id="${gradientId}" x1="${x1}%" y1="${y1}%" x2="${x2}%" y2="${y2}%">`;
                el.colorLinearGradient.gradientStops.forEach(gStop => {
                    const offset = gStop.offset * 100;
                    gradientBlock += `<stop offset="${offset}%" style="stop-color:${gStop.color};stop-opacity:1" />`;
                });
                gradientBlock += `</linearGradient>`;
                gradientsBlock += gradientBlock;
            }
            const angleFrom = (360 * currentValue) / totalValue - START_ANGLE;
            const angleTo = (360 * (currentValue + newValue)) / totalValue - START_ANGLE;
            const dAttribute = this.pieType === EPieType.Donut
                ? getDonutSectorPath(xCoord, yCoord, outerRadius, innerRadius, angleFrom, angleTo, el.delta)
                : getSectorPath(xCoord, yCoord, outerRadius, angleFrom, angleTo, el.delta);
            const pathBlock = hasGradient
                ? `<g fill="url(#${gradientId})"><path id="${el.id}" stroke="${strokeColor}" stroke-width="${strokeWidth}" d="${dAttribute}" /></g>`
                : `<path id="${el.id}" stroke="${strokeColor}" stroke-width="${strokeWidth}" d="${dAttribute}" fill="${el.color}" />`;
            pathsBlock += pathBlock;
            currentValue += newValue;
        });
        gradientsBlock += `</defs>`;
        const svgString = `<svg width="${this.viewRect.width}" height="${this.viewRect.height}">${gradientsBlock}${pathsBlock}</svg>`;
        // CREATING AND ATTACHING SVG TO DOM
        const svgNode = document.createRange().createContextualFragment(svgString);
        this.domSvgContainer.appendChild(svgNode);
        this.svg = this.domSvgContainer.lastChild;
    }
    drawSegmentTitles() {
        const totalValue = this.pieSegmentsTotalValue();
        let currentValue = 0;
        const xCoord = this.viewRect.width / 2;
        const yCoord = this.viewRect.height / 2;
        const outerRadius = (Math.min(this.viewRect.width, this.viewRect.height) * 0.8) / 2;
        let innerRadius = 0;
        if (this.pieType === EPieType.Donut) {
            innerRadius =
                this.holeRadiusSizingMode === ESizingMode.Absolute ? this.holeRadius : outerRadius * this.holeRadius;
        }
        this.pieSegments.asArray().forEach((el, index) => {
            const div = document.createElement("div");
            div.style.position = "absolute";
            div.style.pointerEvents = "none";
            div.style.padding = "5px";
            div.style.borderRadius = "3px";
            div.style.color = "#1e323d";
            div.style.fontWeight = "bold";
            div.style.display = "block";
            div.style.fontFamily = "Arial";
            div.innerHTML = `<div>${el.getPercentage(totalValue)}</div>`;
            this.domDivContainer.appendChild(div);
            const divWidth = div.offsetWidth;
            const divHeight = div.offsetHeight;
            const angleFrom = (360 * currentValue) / totalValue - START_ANGLE;
            const angleTo = (360 * (currentValue + el.value)) / totalValue - START_ANGLE;
            const position = calcTitlePosition(xCoord, yCoord, outerRadius, innerRadius, angleFrom, angleTo, el.delta, divWidth, divHeight);
            div.style.left = `${position.left}px`;
            div.style.top = `${position.top}px`;
            this.titleDivs.push(div);
            currentValue += el.value;
        });
    }
    pieSegmentsTotalValue() {
        return this.pieSegments.asArray().reduce((prev, cur) => prev + cur.value, 0);
    }
    applySciChartBackground(htmlColor) {
        this.domCanvas2D.style.backgroundColor = htmlColor;
    }
}
exports.SciChartPieSurface = SciChartPieSurface;
/**
 * @ignore
 * @description Create sector path string
 * @param x - circle x coordinate
 * @param y - circle y coordinate
 * @param outerRadius - circle radius
 * @param a1 - angleFrom in degrees
 * @param a2 - angleTo in degrees
 * @param delta - sector shift, is used for selected sectors
 */
const getSectorPath = (x, y, outerRadius, a1, a2, delta) => {
    const bigArc = Math.abs(a2 - a1) > 180 ? 1 : 0;
    const deltaAngle = (a1 + a2) / 2;
    const deltaX = Math.cos(DEG_TO_RAD * deltaAngle) * delta;
    const deltaY = Math.sin(DEG_TO_RAD * deltaAngle) * delta;
    const cx1 = Math.cos(DEG_TO_RAD * a2) * outerRadius + x + deltaX;
    const cy1 = Math.sin(DEG_TO_RAD * a2) * outerRadius + y + deltaY;
    const cx2 = Math.cos(DEG_TO_RAD * a1) * outerRadius + x + deltaX;
    const cy2 = Math.sin(DEG_TO_RAD * a1) * outerRadius + y + deltaY;
    return `M${x + deltaX} ${y + deltaY} ${cx1} ${cy1} A${outerRadius} ${outerRadius} 0 ${bigArc} 0 ${cx2} ${cy2}Z`;
};
/**
 * @ignore
 * @description Create donut sector path string
 * @param x - circle x coordinate
 * @param y - circle y coordinate
 * @param outerR - circle outer radius
 * @param innerR - circle inner radius
 * @param a1 - angleFrom in degrees
 * @param a2 - angleTo in degrees
 * @param delta - sector shift, is used for selected sectors
 */
const getDonutSectorPath = (x, y, outerR, innerR, a1, a2, delta) => {
    const bigArc = Math.abs(a2 - a1) > 180 ? 1 : 0;
    const deltaAngle = (a1 + a2) / 2;
    const deltaX = Math.cos(DEG_TO_RAD * deltaAngle) * delta;
    const deltaY = Math.sin(DEG_TO_RAD * deltaAngle) * delta;
    const outerX1 = Math.cos(DEG_TO_RAD * a2) * outerR + x + deltaX;
    const outerY1 = Math.sin(DEG_TO_RAD * a2) * outerR + y + deltaY;
    const outerX2 = Math.cos(DEG_TO_RAD * a1) * outerR + x + deltaX;
    const outerY2 = Math.sin(DEG_TO_RAD * a1) * outerR + y + deltaY;
    const innerX1 = Math.cos(DEG_TO_RAD * a2) * innerR + x + deltaX;
    const innerY1 = Math.sin(DEG_TO_RAD * a2) * innerR + y + deltaY;
    const innerX2 = Math.cos(DEG_TO_RAD * a1) * innerR + x + deltaX;
    const innerY2 = Math.sin(DEG_TO_RAD * a1) * innerR + y + deltaY;
    return `M${outerX1} ${outerY1} A${outerR} ${outerR} 0 ${bigArc} 0 ${outerX2} ${outerY2} L${innerX2} ${innerY2} A${innerR} ${innerR} 0 ${bigArc} 1 ${innerX1} ${innerY1}Z`;
};
/** @ignore */
const calcTitlePosition = (x, y, outerRadius, innerRadius, a1, a2, delta, divWidth, divHeight) => {
    const centerRadius = innerRadius < outerRadius / 2
        ? (outerRadius * 2) / 3 + innerRadius / 6 + delta
        : (outerRadius + innerRadius) / 2 + delta;
    const centerAngle = (a1 + a2) / 2;
    const left = x + Math.cos(DEG_TO_RAD * centerAngle) * centerRadius - divWidth / 2;
    const top = y + Math.sin(DEG_TO_RAD * centerAngle) * centerRadius - divHeight / 2;
    return { left, top };
};
/** @ignore */
let isListenerBlocked = false;
/** @ignore */
exports.addEventListenerToPieSegment = (ps, el, animate) => {
    if (el) {
        el.addEventListener("click", e => {
            if (!animate) {
                ps.isSelected = !ps.isSelected;
                return;
            }
            // ANIMATE
            if (!isListenerBlocked) {
                const ROUNDS = 10;
                const directionDown = ps.isSelected;
                const start = directionDown ? PieSegment_1.PieSegment.DEFAULT_DELTA : 0;
                const d = directionDown ? -PieSegment_1.PieSegment.DEFAULT_DELTA / ROUNDS : PieSegment_1.PieSegment.DEFAULT_DELTA / ROUNDS;
                isListenerBlocked = true;
                (function myLoop(k) {
                    setTimeout(() => {
                        ps.delta = start + d * k;
                        if (k === ROUNDS) {
                            isListenerBlocked = false;
                        }
                        if (++k <= ROUNDS)
                            myLoop(k);
                    }, 20);
                })(1);
            }
        });
    }
};
