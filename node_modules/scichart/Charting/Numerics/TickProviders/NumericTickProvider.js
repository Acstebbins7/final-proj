"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumericTickProvider = void 0;
const Guard_1 = require("../../../Core/Guard");
const NumberRange_1 = require("../../../Core/NumberRange");
const isRealNumber_1 = require("../../../utils/isRealNumber");
const TickProvider_1 = require("./TickProvider");
/**
 * @summary The NumericTickProvider is a {@link TickProvider} implementation for Numeric 2D or 3D Axis.
 * @description TickProviders are responsible for calculating the interval between major and minor gridlines, ticks and labels.
 *
 *  * The method {@link getMajorTicks} returns an array of major ticks (data-values values where SciChart will place labels and major gridlines.
 *  * The method {@link getMinorTicks} returns an array of minor ticks (data-values values where SciChart will place minor gridlines.
 *  * The method {@link isParamsValid} performs some sanity checks.
 *  * The method {@link calculateTicks} performs the actual calculation
 *
 * Override these methods to create custom implementations of Tick intervals in SciChart
 * @remarks
 * See also {@link TickProvider} for the base implementation.
 */
class NumericTickProvider extends TickProvider_1.TickProvider {
    /**
     * Creates an instance of a NumericTickProvider
     * @param webAssemblyContext The {@link TSciChart | SciChart 2D WebAssembly Context} or {@link TSciChart | SciChart 3D WebAssembly Context}
     * containing native methods and access to our WebGL2 WebAssembly Rendering Engine
     */
    constructor(webAssemblyContext) {
        super();
        this.minDeltaValue = 1e-13;
        this.webAssemblyContext = webAssemblyContext;
    }
    /**
     * @inheritDoc
     */
    getMinorTicks(minorDelta, majorDelta, visibleRange) {
        const deltaRange = new NumberRange_1.NumberRange(minorDelta, majorDelta);
        const tickRange = visibleRange;
        if (!this.isParamsValid(tickRange, deltaRange)) {
            return [];
        }
        return this.calculateTicks(tickRange, deltaRange.min, deltaRange.max);
    }
    /**
     * @inheritDoc
     */
    getMajorTicks(minorDelta, majorDelta, visibleRange) {
        const deltaRange = new NumberRange_1.NumberRange(minorDelta, majorDelta);
        const tickRange = visibleRange;
        if (!this.isParamsValid(tickRange, deltaRange)) {
            return [];
        }
        return this.calculateTicks(tickRange, deltaRange.max, deltaRange.max);
    }
    /**
     * @summary Performs sanity checks to see if parameters are valid.
     * @description If this method returns false, then we should not process or compute major/minor gridlines, but instead should
     * return empty array ```[]``` in {@link getMajorTicks} / {@link getMinorTicks}
     * @param visibleRange The current {@link AxisCore.visibleRange} which is the minimum / maximum range visible on the Axis.
     * @param deltaRange The current {@link AxisCore.minorDelta} and {@link AxisCore.majorDelta} which is the difference between minor
     * and major gridlines requested by the {@link AxisCore | Axis}
     */
    isParamsValid(visibleRange, deltaRange) {
        Guard_1.Guard.notNull(visibleRange, "visibleRange");
        Guard_1.Guard.notNull(deltaRange, "deltaRange");
        return (isRealNumber_1.isRealNumber(visibleRange.min) &&
            isRealNumber_1.isRealNumber(visibleRange.max) &&
            isRealNumber_1.isRealNumber(deltaRange.min) &&
            isRealNumber_1.isRealNumber(deltaRange.max));
    }
    /**
     * @summary Performs the Numeric tick calculation
     * @param visibleRange The current {@link AxisCore.visibleRange} which is the minimum / maximum range visible on the Axis.
     * @param delta The delta we are calculating for (could be major or minor delta)
     * @param majorDelta The current {@link AxisCore.majorDelta} which is the difference between major
     * gridlines requested by the {@link AxisCore | Axis}
     */
    calculateTicks(visibleRange, delta, majorDelta) {
        const results = [];
        const min = visibleRange.min;
        const max = visibleRange.max;
        let current = min;
        const calcMajorTicks = delta === majorDelta;
        const numberUtil = this.webAssemblyContext.NumberUtil;
        if (!numberUtil.IsDivisibleBy(current, delta)) {
            current = numberUtil.RoundUp(current, delta);
        }
        const start = current;
        let tickCount = 0;
        while (current <= max) {
            // TRUE if major ticks are calculated && Current is divisible by MajorDelta
            // or if minor ticks are calculated && Current is NOT divisible by MajorDelta
            if (!(numberUtil.IsDivisibleBy(current, majorDelta) !== calcMajorTicks)) {
                results.push(current);
            }
            current = start + ++tickCount * delta;
        }
        return results;
    }
}
exports.NumericTickProvider = NumericTickProvider;
