"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testLayoutManager = exports.LayoutManager = void 0;
const Rect_1 = require("../../Core/Rect");
const AxisAlignment_1 = require("../../types/AxisAlignment");
const ChartLayoutState_1 = require("./ChartLayoutState");
const LayoutStrategyAxes_1 = require("./LayoutStrategyAxes");
const MIN_SERIES_AREA_SIZE = 10;
/**
 * @ignore
 */
class LayoutManager {
    constructor(sciChartSurface) {
        this.chartLayoutState = new ChartLayoutState_1.ChartLayoutState();
        this.axesGroupedByLayoutStrategy = new LayoutStrategyAxes_1.LayoutStrategyAxes();
        this.sciChartSurface = sciChartSurface;
    }
    layoutChart(viewportSize) {
        this.groupAxesByLayoutStrategy();
        // Padding are hardcoded for now
        const paddingRight = 0;
        const paddingLeft = 0;
        const paddingTop = 0;
        const paddingBottom = 0;
        const availableWidth = viewportSize.width - paddingLeft - paddingRight;
        const availableHeight = viewportSize.height - paddingTop - paddingBottom;
        try {
            // measure outer axes areas
            this.measureTopOuterAxes();
            this.measureBottomOuterAxes();
            this.measureLeftOuterAxes();
            this.measureRightOuterAxes();
            const remainingWidth = availableWidth - this.chartLayoutState.leftOuterAreaSize - this.chartLayoutState.rightOuterAreaSize;
            const remainingHeight = availableHeight - this.chartLayoutState.topOuterAreaSize - this.chartLayoutState.bottomOuterAreaSize;
            const leftStart = paddingLeft;
            const leftEnd = leftStart + this.chartLayoutState.leftOuterAreaSize;
            const rightStart = leftEnd + (remainingWidth < MIN_SERIES_AREA_SIZE ? MIN_SERIES_AREA_SIZE : remainingWidth);
            const rightEnd = rightStart + this.chartLayoutState.rightOuterAreaSize;
            const topStart = paddingTop;
            const topEnd = topStart + this.chartLayoutState.topOuterAreaSize;
            const bottomStart = topEnd + (remainingHeight < MIN_SERIES_AREA_SIZE ? MIN_SERIES_AREA_SIZE : remainingHeight);
            const bottomEnd = bottomStart + this.chartLayoutState.bottomOuterAreaSize;
            // layout center parts
            this.layoutChartCenter(leftEnd, topEnd, rightStart, bottomStart);
            // layout outer axes
            this.layoutLeftOuterAxes(leftStart, topEnd, leftEnd - this.sciChartSurface.leftViewportBorder, bottomStart);
            this.layoutRightOuterAxes(rightStart + this.sciChartSurface.rightViewportBorder, topEnd, rightEnd, bottomStart);
            this.layoutTopOuterAxes(leftEnd, topStart, rightStart, topEnd - this.sciChartSurface.topViewportBorder);
            this.layoutBottomOuterAxes(leftEnd, bottomStart + this.sciChartSurface.bottomViewportBorder, rightStart, bottomEnd);
            return this.sciChartSurface.seriesViewRect;
        }
        finally {
            this.chartLayoutState.clear();
        }
        return undefined;
    }
    measureLeftOuterAxes() {
        var _a, _b;
        let requiredSize = (_b = (_a = this.sciChartSurface.padding) === null || _a === void 0 ? void 0 : _a.left) !== null && _b !== void 0 ? _b : 0;
        requiredSize += this.sciChartSurface.leftViewportBorder + this.sciChartSurface.leftCanvasBorder;
        this.axesGroupedByLayoutStrategy.leftOuterAxes.forEach(axis => {
            axis.measure();
            updateOuterAxesLayoutState(axis);
            requiredSize += getVerticalAxisRequiredSize(axis.axisLayoutState);
            updateTopAndBottomChartLayoutState(this.chartLayoutState, axis.axisLayoutState.additionalTopSize, axis.axisLayoutState.additionalBottomSize);
        });
        this.chartLayoutState.leftOuterAreaSize = Math.max(this.chartLayoutState.leftOuterAreaSize, requiredSize);
    }
    measureRightOuterAxes() {
        var _a, _b;
        let requiredSize = (_b = (_a = this.sciChartSurface.padding) === null || _a === void 0 ? void 0 : _a.right) !== null && _b !== void 0 ? _b : 0;
        requiredSize += this.sciChartSurface.rightViewportBorder + this.sciChartSurface.rightCanvasBorder;
        this.axesGroupedByLayoutStrategy.rightOuterAxes.forEach(axis => {
            axis.measure();
            updateOuterAxesLayoutState(axis);
            requiredSize += getVerticalAxisRequiredSize(axis.axisLayoutState);
            updateTopAndBottomChartLayoutState(this.chartLayoutState, axis.axisLayoutState.additionalTopSize, axis.axisLayoutState.additionalBottomSize);
        });
        this.chartLayoutState.rightOuterAreaSize = Math.max(this.chartLayoutState.rightOuterAreaSize, requiredSize);
    }
    groupAxesByLayoutStrategy() {
        this.axesGroupedByLayoutStrategy.clear();
        const groupAxes = (axes) => {
            axes.forEach(axis => {
                const axisAlignment = axis.axisAlignment;
                switch (axisAlignment) {
                    case AxisAlignment_1.EAxisAlignment.Top:
                        this.axesGroupedByLayoutStrategy.topOuterAxes.push(axis);
                        break;
                    case AxisAlignment_1.EAxisAlignment.Bottom:
                        this.axesGroupedByLayoutStrategy.bottomOuterAxes.push(axis);
                        break;
                    case AxisAlignment_1.EAxisAlignment.Left:
                        this.axesGroupedByLayoutStrategy.leftOuterAxes.push(axis);
                        break;
                    case AxisAlignment_1.EAxisAlignment.Right:
                        this.axesGroupedByLayoutStrategy.rightOuterAxes.push(axis);
                        break;
                }
            });
        };
        groupAxes(this.sciChartSurface.xAxes.asArray());
        groupAxes(this.sciChartSurface.yAxes.asArray());
    }
    measureTopOuterAxes() {
        var _a, _b;
        let requiredSize = (_b = (_a = this.sciChartSurface.padding) === null || _a === void 0 ? void 0 : _a.top) !== null && _b !== void 0 ? _b : 0;
        requiredSize += this.sciChartSurface.topViewportBorder + this.sciChartSurface.topCanvasBorder;
        this.axesGroupedByLayoutStrategy.topOuterAxes.forEach(axis => {
            axis.measure();
            updateOuterAxesLayoutState(axis);
            requiredSize += getHorizontalAxisRequiredSize(axis.axisLayoutState);
            updateLeftAndRightChartLayoutState(this.chartLayoutState, axis.axisLayoutState.additionalLeftSize, axis.axisLayoutState.additionalRightSize);
        });
        this.chartLayoutState.topOuterAreaSize = Math.max(this.chartLayoutState.topOuterAreaSize, requiredSize);
    }
    measureBottomOuterAxes() {
        var _a, _b;
        let requiredSize = (_b = (_a = this.sciChartSurface.padding) === null || _a === void 0 ? void 0 : _a.bottom) !== null && _b !== void 0 ? _b : 0;
        requiredSize += this.sciChartSurface.bottomViewportBorder + this.sciChartSurface.bottomCanvasBorder;
        this.axesGroupedByLayoutStrategy.bottomOuterAxes.forEach(axis => {
            axis.measure();
            updateOuterAxesLayoutState(axis);
            requiredSize += getHorizontalAxisRequiredSize(axis.axisLayoutState);
            updateLeftAndRightChartLayoutState(this.chartLayoutState, axis.axisLayoutState.additionalLeftSize, axis.axisLayoutState.additionalRightSize);
        });
        this.chartLayoutState.bottomOuterAreaSize = Math.max(this.chartLayoutState.bottomOuterAreaSize, requiredSize);
    }
    layoutChartCenter(left, top, right, bottom) {
        this.setSeriesViewRect(left, top, right, bottom);
        this.sciChartSurface.annotationUnderlaySurfaceViewRect = Rect_1.Rect.createWithCoords(left, top, right, bottom);
        this.sciChartSurface.annotationOverlaySurfaceViewRect = Rect_1.Rect.createWithCoords(left, top, right, bottom);
        this.sciChartSurface.chartModifierSurfaceViewRect = Rect_1.Rect.createWithCoords(left, top, right, bottom);
    }
    layoutLeftOuterAxes(left, top, right, bottom) {
        layoutAxesFromRightToLeft(right, top, bottom, this.axesGroupedByLayoutStrategy.leftOuterAxes);
    }
    layoutRightOuterAxes(left, top, right, bottom) {
        layoutAxesFromLeftToRight(left, top, bottom, this.axesGroupedByLayoutStrategy.rightOuterAxes);
    }
    layoutTopOuterAxes(left, top, right, bottom) {
        layoutAxesFromBottomToTop(left, bottom, right, this.axesGroupedByLayoutStrategy.topOuterAxes);
    }
    layoutBottomOuterAxes(left, top, right, bottom) {
        layoutAxesFromTopToBottom(left, top, right, this.axesGroupedByLayoutStrategy.bottomOuterAxes);
    }
    setSeriesViewRect(left, top, right, bottom) {
        const { seriesViewRect } = this.sciChartSurface;
        const newRect = Rect_1.Rect.createWithCoords(left, top, right, bottom);
        if (!seriesViewRect || !Rect_1.Rect.isEqual(seriesViewRect, newRect)) {
            this.sciChartSurface.setSeriesViewRect(newRect);
        }
    }
}
exports.LayoutManager = LayoutManager;
function updateLeftAndRightChartLayoutState(chartLayoutState, additionalLeftSize, additionalRightSize) {
    chartLayoutState.leftOuterAreaSize = Math.max(chartLayoutState.leftOuterAreaSize, additionalLeftSize);
    chartLayoutState.rightOuterAreaSize = Math.max(chartLayoutState.rightOuterAreaSize, additionalRightSize);
}
function updateTopAndBottomChartLayoutState(chartLayoutState, additionalTopSize, additionalBottomSize) {
    chartLayoutState.topOuterAreaSize = Math.max(chartLayoutState.topOuterAreaSize, additionalTopSize);
    chartLayoutState.bottomOuterAreaSize = Math.max(chartLayoutState.bottomOuterAreaSize, additionalBottomSize);
}
function updateOuterAxesLayoutState(axis) {
    const { axisRenderer, axisTitleRenderer, axisLayoutState, isHorizontalAxis, axisBorder } = axis;
    axisLayoutState.clear();
    axisLayoutState.axisSize = isHorizontalAxis
        ? axisRenderer.desiredHeight + axisTitleRenderer.desiredHeight
        : axisRenderer.desiredWidth + axisTitleRenderer.desiredWidth;
    axisLayoutState.additionalBottomSize = axisBorder.borderBottom;
    axisLayoutState.additionalTopSize = axisBorder.borderTop;
    axisLayoutState.additionalRightSize = axisBorder.borderRight;
    axisLayoutState.additionalLeftSize = axisBorder.borderLeft;
}
function getHorizontalAxisRequiredSize(axisLayoutState) {
    return axisLayoutState.axisSize + axisLayoutState.additionalTopSize + axisLayoutState.additionalBottomSize;
}
function getVerticalAxisRequiredSize(axisLayoutState) {
    return axisLayoutState.axisSize + axisLayoutState.additionalLeftSize + axisLayoutState.additionalRightSize;
}
function layoutAxesFromRightToLeft(right, top, bottom, axes) {
    let rightOffset = right;
    axes.forEach(axis => {
        const { axisLayoutState: { axisSize, additionalLeftSize, additionalRightSize } } = axis;
        const leftOffset = rightOffset - axisSize - additionalLeftSize - additionalRightSize;
        axis.viewRect = Rect_1.Rect.createWithCoords(leftOffset + additionalLeftSize, top, rightOffset - additionalRightSize, bottom);
        rightOffset = leftOffset;
        layoutAxisParts(axis, layoutAxisPartsLeftStrategy);
    });
}
function layoutAxesFromLeftToRight(left, top, bottom, axes) {
    let leftOffset = left;
    axes.forEach(axis => {
        const { axisLayoutState: { axisSize, additionalLeftSize, additionalRightSize } } = axis;
        const rightOffset = leftOffset + axisSize + additionalLeftSize + additionalRightSize;
        axis.viewRect = Rect_1.Rect.createWithCoords(leftOffset + additionalLeftSize, top, rightOffset - additionalRightSize, bottom);
        leftOffset = rightOffset;
        layoutAxisParts(axis, layoutAxisPartsRightStrategy);
    });
}
function layoutAxesFromBottomToTop(left, bottom, right, axes) {
    let bottomOffset = bottom;
    axes.forEach(axis => {
        const { axisLayoutState: { axisSize, additionalTopSize, additionalBottomSize } } = axis;
        const topOffset = bottomOffset - axisSize - additionalBottomSize - additionalTopSize;
        axis.viewRect = Rect_1.Rect.createWithCoords(left, topOffset + additionalTopSize, right, bottomOffset - additionalBottomSize);
        bottomOffset = topOffset;
        layoutAxisParts(axis, layoutAxisPartsTopStrategy);
    });
}
function layoutAxesFromTopToBottom(left, top, right, axes) {
    let topOffset = top;
    axes.forEach(axis => {
        const { axisLayoutState: { axisSize, additionalTopSize, additionalBottomSize } } = axis;
        const bottomOffset = topOffset + axisSize + additionalBottomSize + additionalTopSize;
        axis.viewRect = Rect_1.Rect.createWithCoords(left, topOffset + additionalTopSize, right, bottomOffset - additionalBottomSize);
        topOffset = bottomOffset;
        layoutAxisParts(axis, layoutAxisPartsBottomStrategy);
    });
}
function layoutAxisParts(axis, layoutFunc) {
    const { isHorizontalAxis, viewRect, axisRenderer, axisTitleRenderer, axisBorder } = axis;
    const axisRendererWidth = isHorizontalAxis ? viewRect.width : axisRenderer.desiredWidth;
    const axisRendererHeight = isHorizontalAxis ? axisRenderer.desiredHeight : viewRect.height;
    const axisTitleRendererWidth = axisTitleRenderer.desiredWidth;
    const axisTitleRendererHeight = axisTitleRenderer.desiredHeight;
    // layout with appropriate strategy
    const { axisRendererViewRect, axisTitleRendererViewRect } = layoutFunc(axisRendererWidth, axisRendererHeight, axisTitleRendererWidth, axisTitleRendererHeight, viewRect, axisBorder);
    axisRenderer.layout(axisRendererViewRect);
    axisTitleRenderer.layout(axisTitleRendererViewRect);
}
function layoutAxisPartsLeftStrategy(axisRendererWidth, axisRendererHeight, axisTitleRendererWidth, axisTitleRendererHeight, containerBounds) {
    return {
        axisTitleRendererViewRect: Rect_1.Rect.createWithCoords(containerBounds.left, containerBounds.top, containerBounds.left + axisTitleRendererWidth, containerBounds.bottom),
        axisRendererViewRect: Rect_1.Rect.createWithCoords(containerBounds.left + axisTitleRendererWidth, containerBounds.top, containerBounds.right, containerBounds.bottom)
    };
}
function layoutAxisPartsRightStrategy(axisRendererWidth, axisRendererHeight, axisTitleRendererWidth, axisTitleRendererHeight, containerBounds) {
    return {
        axisRendererViewRect: Rect_1.Rect.createWithCoords(containerBounds.left, containerBounds.top, containerBounds.left + axisRendererWidth, containerBounds.bottom),
        axisTitleRendererViewRect: Rect_1.Rect.createWithCoords(containerBounds.left + axisRendererWidth, containerBounds.top, containerBounds.right, containerBounds.bottom)
    };
}
function layoutAxisPartsTopStrategy(axisRendererWidth, axisRendererHeight, axisTitleRendererWidth, axisTitleRendererHeight, containerBounds) {
    return {
        axisTitleRendererViewRect: Rect_1.Rect.createWithCoords(containerBounds.left, containerBounds.top, containerBounds.right, containerBounds.top + axisTitleRendererHeight),
        axisRendererViewRect: Rect_1.Rect.createWithCoords(containerBounds.left, containerBounds.top + axisTitleRendererHeight, containerBounds.right, containerBounds.bottom)
    };
}
function layoutAxisPartsBottomStrategy(axisRendererWidth, axisRendererHeight, axisTitleRendererWidth, axisTitleRendererHeight, containerBounds) {
    return {
        axisRendererViewRect: Rect_1.Rect.createWithCoords(containerBounds.left, containerBounds.top, containerBounds.right, containerBounds.top + axisRendererHeight),
        axisTitleRendererViewRect: Rect_1.Rect.createWithCoords(containerBounds.left, containerBounds.top + axisRendererHeight, containerBounds.right, containerBounds.bottom)
    };
}
exports.testLayoutManager = {
    updateOuterAxesLayoutState,
    layoutAxisPartsLeftStrategy,
    layoutAxisPartsRightStrategy,
    layoutAxisPartsTopStrategy,
    layoutAxisPartsBottomStrategy
};
