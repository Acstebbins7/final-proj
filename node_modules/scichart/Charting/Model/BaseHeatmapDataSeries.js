"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseHeatmapDataSeries = void 0;
const Deleter_1 = require("../../Core/Deleter");
const EventHandler_1 = require("../../Core/EventHandler");
const Guard_1 = require("../../Core/Guard");
const NumberRange_1 = require("../../Core/NumberRange");
/**
 * The base class for Heatmap-style DataSeries in SciChart's
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 * A DataSeries stores the data to render. This is independent from the {@link IRenderableSeries | RenderableSeries}
 * which defines how that data should be rendered.
 *
 * See derived types of {@link BaseHeatmapDataSeries} to find out what Heatmap data-series are available.
 * See {@link UniformHeatmapRenderableSeries} to see the class for rendering a 2D JavaScript Heatmap Chart.
 */
class BaseHeatmapDataSeries {
    /**
     * Creates an instance of {@link BaseHeatmapDataSeries}
     * @param webAssemblyContext the {@link TSciChart | SciChart WebAssembly Context} containing native methods
     * and access to our underlying WebGL2 rendering engine
     * @param zValues the 2-Dimensional array which can be passed to populate the {@link BaseHeatmapDataSeries} at construct time
     */
    constructor(webAssemblyContext, zValues) {
        /**
         * @inheritDoc
         */
        this.dataChanged = new EventHandler_1.EventHandler();
        this.minXSpacing = 0;
        /**
         * Gets the width of the 2-dimensional array of {@link getZValues | Z-Values} where array is ranked [width][height]
         */
        this.arrayWidth = 0;
        /**
         * Gets the height of the 2-dimensional array of {@link getZValues | Z-Values} where array is ranked [width][height]
         */
        this.arrayHeight = 0;
        /**
         * When true, the {@link BaseHeatmapDataSeries} has data changes and requires redrawing
         */
        this.hasDataChangesProperty = false;
        this.lastZMin = -1;
        this.lastZMax = -1;
        this.webAssemblyContext = webAssemblyContext;
        this.normalizedVector = new this.webAssemblyContext.FloatVector();
        // Copy zValues
        this.setZValues(zValues);
    }
    /**
     * @inheritDoc
     */
    get isSorted() {
        return true;
    }
    /**
     * @inheritDoc
     */
    set isSorted(value) {
        throw new Error("setting isSorted on a heatmap series is not supported");
    }
    /**
     * @inheritDoc
     */
    get containsNaN() {
        return false;
    }
    /**
     * @inheritDoc
     */
    set containsNaN(value) {
        throw new Error("setting containsNaN on a heatmap series is not supported");
    }
    /**
     * Returns true if the Heatmap DataSeries has data changes.
     * This flag is set to true when notifyDataChanged is called, and reset to false after
     */
    get hasDataChanges() {
        return this.hasDataChangesProperty;
    }
    /**
     * Gets a readonly collection of Z-values which can be read in the format zValues[y][x]
     * Note that changes or manipulation of the 2D array will not update the Heatmap. Set it back via setZValues()
     * to see changes to the chart
     */
    getZValues() {
        return this.zValuesProperty;
    }
    /**
     * Sets a 2D array of zValues. Input is in the format zValues[y][x] where Y is 0 to height and X is 0 to Width
     * @param zValues
     */
    setZValues(zValues) {
        if (!zValues || !zValues[0]) {
            this.zValuesProperty = undefined;
            this.arrayHeight = 0;
            this.arrayWidth = 0;
            this.size = 0;
            return;
        }
        const firstRowLength = zValues[0].length;
        zValues.forEach(zRow => {
            if (!zRow) {
                throw new Error("Each row in zValues must be defined. See how to declare a 2D array in Javascript here https://stackoverflow.com/a/966234/303612");
            }
            if (zRow.length !== firstRowLength) {
                throw new Error("Each row in zValues must be the same length, so that the overall 2D array is square");
            }
        });
        const w = zValues[0].length;
        const h = zValues.length;
        this.arrayWidth = w;
        this.arrayHeight = h;
        this.size = w * h;
        this.zValuesProperty = zValues;
        this.notifyDataChanged();
    }
    /**
     * Gets the ZValue at the specific Y,X index where Y must be within 0-arrayHeight and X must be within 0-arrayWidth
     * @param yIndex the y-index from 0 to arrayHeight
     * @param xIndex the x-index from 0 to arrayWidth
     */
    getZValue(yIndex, xIndex) {
        return this.zValuesProperty[yIndex][xIndex];
    }
    /**
     * Sets the ZValue at the specific Y,X index where Y must be within 0-arrayHeight and X must be within 0-arrayWidth
     * @param yIndex the y-index from 0 to arrayHeight
     * @param xIndex the x-index from 0 to arrayWidth
     * @param zValue the new Z-value
     */
    setZValue(yIndex, xIndex, zValue) {
        this.zValuesProperty[yIndex][xIndex] = zValue;
        this.notifyDataChanged();
    }
    /**
     * Gets the minimum X-value for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get xMin() {
        return this.xRange.min;
    }
    /**
     * Gets the maximum X-value for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get xMax() {
        return this.xRange.max;
    }
    /**
     * Gets the minimum Y-value for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get yMin() {
        return this.yRange.min;
    }
    /**
     * Gets the maximum Y-value for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get yMax() {
        return this.yRange.max;
    }
    /**
     * Computes the minimum Z-value for this heatmap
     * @remarks
     * Be aware for performance reasons, every call to zMin will result in a recalculation
     */
    get zMin() {
        return this.zRange.min;
    }
    /**
     * Computes the maximum Z-value for this heatmap
     * @remarks
     * Be aware for performance reasons, every call to zMax will result in a recalculation
     */
    get zMax() {
        return this.zRange.max;
    }
    /**
     * Gets the XRange for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get xRange() {
        return this.getXRange();
    }
    /**
     * Gets the YRange for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get yRange() {
        return this.getYRange();
    }
    /**
     * Computes the ZRange for this heatmap, which controls where it is displayed on a cartesian chart
     * @remarks
     * Be aware for performance reasons, every call to zRange will result in a recalculation
     */
    get zRange() {
        return this.getZRange();
    }
    /**
     * @inheritDoc
     */
    get dataSeriesName() {
        return this.dataSeriesNameProperty;
    }
    /**
     * @inheritDoc
     */
    set dataSeriesName(dataSeriesName) {
        this.dataSeriesNameProperty = dataSeriesName;
        this.notifyDataChanged();
    }
    /**
     * Gets whether this Heatmap has values to display
     */
    get hasValues() {
        return this.arrayWidth > 0 && this.arrayHeight > 0;
    }
    /**
     * Gets the number of heatmap cells
     */
    count() {
        return this.arrayWidth * this.arrayHeight;
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.isDeleted = true;
        this.normalizedVector = Deleter_1.deleteSafe(this.normalizedVector);
    }
    /**
     * @inheritDoc
     */
    getIsDeleted() {
        return this.isDeleted;
    }
    /**
     * @inheritDoc
     */
    getNativeIndexes() {
        throw new Error("getNativeIndexes is invalid for heatmap type series. Try getting or setting zValues instead");
    }
    /**
     * @inheritDoc
     */
    getNativeXValues() {
        throw new Error("getNativeXValues is invalid for heatmap type series. Try getting or setting zValues instead");
    }
    /**
     * @inheritDoc
     */
    getNativeYValues() {
        throw new Error("getNativeYValues is invalid for heatmap type series. Try getting or setting zValues instead");
    }
    /**
     * @inheritDoc
     */
    getWindowedYRange(xRange, getPositiveRange, isCategoryAxis) {
        return this.yRange;
    }
    /**
     * Notify subscribers to dataChanged that data has changed. Also sets internal flags.
     * This will trigger a redraw on a parent SciChartSurface
     */
    notifyDataChanged() {
        this.hasDataChangesProperty = true;
        this.dataChanged.raiseEvent();
    }
    /**
     * Returns a FloatVector with normalized values based on the color map passed in
     * @param colorMap the {@link IColorMapParams} provides properties used to map heatmap Z-values into colors
     * for rendering in SciChart's {@link https://www.scichart.com/javascript-chart-features | Realtime JavaScript Charts}
     */
    getNormalizedVector(colorMap) {
        Guard_1.Guard.notNull(colorMap, "colorMap");
        Guard_1.Guard.argumentIsRealNumber(colorMap.minimum, "colorMap.minimum");
        Guard_1.Guard.argumentIsRealNumber(colorMap.maximum, "colorMap.maximum");
        const size = this.arrayWidth * this.arrayHeight;
        if (this.hasDataChangesProperty ||
            size !== this.normalizedVector.size() ||
            colorMap.minimum !== this.lastZMin ||
            colorMap.maximum !== this.lastZMax) {
            this.recreateNormalizedVector(colorMap.minimum, colorMap.maximum);
            this.lastZMin = colorMap.minimum;
            this.lastZMax = colorMap.maximum;
            this.hasDataChangesProperty = false;
        }
        return this.normalizedVector;
    }
    /**
     * Recreates the normalized vector (internally used for drawing heatmap) according to zMin and zMax values
     * @param zMin
     * @param zMax
     */
    recreateNormalizedVector(zMin, zMax) {
        const size = this.arrayWidth * this.arrayHeight;
        this.normalizedVector.clear();
        this.normalizedVector.resize(size, 0);
        let index = 0;
        const normalizationFactor = 1.0 / (zMax - zMin);
        for (let y = 0; y < this.arrayHeight; y++) {
            for (let x = 0; x < this.arrayWidth; x++) {
                // normalized value from 0..1 = (zValue - zMin) / ((zMax - zMin))
                const normalizedZValue = (this.zValuesProperty[y][x] - zMin) * normalizationFactor;
                this.normalizedVector.set(index++, normalizedZValue);
            }
        }
    }
    /**
     * Computes the range in the Z-direction for this DataSeries
     * @remarks
     * Be aware for performance reasons, every call to getZRange will result in a recalculation
     * @protected
     */
    getZRange() {
        const zValues = this.getZValues();
        if (zValues) {
            let zMin = Number.MAX_VALUE;
            let zMax = Number.MIN_VALUE;
            for (let y = 0; y < this.arrayHeight; ++y) {
                for (let x = 0; x < this.arrayWidth; x++) {
                    const zValue = zValues[y][x];
                    if (zValue < zMin)
                        zMin = zValue;
                    if (zValue > zMax)
                        zMax = zValue;
                }
            }
            return new NumberRange_1.NumberRange(zMin, zMax);
        }
        return undefined;
    }
}
exports.BaseHeatmapDataSeries = BaseHeatmapDataSeries;
