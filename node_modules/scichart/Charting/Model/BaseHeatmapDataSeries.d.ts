import { EventHandler } from "../../Core/EventHandler";
import { NumberRange } from "../../Core/NumberRange";
import { DoubleVector, FloatVector, TSciChart } from "../../types/TSciChart";
import { IColorMapParams } from "../Visuals/RenderableSeries/HeatmapColorMap";
import { EDataSeriesType, IDataSeries } from "./IDataSeries";
/**
 * Defines the interface to a Heatmap DataSeries in SciChart's High Performance Real-time
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 */
export interface IHeatmapSeries extends IDataSeries {
}
/**
 * The base class for Heatmap-style DataSeries in SciChart's
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 * A DataSeries stores the data to render. This is independent from the {@link IRenderableSeries | RenderableSeries}
 * which defines how that data should be rendered.
 *
 * See derived types of {@link BaseHeatmapDataSeries} to find out what Heatmap data-series are available.
 * See {@link UniformHeatmapRenderableSeries} to see the class for rendering a 2D JavaScript Heatmap Chart.
 */
export declare abstract class BaseHeatmapDataSeries implements IHeatmapSeries {
    /**
     * @inheritDoc
     */
    abstract type: EDataSeriesType;
    /**
     * @inheritDoc
     */
    readonly dataChanged: EventHandler<void>;
    minXSpacing: number;
    /**
     * Gets the width of the 2-dimensional array of {@link getZValues | Z-Values} where array is ranked [width][height]
     */
    arrayWidth: number;
    /**
     * Gets the height of the 2-dimensional array of {@link getZValues | Z-Values} where array is ranked [width][height]
     */
    arrayHeight: number;
    /**
     * When true, the {@link BaseHeatmapDataSeries} has data changes and requires redrawing
     */
    protected hasDataChangesProperty: boolean;
    /**
     * The {@link TSciChart | SciChart WebAssembly Context} containing native methods and access to our underlying WebGL2 rendering engine
     */
    protected webAssemblyContext: TSciChart;
    /**
     * Gets the size of the heatmap where size = {@link arrayWidth} * {@link arrayHeight}
     */
    protected size: number;
    /**
     * A normalized {@link FloatVector} is a native / WebAssembly vector (array) of Float32 values with normalized
     * values ready for drawing in SciChart's WebGL2 Rendering Engine
     */
    protected normalizedVector: FloatVector;
    private dataSeriesNameProperty;
    private isDeleted;
    private zValuesProperty;
    private lastZMin;
    private lastZMax;
    /**
     * Creates an instance of {@link BaseHeatmapDataSeries}
     * @param webAssemblyContext the {@link TSciChart | SciChart WebAssembly Context} containing native methods
     * and access to our underlying WebGL2 rendering engine
     * @param zValues the 2-Dimensional array which can be passed to populate the {@link BaseHeatmapDataSeries} at construct time
     */
    protected constructor(webAssemblyContext: TSciChart, zValues?: number[][]);
    /**
     * @inheritDoc
     */
    get isSorted(): boolean;
    /**
     * @inheritDoc
     */
    set isSorted(value: boolean);
    /**
     * @inheritDoc
     */
    get containsNaN(): boolean;
    /**
     * @inheritDoc
     */
    set containsNaN(value: boolean);
    /**
     * Returns true if the Heatmap DataSeries has data changes.
     * This flag is set to true when notifyDataChanged is called, and reset to false after
     */
    get hasDataChanges(): boolean;
    /**
     * Gets a readonly collection of Z-values which can be read in the format zValues[y][x]
     * Note that changes or manipulation of the 2D array will not update the Heatmap. Set it back via setZValues()
     * to see changes to the chart
     */
    getZValues(): number[][];
    /**
     * Sets a 2D array of zValues. Input is in the format zValues[y][x] where Y is 0 to height and X is 0 to Width
     * @param zValues
     */
    setZValues(zValues: number[][]): void;
    /**
     * Gets the ZValue at the specific Y,X index where Y must be within 0-arrayHeight and X must be within 0-arrayWidth
     * @param yIndex the y-index from 0 to arrayHeight
     * @param xIndex the x-index from 0 to arrayWidth
     */
    getZValue(yIndex: number, xIndex: number): number;
    /**
     * Sets the ZValue at the specific Y,X index where Y must be within 0-arrayHeight and X must be within 0-arrayWidth
     * @param yIndex the y-index from 0 to arrayHeight
     * @param xIndex the x-index from 0 to arrayWidth
     * @param zValue the new Z-value
     */
    setZValue(yIndex: number, xIndex: number, zValue: number): void;
    /**
     * Gets the minimum X-value for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get xMin(): number;
    /**
     * Gets the maximum X-value for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get xMax(): number;
    /**
     * Gets the minimum Y-value for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get yMin(): number;
    /**
     * Gets the maximum Y-value for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get yMax(): number;
    /**
     * Computes the minimum Z-value for this heatmap
     * @remarks
     * Be aware for performance reasons, every call to zMin will result in a recalculation
     */
    get zMin(): number;
    /**
     * Computes the maximum Z-value for this heatmap
     * @remarks
     * Be aware for performance reasons, every call to zMax will result in a recalculation
     */
    get zMax(): number;
    /**
     * Gets the XRange for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get xRange(): NumberRange;
    /**
     * Gets the YRange for this heatmap, which controls where it is displayed on a cartesian chart
     */
    get yRange(): NumberRange;
    /**
     * Computes the ZRange for this heatmap, which controls where it is displayed on a cartesian chart
     * @remarks
     * Be aware for performance reasons, every call to zRange will result in a recalculation
     */
    get zRange(): NumberRange;
    /**
     * @inheritDoc
     */
    get dataSeriesName(): string;
    /**
     * @inheritDoc
     */
    set dataSeriesName(dataSeriesName: string);
    /**
     * Gets whether this Heatmap has values to display
     */
    get hasValues(): boolean;
    /**
     * Gets the number of heatmap cells
     */
    count(): number;
    /**
     * @inheritDoc
     */
    delete(): void;
    /**
     * @inheritDoc
     */
    getIsDeleted(): boolean;
    /**
     * @inheritDoc
     */
    getNativeIndexes(): DoubleVector;
    /**
     * @inheritDoc
     */
    getNativeXValues(): DoubleVector;
    /**
     * @inheritDoc
     */
    getNativeYValues(): DoubleVector;
    /**
     * @inheritDoc
     */
    getWindowedYRange(xRange: NumberRange, getPositiveRange: boolean, isCategoryAxis: boolean): NumberRange;
    /**
     * Notify subscribers to dataChanged that data has changed. Also sets internal flags.
     * This will trigger a redraw on a parent SciChartSurface
     */
    notifyDataChanged(): void;
    /**
     * Returns a FloatVector with normalized values based on the color map passed in
     * @param colorMap the {@link IColorMapParams} provides properties used to map heatmap Z-values into colors
     * for rendering in SciChart's {@link https://www.scichart.com/javascript-chart-features | Realtime JavaScript Charts}
     */
    getNormalizedVector(colorMap: IColorMapParams): FloatVector;
    /**
     * Recreates the normalized vector (internally used for drawing heatmap) according to zMin and zMax values
     * @param zMin
     * @param zMax
     */
    recreateNormalizedVector(zMin: number, zMax: number): void;
    /**
     * Gets the range in the X-direction for this DataSeries
     */
    protected abstract getXRange(): NumberRange;
    /**
     * Gets the range in the Y-direction for this DataSeries
     */
    protected abstract getYRange(): NumberRange;
    /**
     * Computes the range in the Z-direction for this DataSeries
     * @remarks
     * Be aware for performance reasons, every call to getZRange will result in a recalculation
     * @protected
     */
    protected getZRange(): NumberRange;
}
