"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWindowedYRange = exports.BaseDataSeries = void 0;
const Deleter_1 = require("../../Core/Deleter");
const EventHandler_1 = require("../../Core/EventHandler");
const NumberRange_1 = require("../../Core/NumberRange");
const fillDoubleVectorFromJsArray_1 = require("../../utils/ccall/fillDoubleVectorFromJsArray");
const isRealNumber_1 = require("../../utils/isRealNumber");
/**
 * The base class for DataSeries in SciChart's
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 * A DataSeries stores the data to render. This is independent from the {@link IRenderableSeries | RenderableSeries}
 * which defines how that data should be rendered.
 *
 * See derived types of {@link BaseDataSeries} to find out what data-series are available.
 * See derived types of {@link IRenderableSeries} to find out what 2D JavaScript Chart types are available.
 */
class BaseDataSeries {
    /**
     * Creates an instance of {@link BaseDataSeries}
     * @param webAssemblyContext the {@link TSciChart | SciChart WebAssembly Context} containing native methods
     * and access to our underlying WebGL2 rendering engine
     * @param options the {@link IBaseDataSeriesOptions} which can be passed to config the DataSeries at construct time
     */
    constructor(webAssemblyContext, options) {
        var _a, _b;
        /**
         * @inheritDoc
         */
        this.dataChanged = new EventHandler_1.EventHandler();
        this.minXSpacing = 0;
        this.isSortedProperty = true;
        this.containsNaNProperty = true;
        this.webAssemblyContext = webAssemblyContext;
        this.xValues = new webAssemblyContext.DoubleVector();
        this.yValues = new webAssemblyContext.DoubleVector();
        this.indexes = new webAssemblyContext.DoubleVector();
        this.dataSeriesNameProperty = (_a = options === null || options === void 0 ? void 0 : options.dataSeriesName) !== null && _a !== void 0 ? _a : this.dataSeriesNameProperty;
        this.isSorted = (options === null || options === void 0 ? void 0 : options.dataIsSortedInX) !== undefined ? options === null || options === void 0 ? void 0 : options.dataIsSortedInX : this.isSortedProperty;
        this.containsNaN = (_b = options === null || options === void 0 ? void 0 : options.containsNaN) !== null && _b !== void 0 ? _b : this.containsNaNProperty;
    }
    /**
     * @inheritDoc
     */
    get containsNaN() {
        return this.containsNaNProperty;
    }
    /**
     * @inheritDoc
     */
    set containsNaN(containsNaN) {
        this.containsNaNProperty = containsNaN;
        this.notifyDataChanged();
    }
    /**
     * @inheritDoc
     */
    get isSorted() {
        return this.isSortedProperty;
    }
    /**
     * @inheritDoc
     */
    set isSorted(isSorted) {
        this.isSortedProperty = isSorted;
        this.notifyDataChanged();
    }
    /**
     * @inheritDoc
     */
    get dataSeriesName() {
        return this.dataSeriesNameProperty;
    }
    /**
     * @inheritDoc
     */
    set dataSeriesName(dataSeriesName) {
        this.dataSeriesNameProperty = dataSeriesName;
        this.notifyDataChanged();
    }
    /**
     * @inheritDoc
     */
    count() {
        if (this.xValues) {
            return this.xValues.size();
        }
        return 0;
    }
    /**
     * @inheritDoc
     */
    getIsDeleted() {
        return this.isDeleted;
    }
    /**
     * @inheritDoc
     */
    getNativeIndexes() {
        if (!this.indexes) {
            return undefined;
        }
        const indexes = this.indexes;
        if (indexes.size() < this.count()) {
            const newIndexesLength = this.count() - indexes.size();
            const indexValues = Array.from(Array(newIndexesLength), (_, i) => i + indexes.size());
            fillDoubleVectorFromJsArray_1.fillDoubleVectorFromJsArray(this.webAssemblyContext, this.indexes, indexValues);
        }
        return this.indexes;
    }
    /**
     * @inheritDoc
     */
    getNativeXValues() {
        return this.xValues;
    }
    /**
     * @inheritDoc
     */
    getNativeYValues() {
        return this.yValues;
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.xValues = Deleter_1.deleteSafe(this.xValues);
        this.yValues = Deleter_1.deleteSafe(this.yValues);
        this.indexes = Deleter_1.deleteSafe(this.indexes);
        this.isDeleted = true;
    }
    /**
     * Call to notify subscribers of {@link dataChanged} that the data has changed and {@link SciChartSurface} needs redrawing
     */
    notifyDataChanged() {
        this.dataChanged.raiseEvent();
    }
    /**
     * @inheritDoc
     */
    get xRange() {
        // TODO: calc for data not sorted ascending
        const nativeValues = this.getNativeXValues();
        let temp;
        if (this.count() === 1) {
            const min = nativeValues.get(0) - 1;
            const max = nativeValues.get(0) + 1;
            return new NumberRange_1.NumberRange(min, max);
        }
        else if (this.count() > 1) {
            let min = nativeValues.get(0);
            let max = nativeValues.get(this.count() - 1);
            if (min === max) {
                return new NumberRange_1.NumberRange(min - 1, max + 1);
            }
            else if (min > max) {
                temp = min;
                min = max;
                max = temp;
            }
            return new NumberRange_1.NumberRange(min, max);
        }
        return new NumberRange_1.NumberRange();
    }
    /**
     * @inheritDoc
     */
    getWindowedYRange(xRange, getPositiveRange, isXCategoryAxis = false) {
        return exports.getWindowedYRange(this.webAssemblyContext, this.xValues, this.yValues, xRange, getPositiveRange, isXCategoryAxis, this.isSorted);
    }
    getIndicesRange(xRange) {
        // TODO SearchMode downSearchMode = SearchMode.RoundDown, SearchMode upSearchMode = SearchMode.RoundUp
        return getIndicesRange(this.webAssemblyContext, this.xValues, xRange, this.isSorted);
    }
    /**
     * @inheritDoc
     */
    get hasValues() {
        return this.count() > 0;
    }
}
exports.BaseDataSeries = BaseDataSeries;
/** @ignore */
const getIndicesRange = (webAssemblyContext, xValues, xRange, isSorted) => {
    const count = xValues.size();
    let result = new NumberRange_1.NumberRange(0, -1);
    if (count > 0) {
        // For unsorted data, we need to draw everything
        if (!isSorted) {
            return new NumberRange_1.NumberRange(0, count - 1);
        }
        // For sorted data, we search the points in the viewport
        const iMin = webAssemblyContext.NumberUtil.FindIndex(xValues, xRange.min, webAssemblyContext.SCRTFindIndexSearchMode.RoundDown, true);
        const iMax = webAssemblyContext.NumberUtil.FindIndex(xValues, xRange.max, webAssemblyContext.SCRTFindIndexSearchMode.RoundUp, true);
        result = new NumberRange_1.NumberRange(iMin, iMax);
    }
    return result;
};
exports.getWindowedYRange = (webAssemblyContext, xValues, yValues, xRange, getPositiveRange, isXCategoryAxis, // false
isSorted) => {
    // TODO: getPositiveRange
    const count = xValues.size();
    // if one point
    if (count === 1) {
        const min = yValues.get(0) - 1;
        const max = yValues.get(0) + 1;
        return new NumberRange_1.NumberRange(min, max);
    }
    const indicesRange = isXCategoryAxis ? xRange : getIndicesRange(webAssemblyContext, xValues, xRange, isSorted);
    const iMin = Math.max(Math.floor(indicesRange.min), 0);
    const iMax = Math.min(Math.ceil(indicesRange.max), count - 1);
    if (iMax < iMin) {
        return undefined;
    }
    let minMax;
    try {
        minMax = webAssemblyContext.NumberUtil.MinMaxWithIndex(yValues, iMin, iMax - iMin + 1);
        if (!isRealNumber_1.isRealNumber(minMax.minD) || !isRealNumber_1.isRealNumber(minMax.maxD)) {
            return undefined;
        }
        return new NumberRange_1.NumberRange(minMax.minD, minMax.maxD);
    }
    finally {
        Deleter_1.deleteSafe(minMax);
    }
};
