"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaletteFactory = void 0;
const parseColor_1 = require("../../utils/parseColor");
const IPaletteProvider_1 = require("./IPaletteProvider");
/**
 * The PaletteFactory allows easy creation of palettes for some chart types
 */
class PaletteFactory {
    /**
     * Creates a Gradient Palette for line series, returning a {@link IStrokePaletteProvider} implementation which
     * colors data-points of line charts depending on the x-index of the data according to the Gradient Brush passed in
     * @param webAssemblyContext the {@link TSciChart | SciChart WebAssembly Context} containing native methods
     * @param gradientBrush the {@link GradientParams} containing information about the Gradient Brush
     */
    static createGradient(webAssemblyContext, gradientBrush) {
        // TODO (Andrew): Adjust createGradient to modify the output based on start/end point of gradient brush
        const xFactor = gradientBrush.endPoint.x - gradientBrush.startPoint.x;
        const yFactor = gradientBrush.endPoint.y - gradientBrush.startPoint.y;
        const colorData = PaletteFactory.createColorMap(webAssemblyContext, gradientBrush.gradientStops.slice(0));
        let renderSeries;
        const palette = {
            strokePaletteMode: IPaletteProvider_1.EStrokePaletteMode.GRADIENT,
            onAttached(parentSeries) {
                renderSeries = parentSeries;
            },
            onDetached() { },
            overrideStrokeArgb(xValue, yValue, index) {
                const count = renderSeries.getDataSeriesValuesCount();
                const lerpFactor = index / (count - 1);
                const mapIndex = webAssemblyContext.NumberUtil.Constrain(Math.round(lerpFactor * (colorData.length - 1)), 0, colorData.length - 1);
                const result = colorData[mapIndex];
                // console.log("GradientPalette called!");
                // console.log(`mapIndex is ${mapIndex}, colorData.length is ${colorData.length}`);
                // console.log(`count is ${count}, lerp is ${lerpFactor}. result is ${result}`);
                return result;
            }
        };
        return palette;
    }
    static createColorMap(webAssemblyContext, gradientStops) {
        const colorMap = [];
        const count = gradientStops.length;
        const first = gradientStops[0].offset;
        const last = gradientStops[gradientStops.length - 1].offset;
        let diff = last - first;
        const change = diff / (PaletteFactory.precision - 1);
        let prevColor = parseColor_1.parseColorToUIntArgb(gradientStops[0].color);
        let prevOffset = gradientStops[0].offset;
        let nextColor = prevColor;
        let nextOffset = prevOffset;
        if (count > 1) {
            nextColor = parseColor_1.parseColorToUIntArgb(gradientStops[1].color);
            nextOffset = gradientStops[1].offset;
        }
        diff = nextOffset - prevOffset;
        // console.log(`prev: ${prevColor}, ${toHex(prevColor)} @ ${prevOffset}`);
        // console.log(`next: ${nextColor}, ${toHex(nextColor)} @ ${nextOffset}`);
        let offsetInd = 0;
        for (let i = 0; i < PaletteFactory.precision; ++i) {
            const offset = first + i * change;
            // console.log(`offset: ${offset}`);
            if (offset >= nextOffset) {
                offsetInd++;
                prevOffset = nextOffset;
                prevColor = nextColor;
                if (offsetInd + 1 < count) {
                    nextColor = parseColor_1.parseColorToUIntArgb(gradientStops[offsetInd + 1].color);
                    nextOffset = gradientStops[offsetInd + 1].offset;
                }
                diff = nextOffset - prevOffset;
            }
            let color = 0;
            if (prevColor === nextColor || diff <= 0.00000000001) {
                color = nextColor;
            }
            else {
                const coef = (offset - prevOffset) / diff;
                // console.log(`prev: ${prevColor}, ${toHex(prevColor)} @ ${prevOffset}`);
                // console.log(`next: ${nextColor}, ${toHex(nextColor)} @ ${nextOffset}`);
                // console.log(`coef: ${coef}`);
                color = webAssemblyContext.NumberUtil.LinearInterpolateI(prevColor, nextColor, coef);
            }
            colorMap.push(color);
        }
        return colorMap;
    }
}
exports.PaletteFactory = PaletteFactory;
PaletteFactory.precision = 500;
