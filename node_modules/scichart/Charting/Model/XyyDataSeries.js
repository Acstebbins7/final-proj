"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XyyDataSeries = void 0;
const Deleter_1 = require("../../Core/Deleter");
const Guard_1 = require("../../Core/Guard");
const NumberRange_1 = require("../../Core/NumberRange");
const fillDoubleVectorFromJsArray_1 = require("../../utils/ccall/fillDoubleVectorFromJsArray");
const BaseDataSeries_1 = require("./BaseDataSeries");
const IDataSeries_1 = require("./IDataSeries");
/**
 * XyyDataSeries is a DataSeries for holding X, Y1, Y2 data in SciChart's 2D
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript Charts}
 * @remarks
 * The XyyDataSeries is primarily used with our {@link FastBandRenderableSeries | JavaScript Band Chart},
 * which draws a High-Low fill between two lines, where the fill changes color depending on whether line Y2 > Y1
 *
 * A DataSeries stores the data to render. This is independent from the {@link IRenderableSeries | RenderableSeries}
 * which defines how that data should be rendered.
 *
 * See derived types of {@link BaseDataSeries} to find out what data-series are available.
 * See derived types of {@link IRenderableSeries} to find out what 2D JavaScript Chart types are available.
 */
class XyyDataSeries extends BaseDataSeries_1.BaseDataSeries {
    /**
     * Creates an instance of {@link XyyDataSeries}
     * @param webAssemblyContext the {@link TSciChart | SciChart WebAssembly Context} containing native methods
     * and access to our underlying WebGL2 rendering engine
     * @param options the {@link IXyyDataSeriesOptions} which can be passed to configure the DataSeries at construct time
     */
    constructor(webAssemblyContext, options) {
        super(webAssemblyContext, options);
        /**
         * @inheritDoc
         */
        this.type = IDataSeries_1.EDataSeriesType.Xyy;
        this.y1Values = new webAssemblyContext.DoubleVector();
        this.y1AnimationValues = new webAssemblyContext.DoubleVector();
        if (options === null || options === void 0 ? void 0 : options.xValues) {
            Guard_1.Guard.notNull(options.yValues, "options.yValues");
            Guard_1.Guard.notNull(options.y1Values, "options.y1Values");
            this.appendRange(options.xValues, options.yValues, options.y1Values);
        }
    }
    /**
     * Gets a native / WebAssembly vector of Y2-values in the DataSeries
     */
    getNativeY1Values() {
        return this.y1Values;
    }
    /**
     * Appends a single X, Y, Y1 point to the DataSeries
     * @remarks
     * For best performance on drawing large datasets, use the {@link appendRange} method
     *
     * Any changes of the DataSeries will trigger a redraw on the parent {@link SciChartSurface}
     * @param x The X-value
     * @param y The Y1-value
     * @param y1 The Y2-value
     */
    append(x, y, y1) {
        if (!this.getIsDeleted()) {
            this.getNativeXValues().push_back(x);
            this.getNativeYValues().push_back(y);
            this.getNativeY1Values().push_back(y1);
            this.notifyDataChanged();
        }
    }
    /**
     * Appends a range of X, Y, Y1 points to the DataSeries
     * @remarks
     * This method is considerably higher performance than {@link append} which appends a single point
     *
     * Any changes of the DataSeries will trigger a redraw on the parent {@link SciChartSurface}
     * @param xValues The X-values
     * @param yValues The Y-values
     * @param y1Values The Y1-values
     */
    appendRange(xValues, yValues, y1Values) {
        if (!this.getIsDeleted()) {
            Guard_1.Guard.arraysSameLengthArr([
                { arg: xValues, name: "xValues" },
                { arg: yValues, name: "yValues" },
                { arg: y1Values, name: "y1Values" }
            ]);
            const nativeX = this.getNativeXValues();
            const nativeY = this.getNativeYValues();
            const nativeY1 = this.getNativeY1Values();
            // Old implementation with copying each element
            // for (let i = 0; i < xValues.length; i++) {
            //     nativeX.push_back(xValues[i]);
            //     nativeY.push_back(yValues[i]);
            //     nativeY1.push_back(y1Values[i]);
            // }
            // New implementation passing array from JS
            fillDoubleVectorFromJsArray_1.fillDoubleVectorFromJsArray(this.webAssemblyContext, nativeX, xValues);
            fillDoubleVectorFromJsArray_1.fillDoubleVectorFromJsArray(this.webAssemblyContext, nativeY, yValues);
            fillDoubleVectorFromJsArray_1.fillDoubleVectorFromJsArray(this.webAssemblyContext, nativeY1, y1Values);
            this.notifyDataChanged();
        }
    }
    /**
     * Updates a single Y, Y1-value by X-index
     * @remarks Any changes of the DataSeries will trigger a redraw on the parent {@link SciChartSurface}
     * @param index the index to update
     * @param y The new Y value
     * @param y1 The new Y1 value
     */
    update(index, y, y1) {
        if (!this.getIsDeleted()) {
            this.getNativeYValues().set(index, y);
            this.getNativeY1Values().set(index, y1);
            this.notifyDataChanged();
        }
    }
    /**
     * Inserts a single X,Y1,Y2 value at the start index
     * @remarks
     * For best performance on drawing large datasets, use the {@link insertRange} method
     *
     * Any changes of the DataSeries will trigger a redraw on the parent {@link SciChartSurface}
     * @param startIndex the index to insert at
     * @param x the Xvalue
     * @param y the Y1Value
     * @param y1 the Y2Value
     */
    insert(startIndex, x, y, y1) {
        if (!this.getIsDeleted()) {
            if (startIndex < 0 || startIndex >= this.count()) {
                throw new Error("Start index is out of range");
            }
            const nativeX = this.getNativeXValues();
            const nativeY = this.getNativeYValues();
            const nativeY1 = this.getNativeY1Values();
            nativeX.insertAt(startIndex, x);
            nativeY.insertAt(startIndex, y);
            nativeY1.insertAt(startIndex, y1);
            this.notifyDataChanged();
        }
    }
    /**
     * Inserts a ragne of X,Y1,Y2 values at the startIndex
     * @remarks
     * Any changes of the DataSeries will trigger a redraw on the parent {@link SciChartSurface}
     * @param startIndex the index to insert at
     * @param xValues the XValues
     * @param yValues the YValues
     * @param y1Values the Y1Values
     */
    insertRange(startIndex, xValues, yValues, y1Values) {
        if (!this.getIsDeleted()) {
            Guard_1.Guard.arraysSameLengthArr([
                { arg: xValues, name: "xValues" },
                { arg: yValues, name: "yValues" },
                { arg: y1Values, name: "y1Values" }
            ]);
            if (startIndex < 0 || startIndex >= this.count()) {
                throw new Error("Start index is out of range");
            }
            const rangeLength = xValues.length;
            const nativeX = this.getNativeXValues();
            const nativeY = this.getNativeYValues();
            const nativeY1 = this.getNativeY1Values();
            for (let i = 0; i < rangeLength; i++, startIndex++) {
                nativeX.insertAt(startIndex, xValues[i]);
                nativeY.insertAt(startIndex, yValues[i]);
                nativeY1.insertAt(startIndex, y1Values[i]);
            }
            this.notifyDataChanged();
        }
    }
    /**
     * Removes a single X,Y1,Y2 value at the specified index
     * @remarks Any changes of the DataSeries will trigger a redraw on the parent {@link SciChartSurface}
     * @param index the index to remove at
     */
    removeAt(index) {
        if (!this.getIsDeleted()) {
            if (index < 0 || index >= this.count()) {
                throw new Error("index is out of range");
            }
            this.getNativeXValues().removeAt(index);
            this.getNativeYValues().removeAt(index);
            this.getNativeY1Values().removeAt(index);
            this.notifyDataChanged();
        }
    }
    /**
     * Removes a range of X,Y1,Y2 values at the specified index
     * @remarks Any changes of the DataSeries will trigger a redraw on the parent {@link SciChartSurface}
     * @param startIndex the start index to remove at
     * @param count the number of points to remove
     */
    removeRange(startIndex, count) {
        if (!this.getIsDeleted()) {
            if (startIndex < 0 || startIndex + count > this.count()) {
                throw new Error("index is out of range");
            }
            this.getNativeXValues().removeRange(startIndex, count);
            this.getNativeYValues().removeRange(startIndex, count);
            this.getNativeY1Values().removeRange(startIndex, count);
            this.notifyDataChanged();
        }
    }
    /**
     * Clears the entire DataSeries.
     * @remarks
     * Note this does not free memory, WebAssembly/Native memory is released by calling {@link delete}, after which the
     * DataSeries is no longer usable.
     *
     * Any changes of the DataSeries will trigger a redraw on the parent {@link SciChartSurface}
     */
    clear() {
        if (!this.getIsDeleted()) {
            this.getNativeIndexes().clear();
            this.getNativeXValues().clear();
            this.getNativeYValues().clear();
            this.getNativeY1Values().clear();
            this.notifyDataChanged();
        }
    }
    /**
     * @inheritDoc
     */
    getWindowedYRange(xRange, getPositiveRange, isXCategoryAxis = false) {
        // TODO: getPositiveRange
        // if one point
        if (this.count() === 1) {
            const min = Math.min(this.yValues.get(0), this.y1Values.get(0)) - 1;
            const max = Math.max(this.yValues.get(0), this.y1Values.get(0)) + 1;
            return new NumberRange_1.NumberRange(min, max);
        }
        const indicesRange = isXCategoryAxis ? xRange : this.getIndicesRange(xRange);
        let yMin = Number.MAX_VALUE;
        let yMax = Number.MIN_VALUE;
        const iMin = Math.max(Math.floor(indicesRange.min), 0);
        const iMax = Math.min(Math.ceil(indicesRange.max), this.count() - 1);
        if (iMax < iMin) {
            return undefined;
        }
        for (let i = iMin; i <= iMax; i++) {
            const yVal = this.yValues.get(i);
            if (yVal < yMin) {
                yMin = yVal;
            }
            if (yVal > yMax) {
                yMax = yVal;
            }
            const y1Val = this.y1Values.get(i);
            if (y1Val < yMin) {
                yMin = y1Val;
            }
            if (y1Val > yMax) {
                yMax = y1Val;
            }
        }
        return new NumberRange_1.NumberRange(yMin, yMax);
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.y1Values = Deleter_1.deleteSafe(this.y1Values);
        this.y1AnimationValues = Deleter_1.deleteSafe(this.y1AnimationValues);
        super.delete();
    }
}
exports.XyyDataSeries = XyyDataSeries;
