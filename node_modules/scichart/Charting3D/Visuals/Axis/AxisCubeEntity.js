"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxisCubeEntity = void 0;
const Deleter_1 = require("../../../Core/Deleter");
const SceneEntityType_1 = require("../../../types/SceneEntityType");
const tsrExtensions_1 = require("../../../utils/tsrExtensions");
const BaseSceneEntity3D_1 = require("../Primitives/BaseSceneEntity3D");
/**
 * The {@link AxisCubeEntity} is a 3D Scene Entity (inherits {@link BaseSceneEntity3D}) which renders the 3D X,Y,Z axis cube,
 * axis walls and labels in a {@link SciChart3DSurface}
 */
class AxisCubeEntity extends BaseSceneEntity3D_1.BaseSceneEntity3D {
    /**
     * Creates an instance of an {@link AxisCubeEntity}
     * @param webAssemblyContext The {@link TSciChart3D | SciChart 3D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param sciChart3DSurface The {@link SciChart3DSurface} associated with the axis cube
     */
    constructor(webAssemblyContext, sciChart3DSurface) {
        super(webAssemblyContext);
        /**
         * @inheritDoc
         */
        this.type = SceneEntityType_1.ESceneEntityType.AxisCubeEntity;
        this.sciChart3DSurface = sciChart3DSurface;
        this.setNativeEntity(webAssemblyContext.SCRTAxisCubeEntity.implement(this));
    }
    /**
     * @inheritDoc
     */
    delete() {
        super.delete();
    }
    /**
     * @inheritDoc
     */
    Update(deltaTime) {
        // console.log("update");
        // this gets called from wasm!!
        if (!this.currentRenderPassData) {
            return;
        }
        const scrtAxisCubeEntity = this.nativeEntity;
        const scrtAxisCubeDescriptor = scrtAxisCubeEntity.GetDescriptorPtr();
        const { sceneDescriptor: { axisCubeDescriptor: { xAxisDescriptor, yAxisDescriptor, zAxisDescriptor } } } = this.currentRenderPassData;
        // TODO: MEMORY LEAK if we don't delete the SCRTAxisDescriptor
        const xScrtAxisDesc = new this.webAssemblyContext.SCRTAxisDescriptor();
        const yScrtAxisDesc = new this.webAssemblyContext.SCRTAxisDescriptor();
        const zScrtAxisDesc = new this.webAssemblyContext.SCRTAxisDescriptor();
        const descriptorsMapping = [
            [xScrtAxisDesc, xAxisDescriptor],
            [yScrtAxisDesc, yAxisDescriptor],
            [zScrtAxisDesc, zAxisDescriptor]
        ];
        descriptorsMapping.forEach(el => updateScrtAxisDescriptor(el[0], el[1]));
        scrtAxisCubeDescriptor.SetXAxisDesc(xScrtAxisDesc);
        scrtAxisCubeDescriptor.SetYAxisDesc(yScrtAxisDesc);
        scrtAxisCubeDescriptor.SetZAxisDesc(zScrtAxisDesc);
        // The code below is commented due to performance reasons
        // yAxisDescriptor.majorCoordinates.forEach(c => console.log(" .. coord " + c));
        // yAxisDescriptor.tickLabels.forEach(l => console.log(" .. label " + l));
        Deleter_1.deleteSafe(xScrtAxisDesc);
        Deleter_1.deleteSafe(yScrtAxisDesc);
        Deleter_1.deleteSafe(zScrtAxisDesc);
        // scrtAxisCubeEntity.DebugDescriptor();
        super.Update(deltaTime);
        // Redraw after setting up the axis cube
        if (!this.sciChart3DSurface.isAxisCubeRendered) {
            this.sciChart3DSurface.setIsAxisCubeRendered();
            setTimeout(() => this.sciChart3DSurface.invalidateElement(), 0);
        }
    }
}
exports.AxisCubeEntity = AxisCubeEntity;
/** @ignore */
const updateScrtAxisDescriptor = (scrtAxisDesc, axisDesc) => {
    var _a;
    scrtAxisDesc.m_strTitle = (_a = axisDesc.axisTitle) !== null && _a !== void 0 ? _a : "";
    scrtAxisDesc.m_fRangeSize = axisDesc.axisSize;
    scrtAxisDesc.m_fTitleOffset = axisDesc.titleOffset;
    scrtAxisDesc.m_fTextOffset = axisDesc.tickLabelsOffset;
    scrtAxisDesc.m_bBandsEnabled = axisDesc.drawBands;
    scrtAxisDesc.m_bMajorLinesEnabled = axisDesc.drawMajorGridlines;
    scrtAxisDesc.m_bMajorTicksEnabled = axisDesc.drawMajorTicks;
    scrtAxisDesc.m_bMinorLinesEnabled = axisDesc.drawMinorGridlines;
    scrtAxisDesc.m_bMinorTicksEnabled = axisDesc.drawMinorTicks;
    scrtAxisDesc.m_vBandColor = tsrExtensions_1.toTsrVector4(axisDesc.bandColor, scrtAxisDesc.m_vBandColor);
    scrtAxisDesc.m_MajorLineStyle = toScrtLineStyle(axisDesc.majorLineStyle, scrtAxisDesc.m_MajorLineStyle);
    scrtAxisDesc.m_MinorLineStyle = toScrtLineStyle(axisDesc.minorLineStyle, scrtAxisDesc.m_MinorLineStyle);
    scrtAxisDesc.m_TextStyle = toScrtTextStyle(axisDesc.labelStyle, scrtAxisDesc.m_TextStyle);
    scrtAxisDesc.m_MajorTickStyle = toScrtLineStyle(axisDesc.majorTickStyle, scrtAxisDesc.m_MajorTickStyle);
    scrtAxisDesc.m_MinorTickStyle = toScrtLineStyle(axisDesc.minorTickStyle, scrtAxisDesc.m_MinorTickStyle);
    // console.log("majorCoordinates", axisDesc.majorCoordinates);
    // console.log("minorCoordinates", axisDesc.minorCoordinates);
    // console.log("tickLabels", axisDesc.tickLabels);
    const majors = scrtAxisDesc.m_afMajors;
    // TODO: find out why it is reversed
    axisDesc.majorCoordinates.forEach(el => majors.push_back(el));
    scrtAxisDesc.m_afMajors = majors;
    const minors = scrtAxisDesc.m_afMinors;
    axisDesc.minorCoordinates.forEach(el => minors.push_back(el));
    scrtAxisDesc.m_afMinors = minors;
    const majorLabels = scrtAxisDesc.m_astrMajorLabels;
    axisDesc.tickLabels.forEach(el => majorLabels.push_back(el));
    scrtAxisDesc.m_astrMajorLabels = majorLabels;
};
/** @ignore */
const toScrtLineStyle = (lineStyle, scrtLineStyle) => {
    scrtLineStyle.m_fStrokeThickness = lineStyle.strokeThickness;
    scrtLineStyle.m_fStart = lineStyle.start;
    scrtLineStyle.m_fEnd = lineStyle.end;
    scrtLineStyle.m_vStrokeColor = tsrExtensions_1.toTsrVector4(lineStyle.stroke, scrtLineStyle.m_vStrokeColor);
    return scrtLineStyle;
};
/** @ignore */
const toScrtTextStyle = (labelStyle, scrtTextStyle) => {
    scrtTextStyle.m_fSize = labelStyle.fontSize;
    scrtTextStyle.m_strFont = labelStyle.fontFamily;
    scrtTextStyle.m_uiARGBColor = labelStyle.foreground;
    scrtTextStyle.m_fDpiScaling = labelStyle.dpiScaling;
    if (labelStyle.alignment) {
        scrtTextStyle.SetAlignment(labelStyle.alignment);
    }
    return scrtTextStyle;
};
