"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AxisBase3D = exports.EWhichAxis = void 0;
const AxisCore_1 = require("../../../Charting/Visuals/Axis/AxisCore");
const NumberRange_1 = require("../../../Core/NumberRange");
const parseColor_1 = require("../../../utils/parseColor");
const AxisBase3DLabelStyle_1 = require("./AxisBase3DLabelStyle");
const constants_1 = require("./constants");
/**
 * Which axis - used for calculations
 */
var EWhichAxis;
(function (EWhichAxis) {
    EWhichAxis[EWhichAxis["xAxis"] = 0] = "xAxis";
    EWhichAxis[EWhichAxis["yAxis"] = 1] = "yAxis";
    EWhichAxis[EWhichAxis["zAxis"] = 2] = "zAxis";
})(EWhichAxis = exports.EWhichAxis || (exports.EWhichAxis = {}));
/**
 * The base class for 3D Chart Axis within SciChart - High Performance
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript 3D Charts}.
 * @description
 * AxisBase3D is a base class for both 3D Axis types in SciChart. Concrete types include:
 *
 *  - {@link NumericAxis3D}: a Numeric 3D value-axis
 *
 * Set axis on the {@link SciChart3DSurface.xAxis}, {@link SciChart3DSurface.yAxis} or {@link SciChart3DSurface.zAxis} in 3D Charts.
 */
class AxisBase3D extends AxisCore_1.AxisCore {
    /**
     * Creates an instance of the {@link AxisBase3D}
     * @param webAssemblyContext The {@link TSciChart3D | SciChart 3D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param options optional parameters of type {@link IAxisBase3dOptions} to pass to the constructor
     * @protected
     */
    constructor(webAssemblyContext, options) {
        super(options);
        this.labelDepthTestEnabledProperty = false;
        this.planeBorderThicknessProperty = 2;
        this.isYAxisProperty = false;
        this.isZAxisProperty = false;
        this.titleOffsetProperty = 50;
        this.backgroundColorProperty = "black";
        this.tickLabelsOffsetProperty = 10;
        this.labelStyle = new AxisBase3DLabelStyle_1.AxisBase3DLabelStyle(this);
        this.webAssemblyContext3D = webAssemblyContext;
        this.isXAxisProperty = false;
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        this.labelStyle.foreground = themeProvider.labelForegroundBrush;
        this.axisBandsFill = themeProvider.axisBandsFill;
        this.majorGridLineStyle = { color: themeProvider.majorGridLineBrush };
        this.majorTickLineStyle = { color: themeProvider.majorGridLineBrush };
        this.minorGridLineStyle = { color: themeProvider.minorGridLineBrush };
        this.minorTickLineStyle = { color: themeProvider.minorGridLineBrush };
    }
    /**
     * Used internally - gets or sets whether this axis is a Y Axis
     */
    get isYAxis() {
        return this.isYAxisProperty;
    }
    /**
     * Used internally - gets or sets whether this axis is a Y Axis
     */
    set isYAxis(isYAxis) {
        this.isYAxisProperty = isYAxis;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_Y_AXIS);
    }
    /**
     * Used internally - gets or sets whether this axis is a Z Axis
     */
    get isZAxis() {
        return this.isZAxisProperty;
    }
    /**
     * Used internally - gets or sets whether this axis is a Z Axis
     */
    set isZAxis(isZAxis) {
        this.isZAxisProperty = isZAxis;
        this.notifyPropertyChanged(constants_1.PROPERTY.IS_Z_AXIS);
    }
    /**
     * Gets or sets if Label Depth test is enabled
     * @description When true, Labels are rendered with depth and can be behind chart objects.
     * Else, labels are always on top and closest to the viewer
     */
    get labelDepthTestEnabled() {
        return this.labelDepthTestEnabledProperty;
    }
    /**
     * Gets or sets if Label Depth test is enabled
     * @description When true, Labels are rendered with depth and can be behind chart objects.
     * Else, labels are always on top and closest to the viewer
     */
    set labelDepthTestEnabled(labelDepthTestEnabled) {
        this.labelDepthTestEnabledProperty = labelDepthTestEnabled;
        this.notifyPropertyChanged(constants_1.PROPERTY.LABEL_DEPTH_TEST);
    }
    /**
     * Gets or sets a thickness of the axis plane border.
     */
    get planeBorderThickness() {
        return this.planeBorderThicknessProperty;
    }
    /**
     * Gets or sets a thickness of the axis plane border.
     */
    set planeBorderThickness(planeBorderThickness) {
        this.planeBorderThicknessProperty = planeBorderThickness;
        this.notifyPropertyChanged(constants_1.PROPERTY.PLANE_BORDER_THICKNESS);
    }
    /**
     * Gets or sets the color of the axis plane border as an HTML Color code
     */
    get planeBorderColor() {
        return this.planeBorderColorProperty;
    }
    /**
     * Gets or sets the color of the axis plane border as an HTML Color code
     */
    set planeBorderColor(planeBorderColor) {
        this.planeBorderColorProperty = planeBorderColor;
        this.notifyPropertyChanged(constants_1.PROPERTY.PLANE_BORDER_COLOR);
    }
    /**
     * Gets or sets the Axis Label Alignment. See {@link ETextAlignment3D} for a list of values
     */
    get tickLabelAlignment() {
        return this.tickLabelAlignmentProperty;
    }
    /**
     * Gets or sets the Axis Label Alignment. See {@link ETextAlignment3D} for a list of values
     */
    set tickLabelAlignment(tickLabelAlignment) {
        this.tickLabelAlignmentProperty = tickLabelAlignment;
        this.notifyPropertyChanged(constants_1.PROPERTY.TICK_LABEL_ALIGNMENT);
    }
    /**
     * Gets or sets a value determining how {@link BaseRenderableSeries3D | 3D RenderableSeries} are clipped by axis on the positive side
     * @remarks See {@link EAxisSideClipping} for a list of values
     */
    get positiveSideClipping() {
        return this.positiveSideClippingProperty;
    }
    /**
     * Gets or sets a value determining how {@link BaseRenderableSeries3D | 3D RenderableSeries} are clipped by axis on the positive side
     * @remarks See {@link EAxisSideClipping} for a list of values
     */
    set positiveSideClipping(positiveSideClipping) {
        this.positiveSideClippingProperty = positiveSideClipping;
        this.notifyPropertyChanged(constants_1.PROPERTY.POSITIVE_SIDE_CLIPPING);
    }
    /**
     * Gets or sets a value determining how {@link BaseRenderableSeries3D | 3D RenderableSeries} are clipped by axis on the negative side
     * @remarks See {@link EAxisSideClipping} for a list of values
     */
    get negativeSideClipping() {
        return this.negativeSideClippingProperty;
    }
    /**
     * Gets or sets a value determining how {@link BaseRenderableSeries3D | 3D RenderableSeries} are clipped by axis on the negative side
     * @remarks See {@link EAxisSideClipping} for a list of values
     */
    set negativeSideClipping(negativeSideClipping) {
        this.negativeSideClippingProperty = negativeSideClipping;
        this.notifyPropertyChanged(constants_1.PROPERTY.NEGATIVE_SIDE_CLIPPING);
    }
    /**
     * Gets or sets the fill of the Axis Plane background as an HTML Color code. Defaults to transparent
     */
    get axisPlaneBackgroundFill() {
        return this.axisPlaneBackgroundFillProperty;
    }
    /**
     * Gets or sets the fill of the Axis Plane background as an HTML Color code. Defaults to transparent
     */
    set axisPlaneBackgroundFill(axisPlaneBackgroundFill) {
        this.axisPlaneBackgroundFillProperty = axisPlaneBackgroundFill;
        this.notifyPropertyChanged(constants_1.PROPERTY.AXIS_PLANE_BACKGROUND_FILL);
    }
    /**
     *  Gets or sets title text offset from the axis plane
     */
    get titleOffset() {
        return this.titleOffsetProperty;
    }
    /**
     *  Gets or sets title text offset from the axis plane
     */
    set titleOffset(value) {
        this.titleOffsetProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.TITLE_OFFSET);
    }
    /**
     * Gets or sets the color of the background of the axis plane as an HTML Color code
     */
    get backgroundColor() {
        return this.backgroundColorProperty;
    }
    /**
     * Gets or sets the color of the background of the axis plane as an HTML Color code
     */
    set backgroundColor(value) {
        this.backgroundColorProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.BACKGROUND_COLOR);
    }
    /**
     * Gets or sets tick labels offset from the axis plane
     */
    get tickLabelsOffset() {
        return this.tickLabelsOffsetProperty;
    }
    /**
     * Gets or sets tick labels offset from the axis plane
     */
    set tickLabelsOffset(value) {
        this.tickLabelsOffsetProperty = value;
        this.notifyPropertyChanged(constants_1.PROPERTY.TICK_LABELS_OFFSET);
    }
    /**
     * Called internally - returns an {@link IAxisDescriptor} which contains parameters, property and data
     * to pass to the WebAssembly 3D Engine for drawing this axis
     */
    toAxisDescriptor() {
        const defaultColor = "black";
        const defaultBandsColor = "#202123";
        const { majorTickCoords, minorTickCoords, majorTickLabels } = this.getTickCoordsAndLabels();
        // @ts-ignore
        // @ts-ignore
        const descriptor = {
            axisTitle: this.axisTitle,
            axisSize: this.getAxisSize(),
            backgroundColor: parseColor_1.parseColorToUIntArgb(this.backgroundColor || defaultColor),
            bandColor: parseColor_1.parseColorToTArgb(this.axisBandsFill || defaultBandsColor),
            borderColor: parseColor_1.parseColorToUIntArgb(this.planeBorderColor || defaultColor),
            borderThickness: this.planeBorderThickness,
            drawBands: this.drawMajorBands,
            drawMajorGridlines: this.drawMajorGridLines,
            drawMajorTicks: this.drawMajorTickLines,
            drawMinorGridlines: this.drawMinorGridLines,
            drawMinorTicks: this.drawMinorTickLines,
            isVisible: this.isVisible,
            labelDepthTestEnabled: this.labelDepthTestEnabled,
            labelStyle: {
                alignment: this.labelStyle.alignment,
                dpiScaling: this.labelStyle.dpiScaling / 96,
                fontFamily: this.labelStyle.fontFamily,
                fontSize: this.labelStyle.fontSize,
                foreground: parseColor_1.parseColorToUIntArgb(this.labelStyle.foreground)
            },
            majorCoordinates: majorTickCoords,
            majorLineStyle: toLineStyle(this.majorGridLineStyle),
            minorLineStyle: toLineStyle(this.minorGridLineStyle),
            majorTickStyle: toTickStyle(this.majorTickLineStyle),
            minorTickStyle: toTickStyle(this.minorTickLineStyle),
            minorCoordinates: minorTickCoords,
            smoothLabelOverlapAvoidance: false,
            tickLabels: majorTickLabels,
            tickLabelsOffset: this.tickLabelsOffset,
            titleOffset: this.titleOffset,
            titleStyle: undefined // ITextStyle interface which contains font, fontfamily, fontsize
        };
        return descriptor;
    }
    validateAxis() {
        // TODO
    }
    /**
     * @Summary Part of AutoRanging - Gets the maximum range on this axis
     * @description The getMaximumRange function computes the {@link visibleRange} min and max that this axis must
     * have to display all the data in the chart.
     */
    getMaximumRange() {
        var _a, _b, _c, _d, _e;
        let maximumRange = new NumberRange_1.NumberRange(NaN, NaN);
        if (((_b = (_a = this.parentSurface) === null || _a === void 0 ? void 0 : _a.renderableSeries) === null || _b === void 0 ? void 0 : _b.size()) > 0) {
            let whichAxis;
            if (this.isXAxis) {
                whichAxis = EWhichAxis.xAxis;
            }
            else if (this.isYAxis) {
                whichAxis = EWhichAxis.yAxis;
            }
            else if (this.isZAxis) {
                whichAxis = EWhichAxis.zAxis;
            }
            else {
                throw Error("AxisBase3D: isXAxis, isYAxis, isZAxis flag are not set");
            }
            maximumRange = (_c = this.getMaximumRangeAs(this.parentSurface.renderableSeries, whichAxis)) !== null && _c !== void 0 ? _c : maximumRange;
            if (maximumRange.isZero()) {
                maximumRange = this.coerceZeroVisibleRange(maximumRange);
            }
            // Apply growby
            if ((_d = this.growBy) === null || _d === void 0 ? void 0 : _d.isDefined()) {
                maximumRange = maximumRange.growBy(this.growBy, false);
            }
        }
        const currentVisibleRange = ((_e = this.visibleRange) === null || _e === void 0 ? void 0 : _e.isDefined()) ? this.visibleRange : this.getDefaultNonZeroRange();
        return (maximumRange === null || maximumRange === void 0 ? void 0 : maximumRange.isDefined()) ? maximumRange : currentVisibleRange;
    }
    /**
     * @Summary Part of AutoRanging - Gets the maximum range on this axis.
     * @description The getMaximumRange function computes the {@link visibleRange} min and max that this axis must
     * have to display all the data in the chart.
     * @remarks This overload impersonates a specific axis according to the {@link EWhichAxis} parameter
     * @param whichAxis Which axis we should calculate as. See {@link EWhichAxis} for a list of values
     * @param renderableSeries The series to use for calculations
     */
    getMaximumRangeAs(renderableSeries, whichAxis) {
        let maximumRange;
        renderableSeries.asArray().forEach(r => {
            if (r.isVisible && r.dataSeries) {
                const range = whichAxis === EWhichAxis.xAxis
                    ? r.dataSeries.xRange
                    : whichAxis === EWhichAxis.yAxis
                        ? r.dataSeries.yRange
                        : r.dataSeries.zRange;
                if (range === null || range === void 0 ? void 0 : range.isDefined()) {
                    maximumRange = !maximumRange ? range : range.union(maximumRange);
                }
            }
        });
        return maximumRange;
    }
    /**
     * gets the axis size from the WorldDimensions, depending on whether it is an X,Y or ZAxis
     */
    getAxisSize() {
        if (!this.parentSurface) {
            return 0;
        }
        const worldDimensions = this.parentSurface.worldDimensions;
        if (!worldDimensions) {
            throw new Error("Must set property sciChart3DSurface.worldDimensions to a valid Vector3 with X,Y,Z world size");
        }
        const axisSize = this.isXAxis ? worldDimensions.x : this.isYAxis ? worldDimensions.y : worldDimensions.z;
        return axisSize;
    }
    /**
     * Given an array of numeric values for axis labels, returns a list of strings. Uses {@link labelProvider} property to format labels
     * @param majorTicks The major tick values as numbers to be converted to labels
     * @protected
     */
    getLabels(majorTicks) {
        return majorTicks.map(tick => this.labelProvider.formatLabel(tick));
    }
    getTicks() {
        const maxAutoTicks = this.getMaxAutoTicks();
        const delta = this.deltaCalculator.getDeltaFromRange(this.visibleRange.min, this.visibleRange.max, this.minorsPerMajor, maxAutoTicks);
        this.minorDeltaProperty = delta.min;
        this.majorDeltaProperty = delta.max;
        const majorTicks = this.tickProvider.getMajorTicks(delta.min, delta.max, this.visibleRange);
        const minorTicks = this.tickProvider.getMinorTicks(delta.min, delta.max, this.visibleRange);
        return {
            majorTicks,
            minorTicks
        };
    }
    getTickCoordsAndLabels() {
        const coordCalc = this.getCurrentCoordinateCalculator();
        const getTickCoords = (ticks) => ticks.map(el => coordCalc.getCoordinate(el));
        const { majorTicks, minorTicks } = this.getTicks();
        const majorTickLabels = this.getLabels(majorTicks);
        const majorTickCoords = getTickCoords(majorTicks);
        const minorTickCoords = getTickCoords(minorTicks);
        return {
            majorTicks,
            majorTickLabels,
            majorTickCoords,
            minorTicks,
            minorTickCoords
        };
    }
}
exports.AxisBase3D = AxisBase3D;
/** @ignore */
const toLineStyle = (styleProperty) => {
    return {
        stroke: parseColor_1.parseColorToTArgb(styleProperty.color),
        strokeThickness: styleProperty.strokeThickness,
        start: 1,
        end: 1
    };
};
/** @ignore */
const toTickStyle = (tickLineStyle) => {
    return {
        stroke: parseColor_1.parseColorToTArgb(tickLineStyle.color),
        strokeThickness: tickLineStyle.strokeThickness,
        start: 0,
        end: tickLineStyle.tickSize
    };
};
