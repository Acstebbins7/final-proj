"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseSceneEntity3D = void 0;
const Deleter_1 = require("../../../Core/Deleter");
const ObservableArray_1 = require("../../../Core/ObservableArray");
const SceneEntityType_1 = require("../../../types/SceneEntityType");
/**
 * The {@link BaseSceneEntity3D} provides a base class for entities, or 3D objects in the 3D scene within
 * SciChart's High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript 3D Charts}
 * @remarks Each {@link BaseSceneEntity3D} wraps a native WebAssembly {@link SCRTSceneEntity} which is returned by
 * the {@link nativeEntity} property. This is passed to SciChart's 3D engine and inserted into the scene when added
 * to the {@link SciChart3DSurface.rootEntity} collection.
 */
class BaseSceneEntity3D {
    /**
     * Creates an instance of the {@link BaseSceneEntity3D}
     * @param webAssemblyContext The {@link TSciChart3D | SciChart 3D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @protected
     */
    constructor(webAssemblyContext) {
        /**
         * When true, the entity and all its children are visible
         */
        this.isVisible = true;
        this.webAssemblyContext = webAssemblyContext;
        this.entityId = 11111;
        this.detachChild = this.detachChild.bind(this);
        this.attachChild = this.attachChild.bind(this);
        this.children = new ObservableArray_1.ObservableArray();
        this.children.collectionChanged.subscribe(args => {
            var _a, _b;
            (_a = args.getOldItems()) === null || _a === void 0 ? void 0 : _a.forEach(this.detachChild);
            (_b = args.getNewItems()) === null || _b === void 0 ? void 0 : _b.forEach(this.attachChild);
        });
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.children.asArray().forEach(el => el.delete());
        if (this.nativeEntity) {
            this.world.RemoveEntity(this.nativeEntity);
        }
        this.nativeEntityProperty = Deleter_1.deleteSafe(this.nativeEntityProperty);
    }
    /**
     * Update method called from WebAssembly engine. Use this to update meshes, properties, geometry before draw.
     * When overriding, you must call super.Update() for the object to draw in the scene
     * @param deltaTime
     * @constructor
     */
    Update(deltaTime) {
        // this gets called from wasm!!
        // when overriding always call super.Update(deltaTime) in the end of the method
        if (!this.currentRenderPassData) {
            return;
        }
        if (!this.nativeEntity) {
            throw new Error("BaseSceneEntity.nativeSceneEntity must be set by calling setEntity() in the constructor");
        }
        if (this.isVisible) {
            this.nativeEntity.Update(deltaTime);
        }
    }
    /**
     * Render method called from WebAssembly engine. Use this to do immediate-mode 3D drawing, or to draw created meshes
     * When overriding, you must call super.Update() for the object to draw in the scene
     * @constructor
     */
    Render() {
        // this gets called from wasm!!
        if (!this.currentRenderPassData) {
            return;
        }
        if (!this.nativeEntity) {
            throw new Error("BaseSceneEntity.nativeSceneEntity must be set by calling setEntity() in the constructor");
        }
        if (this.isVisible) {
            this.nativeEntity.Render();
        }
    }
    /**
     * @inheritDoc
     */
    onEngineRestart() {
        // TODO: TSRSceneEntity.OnEngineRestart
    }
    /**
     * @inheritDoc
     */
    get entityId() {
        return this.entityIdProperty;
    }
    /**
     * @inheritDoc
     */
    set entityId(value) {
        this.entityIdProperty = value;
        // TODO: this.nativeEntity.SetEntityId(value)
    }
    /**
     * @inheritDoc
     */
    setRenderPassData(rpd) {
        this.currentRenderPassData = rpd;
    }
    /**
     * @inheritDoc
     */
    getEntity(type) {
        for (let i = 0; i < this.children.size(); i++) {
            const ent = this.children.get(i);
            if (ent.type === type) {
                return ent;
            }
        }
        // TODO: return default(T);
        return undefined;
    }
    /**
     * Call this to inform SciChart that data or properties have changed and the 3D Scene must be redrawn
     */
    invalidateScene() {
        var _a, _b;
        (_b = (_a = this.rootSceneEntity) === null || _a === void 0 ? void 0 : _a.parentSurface) === null || _b === void 0 ? void 0 : _b.invalidateElement();
    }
    /**
     * @inheritDoc
     */
    onAttached() {
        if (this.parent.type === SceneEntityType_1.ESceneEntityType.SCRTSceneEntity) {
            // TODO
            // var world = scrtSeParent.GetWorld();
            // SetWorld(world);
            // _nativeEntity.SetWorld(world);
        }
    }
    /**
     * @inheritDoc
     */
    onDetached() {
        // Override in derived class to be notified of detached
    }
    /**
     * @inheritDoc
     */
    visitEntities(operation) {
        operation(this);
        this.children.asArray().forEach(child => {
            child.visitEntities(operation);
        });
    }
    /**
     * @inheritDoc
     */
    get nativeEntity() {
        return this.nativeEntityProperty;
    }
    /**
     * Called internally - Attach a child to the current entity
     * @param childEntity
     * @protected
     */
    attachChild(childEntity) {
        // TODO: entity.EntityIdProvider = this.EntityIdProvider;
        const parentEntity = this;
        parentEntity.nativeEntity.AddChildEntityInternal(childEntity.nativeEntity);
        childEntity.parent = parentEntity;
        childEntity.onAttached();
    }
    /**
     * Called internally - detach a child from the current entity
     * @param childEntity
     * @protected
     */
    detachChild(childEntity) {
        const parentEntity = this;
        parentEntity.nativeEntity.RemoveChildEntityInternal(childEntity.nativeEntity);
        childEntity.onDetached();
        childEntity.parent = undefined;
    }
    /**
     * Called internally - sets the native entity
     * @param entity
     * @protected
     */
    setNativeEntity(entity) {
        this.nativeEntityProperty = entity;
    }
    /**
     * Called internally - gets the world entity
     * @protected
     */
    get world() {
        return this.webAssemblyContext.SCRTGetWorld3D();
    }
}
exports.BaseSceneEntity3D = BaseSceneEntity3D;
