"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SurfaceMeshSceneEntity = exports.SurfaceMeshSceneEntityState = void 0;
const Deleter_1 = require("../../../Core/Deleter");
const Guard_1 = require("../../../Core/Guard");
const NumberRange_1 = require("../../../Core/NumberRange");
const SceneEntityType_1 = require("../../../types/SceneEntityType");
const parseColor_1 = require("../../../utils/parseColor");
const tsrExtensions_1 = require("../../../utils/tsrExtensions");
const BaseDataSeries3D_1 = require("../../Model/DataSeries/BaseDataSeries3D");
const Constants_1 = require("../RenderableSeries/Constants");
const SurfaceMeshRenderableSeries3D_1 = require("../RenderableSeries/SurfaceMesh/SurfaceMeshRenderableSeries3D");
const RenderableSeriesSceneEntity_1 = require("./RenderableSeriesSceneEntity");
const RenderableSeriesSceneEntityState_1 = require("./RenderableSeriesSceneEntityState");
// tslint:disable:max-classes-per-file
/** @ignore */
var EGridDrawingFeatures;
(function (EGridDrawingFeatures) {
    EGridDrawingFeatures[EGridDrawingFeatures["SCRT_GRID_DRAWING_FEATURES_SOLID"] = 1] = "SCRT_GRID_DRAWING_FEATURES_SOLID";
    EGridDrawingFeatures[EGridDrawingFeatures["SCRT_GRID_DRAWING_FEATURES_WIREFRAME"] = 2] = "SCRT_GRID_DRAWING_FEATURES_WIREFRAME";
    EGridDrawingFeatures[EGridDrawingFeatures["SCRT_GRID_DRAWING_FEATURES_CONTOURS"] = 4] = "SCRT_GRID_DRAWING_FEATURES_CONTOURS";
    EGridDrawingFeatures[EGridDrawingFeatures["SCRT_GRID_DRAWING_FEATURES_SKIRT"] = 8] = "SCRT_GRID_DRAWING_FEATURES_SKIRT";
})(EGridDrawingFeatures || (EGridDrawingFeatures = {}));
/** @ignore */
function toString(tsrVector) {
    return `xyzw= (${tsrVector.x} ${tsrVector.y} ${tsrVector.z} ${tsrVector.w})`;
}
/** @ignore */
function toStringRange(r) {
    return `(min=${r.m_fMin.toFixed(2)}, max=${r.m_fMax.toFixed(2)})`;
}
/** @ignore */
function debugProps(props) {
    // console.log(` m_fLightingAmount ${props.m_fLightingAmount}`);
    // console.log(` m_fShininess ${props.m_fShininess}`);
    // console.log(` m_fHighlight ${props.m_fHighlight}`);
    // console.log(` m_fHardNormals ${props.m_fHardNormals}`);
    // console.log(` m_vContourColor ${toString(props.m_vContourColor)}`);
    // console.log(` m_vWireframeStroke ${toString(props.m_vWireframeStroke)}`);
    // console.log(` m_fContourOffset ${props.m_fContourOffset}`);
    // console.log(` m_fContourInterval ${props.m_fContourInterval}`);
    // console.log(` m_fContourThickness ${props.m_fContourThickness}`);
    // console.log(` m_bUseSolidCells ${props.m_bUseSolidCells}`);
    // console.log(` m_bUseGradient ${props.m_bUseGradient}`);
    // console.log(` m_bDrawBackSide ${props.m_bDrawBackSide}`);
    // console.log(` m_eDrawMeshAs ${props.m_eDrawMeshAs}`);
    // console.log(` m_fStrokeThickness ${props.m_fStrokeThickness}`);
}
/**
 * State object for {@link SurfaceMeshSceneEntity}
 */
class SurfaceMeshSceneEntityState extends RenderableSeriesSceneEntityState_1.RenderableSeriesSceneEntityState {
    /**
     * Gets or sets whether the color map texture is valid
     */
    get isColorMapTextureInvalid() {
        return this.isColorMapTextureInvalidProperty;
    }
    /**
     * Gets or sets whether the color map texture is valid
     */
    setColorMapTextureInvalid() {
        this.isColorMapTextureInvalidProperty = true;
    }
    /**
     * @inheritDoc
     */
    validate(rs, rpi) {
        return super.validate(rs, rpi) && this.isColorMapTextureInvalid;
    }
    /**
     * @inheritDoc
     */
    reset(rs, rpi) {
        super.reset(rs, rpi);
        this.isColorMapTextureInvalidProperty = false;
    }
}
exports.SurfaceMeshSceneEntityState = SurfaceMeshSceneEntityState;
/**
 * @summary {@link BaseSceneEntity3D} type for drawing 3D Surface Plot or Surface Mesh with optional Contours in
 * SciChart's High Performance {@link https://www.scichart.com/javascript-chart-features | JavaScript 3D Charts}
 * @remarks See related type {@link SurfaceMeshRenderableSeries3D} which should be added to {@link SciChart3DSurface.renderableSeries}
 * along with data from an {@link UniformGridDataSeries3D} to create a 3D Surface Mesh or Surface Plot
 */
class SurfaceMeshSceneEntity extends RenderableSeriesSceneEntity_1.RenderableSeriesSceneEntity {
    /**
     * Creates an instance of {@link SurfaceMeshSceneEntity}
     * @param webAssemblyContext The {@link TSciChart3D | SciChart 3D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param parentSeries The parent {@link BaseRenderableSeries3D} which this entity maps to
     */
    constructor(webAssemblyContext, parentSeries) {
        var _a;
        super(webAssemblyContext, parentSeries, new SurfaceMeshSceneEntityState());
        /**
         * @inheritDoc
         */
        this.type = SceneEntityType_1.ESceneEntityType.SurfaceMeshSceneEntity;
        this.setNativeEntity(webAssemblyContext.SCRTGridMeshEntity.implement(this));
        this.colorMapTexture = Deleter_1.deleteSafe(this.colorMapTexture);
        this.colorMapTexture = (_a = this.parentSeries.meshColorPalette) === null || _a === void 0 ? void 0 : _a.getTexture(this.parentSeries.colorMapTextureSize);
    }
    /**
     * @inheritDoc
     */
    notifySeriesPropertyChanged(propertyName) {
        if (propertyName === Constants_1.PROPERTY.MESH_COLOR_PALETTE ||
            propertyName === Constants_1.PROPERTY.MESH_PALETTE_MODE ||
            propertyName === Constants_1.PROPERTY.MESH_RESOLUTION ||
            propertyName === Constants_1.PROPERTY.COLOR_MAP_TEXTURE_SIZE) {
            this.state.setColorMapTextureInvalid();
        }
        super.notifySeriesPropertyChanged(propertyName);
    }
    /**
     * @inheritDoc
     */
    delete() {
        super.delete();
        this.colorMapTexture = Deleter_1.deleteSafe(this.colorMapTexture);
    }
    /**
     * @inheritDoc
     */
    Render() {
        if (!this.currentRenderPassData) {
            return;
        }
        if (!this.colorMapTexture || !this.parentSeries.dataSeries) {
            console.log("Cannot draw a SurfaceMeshRenderableSeries3D without a meshColorPalette or dataSeries!");
            return;
        }
        // Setup Properties for grid mesh
        //
        let props;
        try {
            props = new this.webAssemblyContext.SCRTGridDrawingProperties();
            let features = 0;
            if (this.hasFlag(this.parentSeries.drawMeshAs, [
                SurfaceMeshRenderableSeries3D_1.EDrawMeshAs.SOLID_WIREFRAME,
                SurfaceMeshRenderableSeries3D_1.EDrawMeshAs.SOLID_WIREFRAME,
                SurfaceMeshRenderableSeries3D_1.EDrawMeshAs.SOLID_WIREFRAME_WITH_CONTOURS
            ])) {
                features |= EGridDrawingFeatures.SCRT_GRID_DRAWING_FEATURES_WIREFRAME;
            }
            if (this.hasFlag(this.parentSeries.drawMeshAs, [
                SurfaceMeshRenderableSeries3D_1.EDrawMeshAs.SOLID_WIREFRAME,
                SurfaceMeshRenderableSeries3D_1.EDrawMeshAs.SOLID_MESH,
                SurfaceMeshRenderableSeries3D_1.EDrawMeshAs.SOLID_WITH_CONTOURS,
                SurfaceMeshRenderableSeries3D_1.EDrawMeshAs.SOLID_WIREFRAME_WITH_CONTOURS
            ])) {
                features |= EGridDrawingFeatures.SCRT_GRID_DRAWING_FEATURES_SOLID;
            }
            if (this.hasFlag(this.parentSeries.drawMeshAs, [
                SurfaceMeshRenderableSeries3D_1.EDrawMeshAs.CONTOURS,
                SurfaceMeshRenderableSeries3D_1.EDrawMeshAs.SOLID_WITH_CONTOURS,
                SurfaceMeshRenderableSeries3D_1.EDrawMeshAs.SOLID_WIREFRAME_WITH_CONTOURS
            ])) {
                features |= EGridDrawingFeatures.SCRT_GRID_DRAWING_FEATURES_CONTOURS;
            }
            if (this.parentSeries.drawSkirt) {
                features |= EGridDrawingFeatures.SCRT_GRID_DRAWING_FEATURES_SKIRT;
            }
            const useGradient = this.hasFlag(this.parentSeries.meshPaletteMode, [
                SurfaceMeshRenderableSeries3D_1.EMeshPaletteMode.HEIGHT_MAP_INTERPOLATED,
                SurfaceMeshRenderableSeries3D_1.EMeshPaletteMode.HEIGHT_MAP_SOLID_CELLS
            ]);
            const useSolidCells = this.hasFlag(this.parentSeries.meshPaletteMode, [
                SurfaceMeshRenderableSeries3D_1.EMeshPaletteMode.HEIGHT_MAP_SOLID_CELLS,
                SurfaceMeshRenderableSeries3D_1.EMeshPaletteMode.TEXTURED_SOLID_CELLS
            ]);
            // console.log(`features: ${features}`);
            props.SetDrawMeshAsInteger(features);
            props.m_bUseGradient = useGradient;
            props.m_bUseSolidCells = useSolidCells;
            props.m_fStrokeThickness = this.parentSeries.strokeThickness;
            props.m_fContourThickness = this.parentSeries.contourStrokeThickness;
            props.m_fContourInterval = this.parentSeries.contourInterval;
            props.m_fContourOffset = this.parentSeries.contourOffset;
            if (this.parentSeries.stroke) {
                const sc = parseColor_1.parseColorToTArgb(this.parentSeries.stroke);
                props.m_vWireframeStroke = tsrExtensions_1.toTsrVector4(sc, props.m_vWireframeStroke);
            }
            if (this.parentSeries.contourStroke) {
                props.m_vContourColor = tsrExtensions_1.toTsrVector4(parseColor_1.parseColorToTArgb(this.parentSeries.contourStroke), props.m_vContourColor);
            }
            props.m_fHardNormals = this.parentSeries.cellHardnessFactor;
            props.m_fHighlight = this.parentSeries.highlight;
            props.m_fShininess = this.parentSeries.shininess;
            props.m_fLightingAmount = this.parentSeries.lightingFactor;
            // console.log("..setting GridDrawingProps");
            debugProps(props);
            this.nativeEntity.SetGridDrawingProperties(props);
        }
        finally {
            Deleter_1.deleteSafe(props);
        }
        // Setup Range and Offset
        const xCalc = this.currentRenderPassData.xCalc;
        const yCalc = this.currentRenderPassData.yCalc;
        const zCalc = this.currentRenderPassData.zCalc;
        let meshRangeX;
        let meshRangeY;
        let meshRangeZ;
        let visibleRangeX;
        let visibleRangeY;
        let visibleRangeZ;
        try {
            const yRange = new NumberRange_1.NumberRange(this.parentSeries.minimum, this.parentSeries.maximum);
            meshRangeX = this.rangeToSCRTAxisRange(this.webAssemblyContext, xCalc, this.parentSeries.dataSeries.xRange);
            meshRangeY = this.rangeToSCRTAxisRange(this.webAssemblyContext, yCalc, yRange);
            meshRangeZ = this.rangeToSCRTAxisRange(this.webAssemblyContext, zCalc, this.parentSeries.dataSeries.zRange);
            // console.log(
            //     `meshRange: x=${toStringRange(meshRangeX)} y=${toStringRange(meshRangeY)} z=${toStringRange(
            //         meshRangeZ
            //     )}`
            // );
            this.nativeEntity.SetMeshRange(meshRangeX, meshRangeY, meshRangeZ);
            visibleRangeX = this.toSCRTAxisRange(this.webAssemblyContext, xCalc, xCalc.visibleMin, xCalc.visibleMax);
            visibleRangeY = this.toSCRTAxisRange(this.webAssemblyContext, yCalc, yCalc.visibleMin, yCalc.visibleMax);
            visibleRangeZ = this.toSCRTAxisRange(this.webAssemblyContext, zCalc, zCalc.visibleMin, zCalc.visibleMax);
            // console.log(
            //     `visibleRange: x=${toStringRange(visibleRangeX)} y=${toStringRange(visibleRangeY)} z=${toStringRange(
            //         visibleRangeZ
            //     )}`
            // );
            // console.log(
            //     `Viewport dimensions: ${xCalc.viewportDimension}, ${yCalc.viewportDimension}, ${zCalc.viewportDimension}`
            // );
            this.nativeEntity.SetVisibleRange(visibleRangeX, visibleRangeY, visibleRangeZ);
        }
        finally {
            Deleter_1.deleteSafe(meshRangeX);
            Deleter_1.deleteSafe(meshRangeY);
            Deleter_1.deleteSafe(meshRangeZ);
            Deleter_1.deleteSafe(visibleRangeX);
            Deleter_1.deleteSafe(visibleRangeY);
            Deleter_1.deleteSafe(visibleRangeZ);
        }
        const yOffset = this.parentSeries.yOffset ? yCalc.getCoordinate(this.parentSeries.yOffset) : 0;
        // console.log(`heightScaleFactor, yOffset ${this.parentSeries.heightScaleFactor} ${yOffset}`);
        this.nativeEntity.SetHeightmapScaleOffset(this.parentSeries.heightScaleFactor, yOffset);
        // console.log(`ColormapTexture ${this.colorMapTexture}`);
        this.nativeEntity.SetTexture(this.colorMapTexture.getTexture());
        super.Render();
    }
    /**
     * @inheritDoc
     */
    updateSeries() {
        var _a;
        const gridDataSeries = this.parentSeries.dataSeries;
        if (gridDataSeries) {
            Guard_1.Guard.isTrue(gridDataSeries.type === BaseDataSeries3D_1.EDataSeriesType3D.UniformGrid3D ||
                gridDataSeries.type === BaseDataSeries3D_1.EDataSeriesType3D.NonUniformGrid3D, "SurfaceMeshSceneEntity dataSeries must be type UniformGrid3D or NonUniformGrid3D");
            const gridWidth = gridDataSeries.xSize;
            const gridHeight = gridDataSeries.zSize;
            Guard_1.Guard.notNull(this.currentRenderPassData, "SurfaceMeshSceneEntity.currentRenderPassData");
            if (this.state.setColorMapTextureInvalid) {
                this.colorMapTexture = Deleter_1.deleteSafe(this.colorMapTexture);
                this.colorMapTexture = (_a = this.parentSeries.meshColorPalette) === null || _a === void 0 ? void 0 : _a.getTexture(this.parentSeries.colorMapTextureSize);
            }
            const needUpdateMesh = this.state.isInitialState;
            const needUpdateHeights = this.state.isDataSeriesModified;
            if (needUpdateMesh) {
                let scrtMeshRes;
                switch (this.parentSeries.meshResolution) {
                    case SurfaceMeshRenderableSeries3D_1.EMeshResolution.MESH_RESOLUTION_X1:
                        scrtMeshRes = this.webAssemblyContext.eSCRTGridMeshResolution.SCRT_GRID_MESH_RES_X1;
                        break;
                    case SurfaceMeshRenderableSeries3D_1.EMeshResolution.MESH_RESOLUTION_X2:
                        scrtMeshRes = this.webAssemblyContext.eSCRTGridMeshResolution.SCRT_GRID_MESH_RES_X2;
                        break;
                    case SurfaceMeshRenderableSeries3D_1.EMeshResolution.MESH_RESOLUTION_X4:
                        scrtMeshRes = this.webAssemblyContext.eSCRTGridMeshResolution.SCRT_GRID_MESH_RES_X4;
                        break;
                    default:
                        throw Error("Unknown SurfaceMeshSceneEntity.meshResolution " + this.parentSeries.meshResolution);
                }
                const heightCoords = new this.webAssemblyContext.FloatVector();
                const zOffsets = new this.webAssemblyContext.FloatVector();
                const cellColors = new this.webAssemblyContext.UIntVector();
                heightCoords.resize(gridWidth * gridHeight, 0);
                zOffsets.resize(gridWidth * gridHeight, 0);
                cellColors.resize(gridWidth * gridHeight, 0);
                // console.log(`UpdateMeshesVec ${gridWidth} ${gridHeight}`);
                this.nativeEntity.UpdateMeshesVec(heightCoords, zOffsets, cellColors, gridWidth, gridHeight, scrtMeshRes);
                Deleter_1.deleteSafe(heightCoords);
                Deleter_1.deleteSafe(zOffsets);
                Deleter_1.deleteSafe(cellColors);
            }
            if (needUpdateHeights) {
                // console.log(`UpdateHeightCoordinatesVec ${gridWidth} ${gridHeight}`);
                const heightCoords = new this.webAssemblyContext.FloatVector();
                const size = gridWidth * gridHeight;
                heightCoords.reserve(size);
                const yCalc = this.currentRenderPassData.yCalc;
                // console.log(`yCalc: ${yCalc.visibleMin}, ${yCalc.visibleMax}, ${yCalc.viewportDimension}`);
                for (let z = 0; z < gridDataSeries.zSize; z++) {
                    for (let x = 0; x < gridDataSeries.xSize; x++) {
                        heightCoords.push_back(yCalc.getCoordinate(gridDataSeries.getYValue(z, x)));
                    }
                }
                this.nativeEntity.UpdateHeightCoordinatesVec(heightCoords, gridWidth, gridHeight);
                Deleter_1.deleteSafe(heightCoords);
            }
        }
    }
    hasFlag(theFlag, matchList) {
        return matchList.some(item => item === theFlag);
    }
    toSCRTAxisRange(webAssemblyContext, calc, min, max) {
        const scrtAxisRange = new webAssemblyContext.SCRTAxisRange();
        scrtAxisRange.m_fMin = calc ? calc.getCoordinate(min) : min;
        scrtAxisRange.m_fMax = calc ? calc.getCoordinate(max) : max;
        scrtAxisRange.m_fDiff = calc ? calc.getCoordinate(max - min) : max - min;
        return scrtAxisRange;
    }
    rangeToSCRTAxisRange(webAssemblyContext, calc, tsRange) {
        return this.toSCRTAxisRange(webAssemblyContext, calc, tsRange.min, tsRange.max);
    }
}
exports.SurfaceMeshSceneEntity = SurfaceMeshSceneEntity;
