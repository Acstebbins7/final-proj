"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScatterPointsSceneEntity = void 0;
const Deleter_1 = require("../../../Core/Deleter");
const SceneEntityType_1 = require("../../../types/SceneEntityType");
const parseColor_1 = require("../../../utils/parseColor");
const BaseDataSeries3D_1 = require("../../Model/DataSeries/BaseDataSeries3D");
const BasePointMarker3D_1 = require("../PointMarkers/BasePointMarker3D");
const RenderableSeriesSceneEntity_1 = require("./RenderableSeriesSceneEntity");
const RenderableSeriesSceneEntityState_1 = require("./RenderableSeriesSceneEntityState");
/**
 * @summary {@link BaseSceneEntity3D} type for drawing 3D Scatter or Bubble series in SciChart's High Performance
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript 3D Charts}
 * @remarks See related type {@link ScatterRenderableSeries3D} which should be added to {@link SciChart3DSurface.renderableSeries}
 * along with data from an {@link XyzDataSeries3D} to create a 3D Scatter or Bubble chart
 */
class ScatterPointsSceneEntity extends RenderableSeriesSceneEntity_1.RenderableSeriesSceneEntity {
    /**
     * Creates an instance of {@link ScatterPointsSceneEntity}
     * @param webAssemblyContext The {@link TSciChart3D | SciChart 3D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param parentSeries The parent {@link BaseRenderableSeries3D} which this entity maps to
     */
    constructor(webAssemblyContext, parentSeries) {
        super(webAssemblyContext, parentSeries, new RenderableSeriesSceneEntityState_1.RenderableSeriesSceneEntityState());
        /**
         * @inheritDoc
         */
        this.type = SceneEntityType_1.ESceneEntityType.ScatterPointsSceneEntity;
        this.setNativeEntity(webAssemblyContext.SCRTPoint3DSceneEntity.implement(this));
    }
    /**
     * @inheritDoc
     */
    delete() {
        this.pointColors = Deleter_1.deleteSafe(this.pointColors);
        this.pointScales = Deleter_1.deleteSafe(this.pointScales);
        super.delete();
    }
    /**
     * @inheritDoc
     */
    updateSeries() {
        const dataSeries = this.parentSeries.dataSeries;
        if (!dataSeries) {
            return;
        }
        if (dataSeries.type !== BaseDataSeries3D_1.EDataSeriesType3D.Xyz3D) {
            throw new Error("DataSeries type for a ScatterRenderableSeries3D must be XyzDataSeries3D");
        }
        const pointMarker = this.parentSeries.pointMarker;
        if (!pointMarker) {
            throw new Error("To render 3D Scatter, bubble or point-clouds, you must provider a PointMarker on BaseRenderableSeries3D");
        }
        const eSCRTPointMarkerType = this.webAssemblyContext.eSCRT_POINT_MARKER_TYPE;
        const defaultColor = parseColor_1.parseColorToUIntArgb(pointMarker.fill);
        switch (pointMarker.markerType) {
            case BasePointMarker3D_1.EMarkerType.Pixel:
                this.nativeEntity.SetPointMarkerType(eSCRTPointMarkerType.SCRT_POINT_MARKER_TYPE_PIXEL);
                this.nativeEntity.SetPointSize(0);
                this.nativeEntity.SetPointColor(defaultColor);
                break;
            case BasePointMarker3D_1.EMarkerType.TexturedQuad:
                const textureMarker = pointMarker;
                if (!textureMarker.pointsTexture) {
                    throw new Error("Expected a BaseTexturePointMarker3D.pointsTexture on 3D pointmarker of type TexturedQuad");
                }
                this.nativeEntity.SetPointMarkerType(eSCRTPointMarkerType.SCRT_POINT_MARKER_TYPE_TEXTURED_QUAD);
                this.nativeEntity.SetPointSize(pointMarker.size);
                this.nativeEntity.SetPointColor(defaultColor);
                this.nativeEntity.SetPointMarkerTexture(textureMarker.pointsTexture);
                break;
            case BasePointMarker3D_1.EMarkerType.InstancedMesh:
                const meshMarker = pointMarker;
                if (!meshMarker.pointsMesh) {
                    throw new Error("Expected a BaseMeshPointMarker3D.pointsMesh on 3D pointmarker of type InstancedMesh");
                }
                this.nativeEntity.SetPointMarkerType(eSCRTPointMarkerType.SCRT_POINT_MARKER_TYPE_INSTANCED_MESH);
                this.nativeEntity.SetPointSize(pointMarker.size);
                this.nativeEntity.SetPointColor(defaultColor);
                this.nativeEntity.SetPointMarkerMesh(meshMarker.pointsMesh);
                break;
            default:
                throw new Error("Unknown pointMarker.markerType " + pointMarker.markerType);
        }
        const xValues = dataSeries.getNativeXValues();
        const yValues = dataSeries.getNativeYValues();
        const zValues = dataSeries.getNativeZValues();
        const meta = dataSeries.getMetadataValues();
        const count = dataSeries.count();
        const { colors, scales } = this.rebuildPointMetadata(meta, count, defaultColor);
        let args;
        try {
            args = new this.webAssemblyContext.SCRTPoint3DSceneEntityParams();
            args.useDefaultColors = false;
            args.useDefaultScale = false;
            args.SetCoordinateCalculators(this.currentRenderPassData.xCalc.nativeCalculator, this.currentRenderPassData.yCalc.nativeCalculator, this.currentRenderPassData.zCalc.nativeCalculator);
            this.nativeEntity.UpdateMeshesVec(xValues, yValues, zValues, colors, scales, args);
        }
        finally {
            Deleter_1.deleteSafe(args);
        }
    }
    rebuildPointMetadata(metadata, count, defaultColor) {
        if (!this.pointColors) {
            this.pointColors = new this.webAssemblyContext.UIntVector();
        }
        if (!this.pointScales) {
            this.pointScales = new this.webAssemblyContext.FloatVector();
        }
        // Default color, size
        this.pointColors.resize(count, defaultColor);
        this.pointScales.resize(count, 1.0);
        // metadata will always be non-null but individual metadata items may be undefined
        // as its implemented as a non-sparse array
        metadata.forEach((meta, index) => {
            if (meta) {
                this.pointColors.set(index, meta.vertexColorAbgr);
                this.pointScales.set(index, meta.pointScale);
            }
        });
        return { colors: this.pointColors, scales: this.pointScales };
    }
}
exports.ScatterPointsSceneEntity = ScatterPointsSceneEntity;
