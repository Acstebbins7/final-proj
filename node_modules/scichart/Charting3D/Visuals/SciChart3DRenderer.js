"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SciChart3DRenderer = void 0;
const Deleter_1 = require("../../Core/Deleter");
const Guard_1 = require("../../Core/Guard");
const AutoRange_1 = require("../../types/AutoRange");
const AxisCubeDescriptor_1 = require("./Primitives/AxisCubeDescriptor");
const RenderPassInfo3D_1 = require("./Primitives/RenderPassInfo3D");
const SceneDescriptor_1 = require("./Primitives/SceneDescriptor");
/**
 * A class used internally in SciChart to perform layout, arrangement, data-preparation and rendering on the Cartesian 3D {@link SciChart3DSurface}
 */
class SciChart3DRenderer {
    constructor(scs, wasmContext) {
        Guard_1.Guard.notNull(scs, "scs");
        this.scs = scs;
        this.wasmContext = wasmContext;
    }
    /**
     * get the {@link SceneDescriptor} to define the look & styling of the scene in the current render pass
     * @param scs the {@link SciChart3DSurface} we are drawing
     */
    static getSceneDescriptor(scs) {
        var _a, _b, _c;
        // Collect info from axis and scene how to draw / what to draw
        const scene = new SceneDescriptor_1.SceneDescriptor();
        scene.axisCubeDescriptor = new AxisCubeDescriptor_1.AxisCubeDescriptor();
        scene.axisCubeDescriptor.dimensions = scs.worldDimensions;
        scene.axisCubeDescriptor.isVisible = true;
        scene.axisCubeDescriptor.xAxisDescriptor = (_a = scs.xAxis) === null || _a === void 0 ? void 0 : _a.toAxisDescriptor();
        scene.axisCubeDescriptor.yAxisDescriptor = (_b = scs.yAxis) === null || _b === void 0 ? void 0 : _b.toAxisDescriptor();
        scene.axisCubeDescriptor.zAxisDescriptor = (_c = scs.zAxis) === null || _c === void 0 ? void 0 : _c.toAxisDescriptor();
        return scene;
    }
    /**
     * Prepares render data and returns a {@link RenderPassInfo3D} for the current render pass
     * @param scs the {@link SciChart3DSurface} we are drawing
     */
    static prepareRenderData(scs) {
        const rpd = new RenderPassInfo3D_1.RenderPassInfo3D();
        rpd.xCalc = scs.xAxis.getCurrentCoordinateCalculator();
        rpd.yCalc = scs.yAxis.getCurrentCoordinateCalculator();
        rpd.zCalc = scs.zAxis.getCurrentCoordinateCalculator();
        rpd.worldDimensions = scs.worldDimensions;
        rpd.sceneDescriptor = SciChart3DRenderer.getSceneDescriptor(scs);
        return rpd;
    }
    /**
     * Performs autorange on the {@link AxisBase3D} depending on flags such as {@link AxisBase3D.autoRange}
     * @param axis The {@link AxisBase3D} we are auto-ranging
     * @param scs the {@link SciChart3DSurface} we are drawing
     */
    static tryPerformAutoRangeOn(axis, scs) {
        const shouldAutoRange = ((!axis.hasValidVisibleRange || axis.hasDefaultVisibleRange) && axis.autoRange === AutoRange_1.EAutoRange.Once) ||
            axis.autoRange === AutoRange_1.EAutoRange.Always;
        if (shouldAutoRange) {
            const newRange = scs.viewportManager.calculateAutoRange(axis);
            if (newRange && !(newRange === axis.visibleRange) && axis.isValidRange(newRange)) {
                axis.visibleRange = newRange;
            }
        }
    }
    /**
     * The main render loop
     */
    render() {
        // Step 1: Sanity checks
        if (!this.isSurfaceValid(this.scs)) {
            throw Error("SciChart3DSurface is not valid");
        }
        // Step 2: Prepare the Axes
        this.prepareAxes(this.scs.xAxis, this.scs.yAxis, this.scs.zAxis);
        // Step 3: Prepare the RenderPassData
        const rpd = SciChart3DRenderer.prepareRenderData(this.scs);
        // Step 4: Prepare the Axis Cube
        // Viewport3D already checked to be not null in IsSurfaceValid
        this.scs.rootEntity.visitEntities(e => e.setRenderPassData(rpd));
        // Step 5: Update the camera and world
        const sceneWorld = this.wasmContext.SCRTGetWorld3D();
        this.updateWorldDimensions(sceneWorld, this.scs.worldDimensions);
        const tsrCamera = sceneWorld.GetMainCamera();
        const typescriptCamera = this.scs.camera;
        typescriptCamera.updateEngineCamera(tsrCamera);
        // We add the same padding as we have for 2D 6px
        this.scs.updateWatermark(6, 6);
        // Step 6: Notify that scene is about to be drawn
        this.scs.onSciChartRendered();
    }
    isSurfaceValid(sciChartSurface, viewportSize) {
        if (!sciChartSurface.xAxis) {
            throw new Error("Unable to draw SciChart3DSurface as the xAxis is undefined");
        }
        if (!sciChartSurface.yAxis) {
            throw new Error("Unable to draw SciChart3DSurface as the yAxis is undefined");
        }
        if (!sciChartSurface.zAxis) {
            throw new Error("Unable to draw SciChart3DSurface as the zAxis is undefined");
        }
        return true;
    }
    prepareAxes(...axis) {
        axis.forEach(el => {
            el.validateAxis();
            SciChart3DRenderer.tryPerformAutoRangeOn(el, this.scs);
        });
    }
    updateWorldDimensions(sceneWorld, worldDimensions) {
        Guard_1.Guard.notNull(worldDimensions, "worldDimensions");
        let worldDimensionsVector4;
        try {
            worldDimensionsVector4 = this.scs.worldDimensions.toTsrVector3(this.wasmContext);
            sceneWorld.SetWorldDimensions(worldDimensionsVector4);
        }
        finally {
            Deleter_1.deleteSafe(worldDimensionsVector4);
        }
    }
}
exports.SciChart3DRenderer = SciChart3DRenderer;
/** @ignore */
const toString = (vector) => {
    return `TSRVector3 (${vector.x.toFixed(2)}, ${vector.y.toFixed(2)}, ${vector.z.toFixed(2)})`;
};
