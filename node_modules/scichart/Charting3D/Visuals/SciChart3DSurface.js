"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SciChart3DSurface = void 0;
// @ts-ignore
const WasmModule3D = require("../../_wasm/scichart3d");
const sciChartInitCommon_1 = require("../../Charting/Visuals/sciChartInitCommon");
const SciChartSurfaceBase_1 = require("../../Charting/Visuals/SciChartSurfaceBase");
const app_1 = require("../../constants/app");
const ObservableArray_1 = require("../../Core/ObservableArray");
const loader_1 = require("../../Charting/Visuals/loader");
const logger_1 = require("../../utils/logger");
const parseColor_1 = require("../../utils/parseColor");
const CameraController_1 = require("../CameraController");
const Vector3_1 = require("../Vector3");
const AxisCubeEntity_1 = require("./Axis/AxisCubeEntity");
const Constants_1 = require("./Constants");
const DefaultViewportManager3D_1 = require("./DefaultViewportManager3D");
const GizmoEntity_1 = require("./GizmoEntity");
const licenseManager3D_1 = require("./licenseManager3D");
const RootSceneEntity_1 = require("./RootSceneEntity");
const SciChart3DRenderer_1 = require("./SciChart3DRenderer");
const sciChartConfig3D = {};
const locateFile = SciChartSurfaceBase_1.getLocateFile(sciChartConfig3D);
/** @ignore */
const MASTER_CANVAS_ID = "SciChart3DMasterCanvas";
/** @ignore */
const sciChartMaster3D = {
    wasmContext: undefined,
    getChildSurfaces: undefined,
    createChildSurface: undefined
};
/** @ignore */
let sciChartMaster3DPromise;
/**
 * @summary The {@link SciChart3DSurface} is the root 3D Chart control in SciChart's High Performance Real-time
 * {@link https://www.scichart.com/javascript-chart-features | JavaScript 3D Chart Library}
 * @description
 * To create a 3D chart using SciChart, declare a {@link SciChart3DSurface} using {@link SciChart3DSurface.create},
 * add X,Y,Z axis via the {@link SciChart3DSurface.xAxis} {@link SciChart3DSurface.yAxis} and {@link SciChart3DSurface.zAxis} properties.
 *
 * Next, add a series or chart type by adding a {@link BaseRenderableSeries3D} to the {@link SciChart3DSurface.renderableSeries} collection.
 *
 * Position the camera in the 3D scene by adjusting the {@link SciChart3DSurface.camera} property.
 *
 * To redraw a {@link SciChart3DSurface} at any time, call {@link SciChart3DSurface.invalidateElement}, however all properties are reactive and the
 * chart will automatically redraw if data or properties change.
 * @remarks
 * {@link SciChart3DSurface | SciChartSurfaces} scale to fit the parent DIV where they are hosted. Use CSS to position the DIV.
 */
class SciChart3DSurface extends SciChartSurfaceBase_1.SciChartSurfaceBase {
    /**
     * Creates an instance of {@link SciChart3DSurface}
     * @param webAssemblyContext The {@link TSciChart3D | SciChart 3D WebAssembly Context} containing native methods and
     * access to our WebGL2 Engine and WebAssembly numerical methods
     * @param options Optional parameters of type {@link ISciChart3DSurfaceOptions} to configure the chart
     */
    constructor(webAssemblyContext, options) {
        super(webAssemblyContext, options === null || options === void 0 ? void 0 : options.canvases, MASTER_CANVAS_ID);
        this.isAxisCubeRenderedProperty = false;
        this.webAssemblyContext3D = webAssemblyContext;
        if (!app_1.IS_TEST_ENV) {
            if (this.isCopyCanvasSurface) {
                this.changeMasterCanvasViewportSize(this.domCanvas2D.width, this.domCanvas2D.height);
                this.webAssemblyContext3D.TSRSetMainWindowSize(this.domMasterCanvas.width, this.domMasterCanvas.height);
            }
            else {
                this.webAssemblyContext3D.TSRSetMainWindowSize(this.domCanvas2D.width, this.domCanvas2D.height);
            }
        }
        this.invalidateElement = this.invalidateElement.bind(this);
        this.sciChart3DRenderer = new SciChart3DRenderer_1.SciChart3DRenderer(this, webAssemblyContext);
        // Set default viewportManager
        this.viewportManager = new DefaultViewportManager3D_1.DefaultViewportManager3D();
        // Set default WorldDimensions
        this.worldDimensionsProperty = (options === null || options === void 0 ? void 0 : options.worldDimensions) || new Vector3_1.Vector3(300, 200, 300);
        // Setup series
        this.detachSeries = this.detachSeries.bind(this);
        this.attachSeries = this.attachSeries.bind(this);
        this.renderableSeries = new ObservableArray_1.ObservableArray();
        this.renderableSeries.collectionChanged.subscribe(args => {
            var _a, _b;
            (_a = args.getOldItems()) === null || _a === void 0 ? void 0 : _a.forEach(rs => this.detachSeries(rs));
            (_b = args.getNewItems()) === null || _b === void 0 ? void 0 : _b.forEach(rs => this.attachSeries(rs));
        });
        // Set default camera
        this.childPropertyChanged = this.childPropertyChanged.bind(this);
        this.camera = (options === null || options === void 0 ? void 0 : options.camera) || new CameraController_1.CameraController(this.webAssemblyContext3D);
        this.rootEntity = new RootSceneEntity_1.RootSceneEntity(webAssemblyContext);
        this.axisCubeEntity = new AxisCubeEntity_1.AxisCubeEntity(webAssemblyContext, this);
        this.rootEntity.children.add(this.axisCubeEntity);
        this.gizmoEntity = new GizmoEntity_1.GizmoEntity(webAssemblyContext);
        this.gizmoEntity.enableGizmo = true;
        this.rootEntity.children.add(this.gizmoEntity);
        // Watermark
        if (!app_1.IS_TEST_ENV) {
            this.watermarkProperties = new webAssemblyContext.SCRTWaterMarkProperties();
            this.watermarkPropertyPosition = new webAssemblyContext.TSRVector2(6, 6);
            this.watermarkProperties.SetPosition(this.watermarkPropertyPosition);
            this.watermarkProperties.SetOpacity(0.5);
            webAssemblyContext.SCRT3DSetWaterMarkProperties(this.watermarkProperties);
        }
        this.applySciChartBackground("#1c1c1e");
    }
    /**
     * USED INTERNALLY - performs a similar operation to {@link SciChart3DSurface.create} but used internally for testing
     * @param divElementId
     * @param widthAspect
     * @param heightAspect
     */
    static createSingle(divElementId, widthAspect = 0, heightAspect = 0) {
        return new Promise(resolve => {
            const canvases = sciChartInitCommon_1.default.initCanvas(divElementId, widthAspect, heightAspect);
            loader_1.default.addLoaderStyles();
            const loaderDiv = loader_1.default.addChartLoader(canvases.domDivContainer);
            const webGLSupport = sciChartInitCommon_1.default.checkWebGLSupport();
            console.log("webGLSupport", webGLSupport);
            if (webGLSupport === sciChartInitCommon_1.default.EWebGLSupport.WebGL2 ||
                webGLSupport === sciChartInitCommon_1.default.EWebGLSupport.WebGL1) {
                // @ts-ignore
                new WasmModule3D({ locateFile }).then((wasmContext) => {
                    loader_1.default.removeChartLoader(canvases.domDivContainer, loaderDiv);
                    // @ts-ignore
                    wasmContext.doNotCaptureKeyboard = true;
                    initDrawEngineSingleChart(wasmContext, canvases, resolve);
                });
            }
            else {
                throw Error("Sorry Your browser does not support WebGL.");
            }
        });
    }
    static configure(config) {
        var _a, _b;
        sciChartConfig3D.dataUrl = (_a = config === null || config === void 0 ? void 0 : config.dataUrl) !== null && _a !== void 0 ? _a : undefined;
        sciChartConfig3D.wasmUrl = (_b = config === null || config === void 0 ? void 0 : config.wasmUrl) !== null && _b !== void 0 ? _b : undefined;
    }
    /**
     * Creates a {@link SciChart3DSurface} and {@link TSciChart3D | WebAssembly Context} to occupy the div by element ID in your DOM.
     * @remarks This method is async and must be awaited
     * @param divElementId The Div Element ID where the {@link SciChart3DSurface} will reside
     * @param widthAspect Optional - the width aspect ratio of the {@link SciChart3DSurface}. By default SciChart will scale to fit the parent Div
     * However if height of the div is not provided it will use width/height aspect ratio to calculate the height. The default ratio is 3/2.
     * @param heightAspect Optional - the height aspect ratio of the {@link SciChart3DSurface}. By default SciChart will scale to fit the parent Div
     */
    static create(divElementId, widthAspect = 0, heightAspect = 0) {
        return createMultichart(divElementId, widthAspect, heightAspect);
    }
    /**
     * @inheritdoc
     */
    delete() {
        this.rootEntity.delete();
        this.renderableSeries.asArray().forEach(el => el.delete());
        this.renderableSeries.clear();
    }
    /**
     * Gets or sets whether the Xyz gizmo is enabled - a small 3D Xyz axis on the bottom left of the 3D Chart
     */
    get enableGizmo() {
        return this.gizmoEntity.enableGizmo;
    }
    /**
     * Gets or sets whether the Xyz gizmo is enabled - a small 3D Xyz axis on the bottom left of the 3D Chart
     */
    set enableGizmo(isEnabled) {
        this.gizmoEntity.enableGizmo = isEnabled;
    }
    /**
     * Gets or sets the {@link ViewportManager3DBase | Viewport Manager} - a class that allows managing of viewport axis ranges
     */
    get viewportManager() {
        return this.viewportManagerProperty;
    }
    /**
     * Gets or sets the {@link ViewportManager3DBase | Viewport Manager} - a class that allows managing of viewport axis ranges
     */
    set viewportManager(viewportManager) {
        var _a, _b;
        (_a = this.viewportManagerProperty) === null || _a === void 0 ? void 0 : _a.detachSciChartSurface();
        this.viewportManagerProperty = viewportManager;
        (_b = this.viewportManagerProperty) === null || _b === void 0 ? void 0 : _b.attachSciChartSurface(this);
        this.notifyPropertyChanged(Constants_1.PROPERTY.SURFACE_VIEWPORT_MANAGER);
    }
    /**
     * The WorldDimensions defines the size of the world in 3D space. Series and objects can exist outside of this world
     * however the Axis cube will conform to this size.
     * @remarks See our {@link https://www.scichart.com/javascript-chart-documentation | Documentation} online to see
     * how the World Dimensions property configures the size of the chart.
     */
    get worldDimensions() {
        return this.worldDimensionsProperty;
    }
    /**
     * The WorldDimensions defines the size of the world in 3D space. Series and objects can exist outside of this world
     * however the Axis cube will conform to this size.
     * @remarks See our {@link https://www.scichart.com/javascript-chart-documentation | Documentation} online to see
     * how the World Dimensions property configures the size of the chart.
     */
    set worldDimensions(worldDimensions) {
        this.worldDimensionsProperty = worldDimensions;
        this.notifyPropertyChanged(Constants_1.PROPERTY.SURFACE_WORLD_DIMENSIONS);
    }
    /**
     * The {@link ICameraController} is a 3D Camera which allows choosing perspective, orthogonal projections,
     * camera position, target, orientation such as Pitch, Yaw and Roll etc...
     * @remarks See {@link CameraController} for a concrete implementation of {@link ICameraController}
     */
    get camera() {
        return this.cameraProperty;
    }
    /**
     * The {@link ICameraController} is a 3D Camera which allows choosing perspective, orthogonal projections,
     * camera position, target, orientation such as Pitch, Yaw and Roll etc...
     * @remarks See {@link CameraController} for a concrete implementation of {@link ICameraController}
     */
    set camera(value) {
        var _a, _b;
        (_a = this.cameraProperty) === null || _a === void 0 ? void 0 : _a.propertyChanged.unsubscribe(this.childPropertyChanged);
        this.cameraProperty = value;
        (_b = this.cameraProperty) === null || _b === void 0 ? void 0 : _b.propertyChanged.subscribe(this.childPropertyChanged);
        this.notifyPropertyChanged(Constants_1.PROPERTY.SURFACE_CAMERA);
    }
    /**
     * Gets or sets the XAxis in the 3D Chart.
     * @remarks Axis types which derive from {@link AxisBase3D} or concrete type {@link NumericAxis3D} are valid
     */
    get xAxis() {
        return this.xAxisProperty;
    }
    /**
     * Gets or sets the XAxis in the 3D Chart.
     * @remarks Axis types which derive from {@link AxisBase3D} or concrete type {@link NumericAxis3D} are valid
     */
    set xAxis(xAxis) {
        this.detachAxis(this.xAxisProperty);
        this.xAxisProperty = xAxis;
        this.attachAxis(this.xAxisProperty);
        this.notifyPropertyChanged(Constants_1.PROPERTY.SURFACE_XAXIS);
    }
    /**
     * Gets or sets the YAxis in the 3D Chart.
     * @remarks Axis types which derive from {@link AxisBase3D} or concrete type {@link NumericAxis3D} are valid
     */
    get yAxis() {
        return this.yAxisProperty;
    }
    /**
     * Gets or sets the YAxis in the 3D Chart.
     * @remarks Axis types which derive from {@link AxisBase3D} or concrete type {@link NumericAxis3D} are valid
     */
    set yAxis(yAxis) {
        this.detachAxis(this.yAxisProperty);
        this.yAxisProperty = yAxis;
        this.attachAxis(this.yAxisProperty);
        this.notifyPropertyChanged(Constants_1.PROPERTY.SURFACE_YAXIS);
    }
    /**
     * Gets or sets the ZAxis in the 3D Chart.
     * @remarks Axis types which derive from {@link AxisBase3D} or concrete type {@link NumericAxis3D} are valid
     */
    get zAxis() {
        return this.zAxisProperty;
    }
    /**
     * Gets or sets the ZAxis in the 3D Chart.
     * @remarks Axis types which derive from {@link AxisBase3D} or concrete type {@link NumericAxis3D} are valid
     */
    set zAxis(zAxis) {
        this.detachAxis(this.zAxisProperty);
        this.zAxisProperty = zAxis;
        this.attachAxis(this.zAxisProperty);
        this.notifyPropertyChanged(Constants_1.PROPERTY.SURFACE_ZAXIS);
    }
    /**
     * Called internally
     * Sets isAxisCubeRenderedProperty flag after Axis Cube is rendered
     */
    setIsAxisCubeRendered() {
        this.isAxisCubeRenderedProperty = true;
    }
    /**
     * Called internally
     * Gets isAxisCubeRenderedProperty flag
     */
    get isAxisCubeRendered() {
        return this.isAxisCubeRenderedProperty;
    }
    /**
     * @inheritDoc
     */
    invalidateElement() {
        // When isSuspended (see suspendUpdates() function) ignore drawing
        if (this.isSuspended) {
            logger_1.Logger.log("SciChart3DSurface.isSuspended = true. Ignoring invalidateElement() call");
            return;
        }
        const canvasId = this.domCanvas2D ? this.domCanvas2D.id : "undefinedCanvasId";
        this.webAssemblyContext3D.TSRRequestCanvasDraw(canvasId);
    }
    /**
     * @inheritDoc
     */
    get surfaceType() {
        return SciChartSurfaceBase_1.ESurfaceType.SciChart3DSurfaceType;
    }
    /**
     * Called after the {@link SciChart3DSurface} has rendered.
     */
    onSciChartRendered() {
        // TODO - event after rendered
    }
    /**
     * Called internally - the main drawing loop
     */
    doDrawingLoop() {
        this.sciChart3DRenderer.render();
    }
    /**
     * @inheritDoc
     */
    applyTheme(themeProvider) {
        var _a, _b, _c;
        super.applyTheme(themeProvider);
        this.renderableSeries.asArray().forEach(rs => rs.applyTheme(themeProvider));
        (_a = this.xAxis) === null || _a === void 0 ? void 0 : _a.applyTheme(themeProvider);
        (_b = this.yAxis) === null || _b === void 0 ? void 0 : _b.applyTheme(themeProvider);
        (_c = this.zAxis) === null || _c === void 0 ? void 0 : _c.applyTheme(themeProvider);
    }
    /**
     * @inheritDoc
     */
    changeViewportSize(width, height) {
        this.changeDomViewportSize(width, height);
        if (!this.isCopyCanvasSurface) {
            this.webAssemblyContext3D.TSRSetMainWindowSize(width, height);
        }
        this.invalidateElement();
    }
    /**
     * @inheritDoc
     */
    updateWatermark(left, bottom) {
        if (!app_1.IS_TEST_ENV) {
            this.watermarkPropertyPosition.x = left;
            this.watermarkPropertyPosition.y = bottom;
            this.watermarkProperties.SetPosition(this.watermarkPropertyPosition);
            this.webAssemblyContext3D.SCRT3DSetWaterMarkProperties(this.watermarkProperties);
        }
    }
    /**
     * @inheritDoc
     */
    attachChartModifier(chartModifier) {
        super.attachChartModifier(chartModifier);
        chartModifier.setParentSurface(this);
        chartModifier.invalidateParentCallback = this.invalidateElement;
        chartModifier.onAttach();
        this.invalidateElement();
    }
    /**
     * @inheritDoc
     */
    applySciChartBackground(htmlColor, alphaEnabled = true) {
        const c = parseColor_1.parseColorToTArgb(htmlColor ? htmlColor : "rgba(28,28,30,1)");
        const f = 1 / 255;
        this.webAssemblyContext3D.SCRT3DSetClearColor(c.red * f, c.green * f, c.blue * f, c.opacity * f);
        this.setClearAlphaParams(alphaEnabled, c.opacity * f);
    }
    /**
     * @inheritDoc
     */
    setClearAlphaParams(enabled, alpha) {
        this.webAssemblyContext3D.SCRTSetClearAlphaParams(enabled, alpha);
    }
    detachSeries(renderableSeries) {
        this.rootEntity.children.remove(renderableSeries.sceneEntity);
        renderableSeries.onDetach();
        this.invalidateElement();
    }
    attachSeries(renderableSeries) {
        renderableSeries.onAttach(this);
        if (!renderableSeries.sceneEntity) {
            throw new Error("IRenderableSeries3D.sceneEntity must be set before attaching to SciChart3DSurface");
        }
        this.rootEntity.children.add(renderableSeries.sceneEntity);
        this.invalidateElement();
    }
    detachAxis(axis) {
        if (axis) {
            axis.invalidateParentCallback = undefined;
            axis.parentSurface = undefined;
        }
    }
    attachAxis(axis) {
        if (this.themeProviderProperty && axis) {
            axis.applyTheme(this.themeProviderProperty);
        }
        if (axis) {
            axis.parentSurface = this;
            axis.isXAxis = axis === this.xAxis;
            axis.isYAxis = axis === this.yAxis;
            axis.isZAxis = axis === this.zAxis;
            axis.invalidateParentCallback = this.invalidateElement;
        }
    }
    childPropertyChanged(args) {
        this.invalidateElement();
    }
}
exports.SciChart3DSurface = SciChart3DSurface;
// SINGLE CHART FUNCTIONS
/** @ignore */
const initDrawEngineSingleChart = (wasmContext, canvases, resolve) => {
    const width = canvases.domCanvas2D.width;
    const height = canvases.domCanvas2D.height;
    // @ts-ignore
    wasmContext.preRun.push(() => (ENV.SDL_EMSCRIPTEN_KEYBOARD_ELEMENT = "#chart_WebGL"));
    wasmContext.TSRSetMainWindowSize(width, height);
    let scs;
    wasmContext.canvas = canvases.domCanvasWebGL;
    const chartInitializer = {
        InitializeChart() {
            scs = new SciChart3DSurface(wasmContext, { canvases });
            sciChartInitCommon_1.default.subscribeToResize(canvases.domChartRoot, canvases.aspect, scs);
            licenseManager3D_1.applyLicense3D(wasmContext, scs, true);
            scs.setIsInitialized();
            setTimeout(() => {
                setTimeout(scs.invalidateElement, 0);
            }, 0);
            resolve({ wasmContext, sciChart3DSurface: scs });
        },
        Draw() {
            if (scs.isInitialized) {
                scs.doDrawingLoop();
            }
        },
        Update(deltaTime) {
            logger_1.Logger.log("SciChart3DSurface.ts Update()");
        },
        ShutDownChart() {
            logger_1.Logger.log("SciChart3DSurface.ts ShutDownChart");
        }
    };
    const chartInitObj = wasmContext.SCRTSampleChartInterface3D.implement(chartInitializer);
    chartInitObj.SetFPSCounterEnabled(false);
    wasmContext.SCRTSetGlobalSampleChartInterface3D(chartInitObj);
};
// MULTI-CHART FUNCTIONS
/** @ignore */
const createMultichart = (divElementId, width = 0, height = 0) => __awaiter(void 0, void 0, void 0, function* () {
    sciChartInitCommon_1.default.checkChartDivExists(divElementId);
    loader_1.default.addLoaderStyles();
    const canvases = sciChartInitCommon_1.default.initCanvas(divElementId, width, height, sciChartInitCommon_1.default.ECanvasType.canvas2D);
    if (!sciChartMaster3D.wasmContext || !sciChartMaster3D.createChildSurface || !sciChartMaster3D.getChildSurfaces) {
        if (!sciChartMaster3DPromise) {
            sciChartMaster3DPromise = createMaster3D();
        }
        const loaderDiv = loader_1.default.addChartLoader(canvases.domDivContainer);
        const master = yield sciChartMaster3DPromise;
        loader_1.default.removeChartLoader(canvases.domDivContainer, loaderDiv);
        sciChartMaster3D.wasmContext = master.wasmContext;
        sciChartMaster3D.createChildSurface = master.createChildSurface;
        sciChartMaster3D.getChildSurfaces = master.getChildSurfaces;
    }
    const { createChildSurface, wasmContext } = sciChartMaster3D;
    const sciChart3DSurface = createChildSurface(divElementId, canvases);
    return new Promise(resolve => {
        setTimeout(() => {
            sciChart3DSurface.setIsInitialized();
            resolve({ wasmContext, sciChart3DSurface });
        }, 0);
    });
});
/** @ignore */
const createMaster3D = () => {
    const sciChartDestinations = [];
    const createChildSurfaceInner = (wasmContext, divElementId, canvases) => {
        const sciChart3DSurface = new SciChart3DSurface(wasmContext, { canvases });
        sciChart3DSurface.setDestinations(sciChartDestinations);
        sciChartInitCommon_1.default.subscribeToResize(canvases.domChartRoot, canvases.aspect, sciChart3DSurface);
        return sciChart3DSurface;
    };
    const addDestination = (wasmContext, canvasElementId, sciChartSurface, width, height, chartInitObj3D) => {
        const newDestination = SciChartSurfaceBase_1.createChartDestination(canvasElementId);
        if (!newDestination) {
            sciChartSurface.delete();
            return;
        }
        const dest = wasmContext.SCRTSurfaceDestination.implement(newDestination);
        chartInitObj3D.AddDestination(dest);
        sciChartDestinations.push({ canvasElementId, sciChartSurface, width, height });
    };
    return new Promise(resolve => {
        // @ts-ignore
        new WasmModule3D({ locateFile }).then((wasmContext) => {
            const getChildSurfaces = () => sciChartDestinations.map(el => el.sciChartSurface);
            // Create of replace child surface
            const createChildSurface = (divElementId, canvases) => {
                const canvas2dId = sciChartInitCommon_1.default.getCanvas2dId(divElementId);
                const otherDestinations = sciChartDestinations.filter(el => el.canvasElementId !== canvas2dId);
                chartInitObj.ClearDestinations();
                const sameIdDestination = sciChartDestinations.filter(el => el.canvasElementId === canvas2dId);
                sameIdDestination.forEach(el => el.sciChartSurface.delete());
                while (sciChartDestinations.length > 0) {
                    sciChartDestinations.pop();
                }
                otherDestinations.forEach(el => addDestination(wasmContext, el.canvasElementId, el.sciChartSurface, el.width, el.height, chartInitObj));
                const sciChart3DSurface = createChildSurfaceInner(wasmContext, divElementId, canvases);
                addDestination(wasmContext, canvas2dId, sciChart3DSurface, canvases.domCanvas2D.width, canvases.domCanvas2D.height, chartInitObj);
                licenseManager3D_1.applyLicense3D(wasmContext, sciChart3DSurface, false);
                return sciChart3DSurface;
            };
            wasmContext.canvas = SciChartSurfaceBase_1.getMasterCanvas(MASTER_CANVAS_ID);
            const chartInitializer = {
                InitializeChart() {
                    resolve({ getChildSurfaces, createChildSurface, wasmContext });
                },
                Draw() {
                    sciChartDestinations.forEach(dest => {
                        const { canvasElementId, sciChartSurface } = dest;
                        const chart = wasmContext.SCRTGetGlobalSampleChartInterface3D();
                        // TODO
                        if (chart.GetCurrentDestination()) {
                            const currDestID = chart.GetCurrentDestination().GetID();
                            if (currDestID === canvasElementId &&
                                sciChartSurface.isInitialized &&
                                !sciChartSurface.isDeleted) {
                                sciChartSurface.doDrawingLoop();
                            }
                        }
                    });
                },
                Update(deltaTime) {
                    // console.log("Update");
                },
                ShutDownChart() {
                    // console.log("ShutDownChart");
                }
            };
            const chartInitObj = wasmContext.SCRTSampleChartInterface3D.implement(chartInitializer);
            chartInitObj.SetFPSCounterEnabled(false);
            wasmContext.SCRTSetGlobalSampleChartInterface3D(chartInitObj);
            // create an object that native side can trigger the copy to from...
            const canvasCopyObj = wasmContext.SCRTCopyToDestinationInterface.implement({
                CopyToDestination: SciChartSurfaceBase_1.copyToCanvas(MASTER_CANVAS_ID)
            });
            wasmContext.SCRTSetGlobalCopyToDestinationInterface(canvasCopyObj);
            wasmContext.TSRSetDrawRequestsEnabled(true);
        });
    });
};
