"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SurfaceMeshRenderableSeries3D = exports.EMeshResolution = exports.EMeshPaletteMode = exports.EDrawMeshAs = void 0;
const Size_1 = require("../../../../types/Size");
const SurfaceMeshSceneEntity_1 = require("../../Primitives/SurfaceMeshSceneEntity");
const BaseRenderableSeries3D_1 = require("../BaseRenderableSeries3D");
const Constants_1 = require("../Constants");
const ESeriesType_1 = require("../ESeriesType");
/**
 * Enumeration constants which define how a {@link SurfaceMeshRenderableSeries3D | Surface Mesh Plot} is drawn
 */
var EDrawMeshAs;
(function (EDrawMeshAs) {
    /**
     * Draws the SurfaceMesh as wireframe only
     */
    EDrawMeshAs["WIREFRAME"] = "WIREFRAME";
    /**
     * Draws the SurfaceMesh as a solid shape with wireframe
     */
    EDrawMeshAs["SOLID_WIREFRAME"] = "SOLID_WIREFRAME";
    /**
     * Draws the SurfaceMesh as a solid shape with wireframe and contours
     */
    EDrawMeshAs["SOLID_WIREFRAME_WITH_CONTOURS"] = "SOLID_WIREFRAME_WITH_CONTOURS";
    /**
     * Draws the SurfaceMesh as a solid shape only
     */
    EDrawMeshAs["SOLID_MESH"] = "SOLID_MESH";
    /**
     * Draws the SurfaceMesh as a solid shape with contours
     */
    EDrawMeshAs["SOLID_WITH_CONTOURS"] = "SOLID_WITH_CONTOURS";
    /**
     * Draws the SurfaceMesh as contours only
     */
    EDrawMeshAs["CONTOURS"] = "CONTOURS";
})(EDrawMeshAs = exports.EDrawMeshAs || (exports.EDrawMeshAs = {}));
/**
 * Enumeration constants which define a {@link SurfaceMeshRenderableSeries3D | Surface Mesh Plot} mesh palette mode
 */
var EMeshPaletteMode;
(function (EMeshPaletteMode) {
    /**
     * The Height Map is linear interpolated
     */
    EMeshPaletteMode["HEIGHT_MAP_INTERPOLATED"] = "HEIGHT_MAP_INTERPOLATED";
    /**
     * The Height Map has steps between cells
     */
    EMeshPaletteMode["HEIGHT_MAP_SOLID_CELLS"] = "HEIGHT_MAP_SOLID_CELLS";
    /**
     * The Height Map is ignored and applied as a texture instead
     */
    EMeshPaletteMode["TEXTURED_SOLID_CELLS"] = "TEXTURED_SOLID_CELLS";
})(EMeshPaletteMode = exports.EMeshPaletteMode || (exports.EMeshPaletteMode = {}));
/**
 * Enumeration constants which define a {@link SurfaceMeshRenderableSeries3D | Surface Mesh Plot} mesh resolution
 */
var EMeshResolution;
(function (EMeshResolution) {
    /**
     * Mesh resolution is 1:1 between data cells and mesh cells
     */
    EMeshResolution[EMeshResolution["MESH_RESOLUTION_X1"] = 1] = "MESH_RESOLUTION_X1";
    /**
     * Twice the number of mesh cells for each data-cell
     */
    EMeshResolution[EMeshResolution["MESH_RESOLUTION_X2"] = 2] = "MESH_RESOLUTION_X2";
    /**
     * 4x the number of mesh cells for each data-cell
     */
    EMeshResolution[EMeshResolution["MESH_RESOLUTION_X4"] = 4] = "MESH_RESOLUTION_X4";
})(EMeshResolution = exports.EMeshResolution || (exports.EMeshResolution = {}));
/**
 * @summary A JavaScript 3D Surface Mesh or Surface Plot chart type rendering a 2-dimensional array of data as color and height values
 * SciChart's High Performance Real-time {@link https://www.scichart.com/javascript-chart-features | JavaScript 3D Chart Library}
 * @description
 * Surface meshes are a 3D representation of 2-dimensional arrays of data, rendered as a height-map with optional colors on the chart.
 * The {@link SurfaceMeshRenderableSeries3D} assumes the cells are equal size, and spaced along the X,Z axis according to properties on the
 * {@link UniformGridDataSeries3D}.
 *
 * For a code sample how to initialize a surface mesh, see below
 *
 * ```ts
 * // Create an empty 2D array using the helper function zeroArray2D
 * const heightMapArray: number[][] = zeroArray2D([height, width]);
 * // todo: fill the zValues 2d array with values
 *
 * // Create a UniformGridDataSeries3D passing in height values
 * const dataSeries = new UniformGridDataSeries3D(wasmContext, {
 *       yValues: heightmapArray,
 *       xStep: 1,
 *       zStep: 1,
 *       dataSeriesName: "Uniform Surface Mesh"
 *   });
 *
 * // Create a color map with gradient colors
 * const colorMap = new GradientColorPalette(wasmContext, {
 *        gradientStops: [
 *            { offset: 1, color: "#8B0000" },
 *            { offset: 0.9, color: "#FF0000" },
 *            { offset: 0.7, color: "#FF0000" },
 *            { offset: 0.5, color: "#ADFF2F" },
 *            { offset: 0.3, color: "#00FFFF" },
 *            { offset: 0.1, color: "#0000FF" },
 *            { offset: 0, color: "#1D2C6B" }
 *        ]
 *    });
 *
 * // Create a SurfaceMeshRenderableSeries3D
 * const series = new SurfaceMeshRenderableSeries3D(wasmContext, {
 *        dataSeries,
 *        minimum: 0,
 *        maximum: 0.5,
 *        opacity: 0.9,
 *        cellHardnessFactor: 1.0,
 *        shininess: 0,
 *        lightingFactor: 0.8,
 *        highlight: 1.0,
 *        stroke: "rgba(24,139,34,0.5)",
 *        strokeThickness: 2.0,
 *        contourStroke: "rgba(24,139,34,0.5)",
 *        contourInterval: 2,
 *        contourOffset: 0,
 *        contourStrokeThickness: 2,
 *        drawSkirt: false,
 *        drawMeshAs: EDrawMeshAs.SOLID_WIREFRAME,
 *        meshColorPalette: colorMap,
 *        isVisible: true
 *    });
 *
 * // Add the Surface Mesh to the chart
 * sciChart3DSurface.renderableSeries.add(series);
 * ```
 */
class SurfaceMeshRenderableSeries3D extends BaseRenderableSeries3D_1.BaseRenderableSeries3D {
    /**
     * Creates an instance of a {@link SurfaceMeshRenderableSeries3D}
     * @param webAssemblyContext The {@link TSciChart3D | SciChart 3D WebAssembly Context}
     * containing native methods and access to our WebGL2 Engine and WebAssembly numerical methods
     * @param options
     */
    constructor(webAssemblyContext, options) {
        super(webAssemblyContext, options);
        this.drawMeshAsProperty = (options === null || options === void 0 ? void 0 : options.drawMeshAs) || EDrawMeshAs.SOLID_WIREFRAME;
        this.strokeThicknessProperty = (options === null || options === void 0 ? void 0 : options.strokeThickness) || 1;
        this.drawSkirtProperty = (options === null || options === void 0 ? void 0 : options.drawSkirt) !== undefined ? options === null || options === void 0 ? void 0 : options.drawSkirt : true;
        this.meshColorPaletteProperty = options === null || options === void 0 ? void 0 : options.meshColorPalette;
        this.minimumProperty = (options === null || options === void 0 ? void 0 : options.minimum) || 0;
        this.maximumProperty = (options === null || options === void 0 ? void 0 : options.maximum) || 1;
        this.meshPaletteModeProperty = (options === null || options === void 0 ? void 0 : options.meshPaletteMode) || EMeshPaletteMode.HEIGHT_MAP_INTERPOLATED;
        this.colorMapTextureSizeProperty = (options === null || options === void 0 ? void 0 : options.colorMapTextureSize) || new Size_1.Size(1024, 1);
        this.heightScaleFactorProperty = (options === null || options === void 0 ? void 0 : options.heightScaleFactor) || 1;
        this.meshResolutionProperty = (options === null || options === void 0 ? void 0 : options.meshResolution) || EMeshResolution.MESH_RESOLUTION_X1;
        this.yOffsetProperty = (options === null || options === void 0 ? void 0 : options.yOffset) || 0;
        this.cellHardnessFactorProperty = (options === null || options === void 0 ? void 0 : options.cellHardnessFactor) || 1;
        this.lightingFactorProperty = (options === null || options === void 0 ? void 0 : options.lightingFactor) || 0.8;
        this.contourStrokeThicknessProperty = (options === null || options === void 0 ? void 0 : options.contourStrokeThickness) || 2;
        this.contourIntervalProperty = (options === null || options === void 0 ? void 0 : options.contourInterval) || 20.0;
        this.contourOffsetProperty = (options === null || options === void 0 ? void 0 : options.contourOffset) || 0.1;
        this.contourStrokeProperty = (options === null || options === void 0 ? void 0 : options.contourStroke) || "#FFFFFF";
        this.highlightProperty = (options === null || options === void 0 ? void 0 : options.highlight) || 0.05;
        this.setSceneEntity(new SurfaceMeshSceneEntity_1.SurfaceMeshSceneEntity(webAssemblyContext, this));
    }
    /**
     * @inheritDoc
     */
    get type() {
        return ESeriesType_1.ESeriesType3D.SurfaceMeshRenderableSeries3D;
    }
    /**
     * Gets or sets the Colormap texture size.
     * @remarks This defaults to [1024,1] and simply sets the resolution of color mapping. Leave default in normal operation
     */
    get colorMapTextureSize() {
        return this.colorMapTextureSizeProperty;
    }
    /**
     * Gets or sets the Colormap texture size.
     * @remarks This defaults to [1024,1] and simply sets the resolution of color mapping. Leave default in normal operation
     */
    set colorMapTextureSize(colorMapTextureSize) {
        this.colorMapTextureSizeProperty = colorMapTextureSize;
        this.notifyPropertyChanged(Constants_1.PROPERTY.COLOR_MAP_TEXTURE_SIZE);
    }
    /**
     * Gets or sets the {@link EDrawMeshAs}, whether the mesh is drawn as wireframe, solid, with or without contours etc...
     * @remarks Default value is SOLID_WIREFRAME. For contours, choose SOLID_WITH_CONTOURS
     */
    get drawMeshAs() {
        return this.drawMeshAsProperty;
    }
    /**
     * Gets or sets the {@link EDrawMeshAs}, whether the mesh is drawn as wireframe, solid, with or without contours etc...
     * @remarks Default value is SOLID_WIREFRAME. For contours, choose SOLID_WITH_CONTOURS
     */
    set drawMeshAs(drawMeshAs) {
        this.drawMeshAsProperty = drawMeshAs;
        this.notifyPropertyChanged(Constants_1.PROPERTY.DRAW_MESH_AS);
    }
    /**
     * Gets or sets the stroke thickness of mesh wireframe lines on the {@link SurfaceMeshRenderableSeries3D}
     */
    get strokeThickness() {
        return this.strokeThicknessProperty;
    }
    /**
     * Gets or sets the stroke thickness of mesh wireframe lines on the {@link SurfaceMeshRenderableSeries3D}
     */
    set strokeThickness(strokeThickness) {
        this.strokeThicknessProperty = strokeThickness;
        this.notifyPropertyChanged(Constants_1.PROPERTY.STROKE_THICKNESS);
    }
    /**
     * When true, draws a skirt from the edge of the mesh to zero (solid walls on the left, right, top, bottom side)
     */
    get drawSkirt() {
        return this.drawSkirtProperty;
    }
    /**
     * When true, draws a skirt from the edge of the mesh to zero (solid walls on the left, right, top, bottom side)
     */
    set drawSkirt(drawSkirt) {
        this.drawSkirtProperty = drawSkirt;
        this.notifyPropertyChanged(Constants_1.PROPERTY.DRAW_SKIRT);
    }
    /**
     * Gets or sets the {@link MeshColorPalette}, which defines how values in the {@link SurfaceMeshRenderableSeries3D.dataSeries} map to colours
     * @remarks See concrete types {@link SolidColorBrushPalette} and {@link GradientColorPalette} plus our examples for more information.
     */
    get meshColorPalette() {
        return this.meshColorPaletteProperty;
    }
    /**
     * Gets or sets the {@link MeshColorPalette}, which defines how values in the {@link SurfaceMeshRenderableSeries3D.dataSeries} map to colours
     * @remarks See concrete types {@link SolidColorBrushPalette} and {@link GradientColorPalette} plus our examples for more information.
     */
    set meshColorPalette(meshColorPalette) {
        this.meshColorPaletteProperty = meshColorPalette;
        this.notifyPropertyChanged(Constants_1.PROPERTY.MESH_COLOR_PALETTE);
    }
    /**
     * Gets or sets the minimum value in the {@link SurfaceMeshRenderableSeries3D.dataSeries} that we want to map to colours in the
     * {@link SurfaceMeshRenderableSeries3D.meshColorPalette}
     * @remarks For example, if data contains values 0..100, and the meshColorPalette is a {@link GradientColorPalette} from red to blue, and you want
     * 0=red and blue=100 then you should set {@link SurfaceMeshRenderableSeries3D.minimum} = 0 and {@link SurfaceMeshRenderableSeries3D.maximum} = 1
     */
    get minimum() {
        return this.minimumProperty;
    }
    /**
     * Gets or sets the minimum value in the {@link SurfaceMeshRenderableSeries3D.dataSeries} that we want to map to colours in the
     * {@link SurfaceMeshRenderableSeries3D.meshColorPalette}
     * @remarks For example, if data contains values 0..100, and the meshColorPalette is a {@link GradientColorPalette} from red to blue, and you want
     * 0=red and blue=100 then you should set {@link SurfaceMeshRenderableSeries3D.minimum} = 0 and {@link SurfaceMeshRenderableSeries3D.maximum} = 1
     */
    set minimum(minimum) {
        this.minimumProperty = minimum;
        this.notifyPropertyChanged(Constants_1.PROPERTY.MINIMUM);
    }
    /**
     * Gets or sets the maximum value in the {@link SurfaceMeshRenderableSeries3D.dataSeries} that we want to map to colours in the
     * {@link SurfaceMeshRenderableSeries3D.meshColorPalette}
     * @remarks For example, if data contains values 0..100, and the meshColorPalette is a {@link GradientColorPalette} from red to blue, and you want
     * 0=red and blue=100 then you should set {@link SurfaceMeshRenderableSeries3D.minimum} = 0 and {@link SurfaceMeshRenderableSeries3D.maximum} = 1
     */
    get maximum() {
        return this.maximumProperty;
    }
    /**
     * Gets or sets the maximum value in the {@link SurfaceMeshRenderableSeries3D.dataSeries} that we want to map to colours in the
     * {@link SurfaceMeshRenderableSeries3D.meshColorPalette}
     * @remarks For example, if data contains values 0..100, and the meshColorPalette is a {@link GradientColorPalette} from red to blue, and you want
     * 0=red and blue=100 then you should set {@link SurfaceMeshRenderableSeries3D.minimum} = 0 and {@link SurfaceMeshRenderableSeries3D.maximum} = 1
     */
    set maximum(maximum) {
        this.maximumProperty = maximum;
        this.notifyPropertyChanged(Constants_1.PROPERTY.MAXIMUM);
    }
    /**
     * Gets or sets the {@link EMeshPaletteMode}, which defines how heightmaps are treated.
     * @remarks Defaults to HEIGHT_MAP_INTERPOLATED
     */
    get meshPaletteMode() {
        return this.meshPaletteModeProperty;
    }
    /**
     * Gets or sets the {@link EMeshPaletteMode}, which defines how heightmaps are treated.
     * @remarks Defaults to HEIGHT_MAP_INTERPOLATED
     */
    set meshPaletteMode(meshPaletteMode) {
        this.meshPaletteModeProperty = meshPaletteMode;
        this.notifyPropertyChanged(Constants_1.PROPERTY.MESH_PALETTE_MODE);
    }
    /**
     * Gets or sets the height scale factor for the {@link SurfaceMeshRenderableSeries3D}.
     * @remarks Default value is 1. A height scale factor of 0 makes the mesh flat, and 0.5 means all heights are multiplied by 0.5 etc...
     */
    get heightScaleFactor() {
        return this.heightScaleFactorProperty;
    }
    /**
     * Gets or sets the height scale factor for the {@link SurfaceMeshRenderableSeries3D}.
     * @remarks Default value is 1. A height scale factor of 0 makes the mesh flat, and 0.5 means all heights are multiplied by 0.5 etc...
     */
    set heightScaleFactor(heightScaleFactor) {
        this.heightScaleFactorProperty = heightScaleFactor;
        this.notifyPropertyChanged(Constants_1.PROPERTY.HEIGHT_SCALE_FACTOR);
    }
    /**
     * Gets or sets the {@link EMeshResolution}, the amount of oversampling when creating a mesh.
     * @remarks Defaults to 1x.
     */
    get meshResolution() {
        return this.meshResolutionProperty;
    }
    /**
     * Gets or sets the {@link EMeshResolution}, the amount of oversampling when creating a mesh.
     * @remarks Defaults to 1x.
     */
    set meshResolution(meshResolution) {
        this.meshResolutionProperty = meshResolution;
        this.notifyPropertyChanged(Constants_1.PROPERTY.MESH_RESOLUTION);
    }
    /**
     * Gets or sets a Y-offset or height-offset in world coordinates.
     * @remarks Defaults to 0. When setting to a value such as 10, the entire {@link SurfaceMeshRenderableSeries3D} will be offset to height=10
     */
    get yOffset() {
        return this.yOffsetProperty;
    }
    /**
     * Gets or sets a Y-offset or height-offset in world coordinates.
     * @remarks Defaults to 0. When setting to a value such as 10, the entire {@link SurfaceMeshRenderableSeries3D} will be offset to height=10
     */
    set yOffset(yOffset) {
        this.yOffsetProperty = yOffset;
        this.notifyPropertyChanged(Constants_1.PROPERTY.Y_OFFSET);
    }
    /**
     * Gets or sets the cell hardness factor, a number used to calculate lighting effects.
     * @remarks Defaults to 1
     */
    get cellHardnessFactor() {
        return this.cellHardnessFactorProperty;
    }
    /**
     * Gets or sets the cell hardness factor, a number used to calculate lighting effects.
     * @remarks Defaults to 1
     */
    set cellHardnessFactor(cellHardnessFactor) {
        this.cellHardnessFactorProperty = cellHardnessFactor;
        this.notifyPropertyChanged(Constants_1.PROPERTY.CELL_HARDNESS_FACTOR);
    }
    /**
     * Gets or sets the lighting factor, a number used to calculate lighting effects.
     * @remarks Defaults to 0.8
     */
    get lightingFactor() {
        return this.lightingFactorProperty;
    }
    /**
     * Gets or sets the lighting factor, a number used to calculate lighting effects.
     * @remarks Defaults to 0.8
     */
    set lightingFactor(lightingFactor) {
        this.lightingFactorProperty = lightingFactor;
        this.notifyPropertyChanged(Constants_1.PROPERTY.LIGHTING_FACTOR);
    }
    /**
     * Gets or sets the stroke thickness of contour lines on the {@link SurfaceMeshRenderableSeries3D}
     */
    get contourStrokeThickness() {
        return this.contourStrokeThicknessProperty;
    }
    /**
     * Gets or sets the stroke thickness of contour lines on the {@link SurfaceMeshRenderableSeries3D}
     */
    set contourStrokeThickness(contourStrokeThickness) {
        this.contourStrokeThicknessProperty = contourStrokeThickness;
        this.notifyPropertyChanged(Constants_1.PROPERTY.CONTOUR_STROKE_THICKNESS);
    }
    /**
     * Gets or sets the contour interval, a value for the spacing between contour lines.
     * @description For example, if you have data in the {@link SurfaceMeshRenderableSeries3D.dataSeries} ranging from 0-100.0, and you
     * want to display contour lines every 1/10th then set {@link SurfaceMeshRenderableSeries3D.contourInterval} = 10
     * @remarks Defaults to 20, but must be set according to your data in the {@link SurfaceMeshRenderableSeries3D.dataSeries}
     */
    get contourInterval() {
        return this.contourIntervalProperty;
    }
    /**
     * Gets or sets the contour interval, a value for the spacing between contour lines.
     * @description For example, if you have data in the {@link SurfaceMeshRenderableSeries3D.dataSeries} ranging from 0-100.0, and you
     * want to display contour lines every 1/10th then set {@link SurfaceMeshRenderableSeries3D.contourInterval} = 10
     * @remarks Defaults to 20, but must be set according to your data in the {@link SurfaceMeshRenderableSeries3D.dataSeries}
     */
    set contourInterval(contourInterval) {
        this.contourIntervalProperty = contourInterval;
        this.notifyPropertyChanged(Constants_1.PROPERTY.CONTOUR_INTERVAL);
    }
    /**
     * Gets or sets the contour offset, a value for the offsetting contour lines
     * @description For example, if you have data in the {@link SurfaceMeshRenderableSeries3D.dataSeries} ranging from 0-100.0, and you
     * want to display the first contour line at value = 5, then set {@link SurfaceMeshRenderableSeries3D.contourOffset} = 5
     * @remarks Defaults to 0.1, but must be set according to your data in the {@link SurfaceMeshRenderableSeries3D.dataSeries}
     */
    get contourOffset() {
        return this.contourOffsetProperty;
    }
    /**
     * Gets or sets the contour offset, a value for the offsetting contour lines
     * @description For example, if you have data in the {@link SurfaceMeshRenderableSeries3D.dataSeries} ranging from 0-100.0, and you
     * want to display the first contour line at value = 5, then set {@link SurfaceMeshRenderableSeries3D.contourOffset} = 5
     * @remarks Defaults to 0.1, but must be set according to your data in the {@link SurfaceMeshRenderableSeries3D.dataSeries}
     */
    set contourOffset(contourOffset) {
        this.contourOffsetProperty = contourOffset;
        this.notifyPropertyChanged(Constants_1.PROPERTY.CONTOUR_OFFSET);
    }
    /**
     * Gets or sets the contour stroke as an HTML Color Code
     */
    get contourStroke() {
        return this.contourStrokeProperty;
    }
    /**
     * Gets or sets the contour stroke as an HTML Color Code
     */
    set contourStroke(contourStroke) {
        this.contourStrokeProperty = contourStroke;
        this.notifyPropertyChanged(Constants_1.PROPERTY.CONTOUR_STROKE);
    }
    /**
     * Gets or sets the highlight factor, a number used to calculate lighting effects.
     * @remarks Defaults to 0.05
     */
    get highlight() {
        return this.highlightProperty;
    }
    /**
     * Gets or sets the highlight factor, a number used to calculate lighting effects.
     * @remarks Defaults to 0.05
     */
    set highlight(highlight) {
        this.highlightProperty = highlight;
        this.notifyPropertyChanged(Constants_1.PROPERTY.HIGHLIGHT);
    }
}
exports.SurfaceMeshRenderableSeries3D = SurfaceMeshRenderableSeries3D;
