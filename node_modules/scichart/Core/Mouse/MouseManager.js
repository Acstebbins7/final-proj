"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MouseManager = void 0;
const ModifierMouseArgs_1 = require("../../Charting/ChartModifiers/ModifierMouseArgs");
const SciChartSurfaceBase_1 = require("../../Charting/Visuals/SciChartSurfaceBase");
const ExecuteOn_1 = require("../../types/ExecuteOn");
const array_1 = require("../../utils/array");
const Guard_1 = require("../Guard");
/**
 * The MouseManager handles mouse and touch events from any {@link IEventListenerSource} and publishes events to any {@link IReceiveMouseEvents}
 * type
 * @remarks
 * Used internally by the {@link SciChartSurface} and {@link SciChart3DSurface} to manage and route mouse eents
 */
class MouseManager {
    /**
     * Creates an instance of the {@link MouseManager}
     * @param target The target {@link SciChartSurfaceBase} that we are listening to events on
     */
    constructor(target) {
        // We allow null target for testing purpose
        this.sciChartSurface = target;
        this.onPointerMove = this.onPointerMove.bind(this);
        this.onPointerDown = this.onPointerDown.bind(this);
        this.onPointerUp = this.onPointerUp.bind(this);
        this.onMouseWheel = this.onMouseWheel.bind(this);
        this.onDoubleClick = this.onDoubleClick.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
        this.onMouseEnter = this.onMouseEnter.bind(this);
        this.onContextMenu = this.onContextMenu.bind(this);
        this.onPointerCancel = this.onPointerCancel.bind(this);
    }
    /**
     * Used internally - subscribes to mouse events on the source
     * @param source The source element, must implement {@link IEventListenerSource} which any HTML5 element does
     */
    subscribe(source) {
        Guard_1.Guard.notNull(source, "source");
        this.unsubscribe();
        this.canvas = source;
        source.addEventListener("pointermove", this.onPointerMove);
        source.addEventListener("pointerdown", this.onPointerDown);
        source.addEventListener("pointerup", this.onPointerUp);
        source.addEventListener("pointercancel", this.onPointerCancel);
        source.addEventListener("wheel", this.onMouseWheel);
        source.addEventListener("dblclick", this.onDoubleClick);
        source.addEventListener("mouseleave", this.onMouseLeave);
        source.addEventListener("mouseenter", this.onMouseEnter);
        source.addEventListener("contextmenu", this.onContextMenu);
    }
    /**
     * Used internally - unsubscribes from mouse events
     */
    unsubscribe() {
        if (this.canvas) {
            this.canvas.removeEventListener("pointermove", this.onPointerMove);
            this.canvas.removeEventListener("pointerdown", this.onPointerDown);
            this.canvas.removeEventListener("pointerup", this.onPointerUp);
            this.canvas.removeEventListener("pointercancel", this.onPointerCancel);
            this.canvas.removeEventListener("wheel", this.onMouseWheel);
            this.canvas.removeEventListener("dblclick", this.onDoubleClick);
            this.canvas.removeEventListener("mouseleave", this.onMouseLeave);
            this.canvas.removeEventListener("mouseenter", this.onMouseEnter);
            this.canvas.removeEventListener("contextmenu", this.onContextMenu);
        }
        this.canvas = null;
    }
    onPointerCancel(event) {
        const modifierEvent = ModifierMouseArgs_1.ModifierMouseArgs.fromPointerEvent(event);
        this.modifierPointerCancel(modifierEvent);
    }
    /**
     * Internal function called when 'pointermove' event is fired on the target element
     * @param event The {@link PointerEvent}
     */
    onPointerMove(event) {
        const modifierEvent = ModifierMouseArgs_1.ModifierMouseArgs.fromPointerEvent(event);
        this.modifierMouseMove(modifierEvent);
    }
    /**
     * Internal function called when 'pointerdown' event is fired on the target element
     * @param event The {@link PointerEvent}
     */
    onPointerDown(event) {
        // prevent page scrolling on MMB click
        if (event.button === ExecuteOn_1.EExecuteOn.MouseMiddleButton) {
            event.preventDefault();
        }
        const modifierEvent = ModifierMouseArgs_1.ModifierMouseArgs.fromPointerEvent(event);
        this.modifierMouseDown(modifierEvent);
    }
    /**
     * Internal function called when 'pointerup' event is fired on the target element
     * @param event The {@link PointerEvent}
     */
    onPointerUp(event) {
        const modifierEvent = ModifierMouseArgs_1.ModifierMouseArgs.fromPointerEvent(event);
        this.modifierMouseUp(modifierEvent);
    }
    /**
     * Internal function called when 'dblclick' event is fired on the target element
     * @param event The {@link PointerEvent}
     */
    onDoubleClick(event) {
        const modifierEvent = ModifierMouseArgs_1.ModifierMouseArgs.fromMouseEvent(event);
        this.modifierDoubleClick(modifierEvent);
    }
    /**
     * Internal function called when 'wheel' event is fired on the target element
     * @param event The {@link PointerEvent}
     */
    onMouseWheel(event) {
        event.preventDefault();
        const modifierEvent = ModifierMouseArgs_1.ModifierMouseArgs.fromWheelEvent(event);
        this.modifierMouseWheel(modifierEvent);
    }
    /**
     * Internal function called when 'mouseleave' event is fired on the target element
     * @param event The {@link PointerEvent}
     */
    onMouseLeave(event) {
        const modifierEvent = ModifierMouseArgs_1.ModifierMouseArgs.fromMouseEvent(event);
        this.modifierMouseLeave(modifierEvent);
    }
    /**
     * Internal function called when 'mouseenter' event is fired on the target element
     * @param event The {@link PointerEvent}
     */
    onMouseEnter(event) {
        const modifierEvent = ModifierMouseArgs_1.ModifierMouseArgs.fromMouseEvent(event);
        this.modifierMouseEnter(modifierEvent);
    }
    /**
     * Internal function called when 'contextmenu' event is fired on the target element
     * @param event The {@link PointerEvent}
     */
    onContextMenu(event) {
        // prevent context menu on chart elements
        event.preventDefault();
    }
    modifierPointerCancel(args) {
        this.chartModifiers.forEach(cm => {
            if (cm.canReceiveMouseEvents && (!args.handled || cm.receiveHandledEvents)) {
                if (args.isMaster || (!args.isMaster && cm.modifierGroup === args.modifierGroup)) {
                    cm.modifierPointerCancel(args);
                }
            }
        });
        if (args.isMaster) {
            this.chartModifierGroups.forEach(modifierGroup => {
                this.sciChartSurface.otherSurfaces.forEach(scs => {
                    const argsCopy = ModifierMouseArgs_1.ModifierMouseArgs.copy(args, modifierGroup, this.sciChartSurface.seriesViewRect, scs.seriesViewRect);
                    scs.mouseManager.modifierPointerCancel(argsCopy);
                });
            });
        }
    }
    /**
     * Internal function called to route a mouse move event to all {@link sciChartSurface.chartModifiers}
     * @param args The {@link ModifierMouseArgs} to route
     * @remarks Event routing stops if any event marks {@link ModifierMouseArgs.handled} as true. To override this,
     * the user must set {@link ChartModifierBase.receiveHandledEvents} = true.
     */
    modifierMouseMove(args) {
        // Annotation Adorners
        if (this.sciChartSurface.surfaceType === SciChartSurfaceBase_1.ESurfaceType.SciChartSurfaceType) {
            const scs = this.sciChartSurface;
            if (scs.adornerLayer.isAnnotationSelected) {
                const currentAnnotation = scs.adornerLayer.selectedAnnotation;
                if (currentAnnotation.isDraggingStarted) {
                    currentAnnotation.onDragAdorner(args);
                }
            }
        }
        this.chartModifiers.forEach(cm => {
            if (cm.canReceiveMouseEvents && (!args.handled || cm.receiveHandledEvents)) {
                if (args.isMaster || (!args.isMaster && cm.modifierGroup === args.modifierGroup)) {
                    cm.modifierMouseMove(args);
                }
            }
        });
        if (args.isMaster) {
            this.chartModifierGroups.forEach(modifierGroup => {
                this.sciChartSurface.otherSurfaces.forEach(scs => {
                    const args2 = ModifierMouseArgs_1.ModifierMouseArgs.copy(args, modifierGroup, this.sciChartSurface.seriesViewRect, scs.seriesViewRect);
                    scs.mouseManager.modifierMouseMove(args2);
                });
            });
        }
    }
    /**
     * Internal function called to route a mouse down event to all {@link sciChartSurface.chartModifiers}
     * @param args The {@link ModifierMouseArgs} to route
     * @remarks Event routing stops if any event marks {@link ModifierMouseArgs.handled} as true. To override this,
     * the user must set {@link ChartModifierBase.receiveHandledEvents} = true.
     */
    modifierMouseDown(args) {
        const updateModifiers = () => {
            this.chartModifiers.forEach(cm => {
                if (cm.canReceiveMouseEvents && (!args.handled || cm.receiveHandledEvents)) {
                    if (args.isMaster || (!args.isMaster && cm.modifierGroup === args.modifierGroup)) {
                        cm.modifierMouseDown(args);
                    }
                }
            });
            if (args.isMaster) {
                this.chartModifierGroups.forEach(modifierGroup => {
                    this.sciChartSurface.otherSurfaces.forEach(scs => {
                        const args2 = ModifierMouseArgs_1.ModifierMouseArgs.copy(args, modifierGroup, this.sciChartSurface.seriesViewRect, scs.seriesViewRect);
                        scs.mouseManager.modifierMouseDown(args2);
                    });
                });
            }
        };
        const updateAdorner = (_scs) => {
            _scs.adornerLayer.selectAnnotation(args);
            const currentAnnotation = _scs.adornerLayer.selectedAnnotation;
            if (_scs.adornerLayer.isAnnotationSelected) {
                currentAnnotation.onDragStarted(args);
                if (currentAnnotation.isDraggingStarted) {
                    this.modifierMouseMove(args);
                }
            }
            else {
                updateModifiers();
            }
        };
        // Annotation Adorners
        if (this.sciChartSurface.surfaceType === SciChartSurfaceBase_1.ESurfaceType.SciChartSurfaceType) {
            const scs = this.sciChartSurface;
            const currentAnnotation = scs.adornerLayer.selectedAnnotation;
            if (scs.adornerLayer.isAnnotationSelected) {
                if (!currentAnnotation.onDragStarted(args)) {
                    updateAdorner(scs);
                }
            }
            else {
                updateAdorner(scs);
            }
        }
        else {
            updateModifiers();
        }
    }
    /**
     * Internal function called to route a mouse up event to all {@link sciChartSurface.chartModifiers}
     * @param args The {@link ModifierMouseArgs} to route
     * @remarks Event routing stops if any event marks {@link ModifierMouseArgs.handled} as true. To override this,
     * the user must set {@link ChartModifierBase.receiveHandledEvents} = true.
     */
    modifierMouseUp(args) {
        // Annotation Adorners
        if (this.sciChartSurface.surfaceType === SciChartSurfaceBase_1.ESurfaceType.SciChartSurfaceType) {
            const scs = this.sciChartSurface;
            if (scs.adornerLayer.isAnnotationSelected) {
                const currentAnnotation = scs.adornerLayer.selectedAnnotation;
                if (currentAnnotation.isDraggingStarted) {
                    currentAnnotation.onDragEnded();
                }
            }
        }
        this.chartModifiers.forEach(cm => {
            if (cm.canReceiveMouseEvents && (!args.handled || cm.receiveHandledEvents)) {
                if (args.isMaster || (!args.isMaster && cm.modifierGroup === args.modifierGroup)) {
                    cm.modifierMouseUp(args);
                }
            }
        });
        if (args.isMaster) {
            this.chartModifierGroups.forEach(modifierGroup => {
                this.sciChartSurface.otherSurfaces.forEach(scs => {
                    const args2 = ModifierMouseArgs_1.ModifierMouseArgs.copy(args, modifierGroup, this.sciChartSurface.seriesViewRect, scs.seriesViewRect);
                    scs.mouseManager.modifierMouseUp(args2);
                });
            });
        }
    }
    /**
     * Internal function called to route a mouse wheel event to all {@link sciChartSurface.chartModifiers}
     * @param args The {@link ModifierMouseArgs} to route
     * @remarks Event routing stops if any event marks {@link ModifierMouseArgs.handled} as true. To override this,
     * the user must set {@link ChartModifierBase.receiveHandledEvents} = true.
     */
    modifierMouseWheel(args) {
        this.chartModifiers.forEach(cm => {
            if (cm.canReceiveMouseEvents && (!args.handled || cm.receiveHandledEvents)) {
                if (args.isMaster || (!args.isMaster && cm.modifierGroup === args.modifierGroup)) {
                    cm.modifierMouseWheel(args);
                }
            }
        });
        if (args.isMaster) {
            this.chartModifierGroups.forEach(modifierGroup => {
                this.sciChartSurface.otherSurfaces.forEach(scs => {
                    const args2 = ModifierMouseArgs_1.ModifierMouseArgs.copy(args, modifierGroup, this.sciChartSurface.seriesViewRect, scs.seriesViewRect);
                    scs.mouseManager.modifierMouseWheel(args2);
                });
            });
        }
    }
    /**
     * Internal function called to route a mouse double click event to all {@link sciChartSurface.chartModifiers}
     * @param args The {@link ModifierMouseArgs} to route
     * @remarks Event routing stops if any event marks {@link ModifierMouseArgs.handled} as true. To override this,
     * the user must set {@link ChartModifierBase.receiveHandledEvents} = true.
     */
    modifierDoubleClick(args) {
        this.chartModifiers.forEach(cm => {
            if (cm.canReceiveMouseEvents && (!args.handled || cm.receiveHandledEvents)) {
                if (args.isMaster || (!args.isMaster && cm.modifierGroup === args.modifierGroup)) {
                    cm.modifierDoubleClick(args);
                }
            }
        });
        if (args.isMaster) {
            this.chartModifierGroups.forEach(modifierGroup => {
                this.sciChartSurface.otherSurfaces.forEach(scs => {
                    const args2 = ModifierMouseArgs_1.ModifierMouseArgs.copy(args, modifierGroup, this.sciChartSurface.seriesViewRect, scs.seriesViewRect);
                    scs.mouseManager.modifierDoubleClick(args2);
                });
            });
        }
    }
    /**
     * Internal function called to route a mouse leave event to all {@link sciChartSurface.chartModifiers}
     * @param args The {@link ModifierMouseArgs} to route
     * @remarks Event routing stops if any event marks {@link ModifierMouseArgs.handled} as true. To override this,
     * the user must set {@link ChartModifierBase.receiveHandledEvents} = true.
     */
    modifierMouseLeave(args) {
        this.chartModifiers.forEach(cm => {
            if (cm.canReceiveMouseEvents && (!args.handled || cm.receiveHandledEvents)) {
                if (args.isMaster || (!args.isMaster && cm.modifierGroup === args.modifierGroup)) {
                    cm.modifierMouseLeave(args);
                }
            }
        });
        if (args.isMaster) {
            this.chartModifierGroups.forEach(modifierGroup => {
                this.sciChartSurface.otherSurfaces.forEach(scs => {
                    const args2 = ModifierMouseArgs_1.ModifierMouseArgs.copy(args, modifierGroup, this.sciChartSurface.seriesViewRect, scs.seriesViewRect);
                    scs.mouseManager.modifierMouseLeave(args2);
                });
            });
        }
    }
    /**
     * Internal function called to route a mouse enter event to all {@link sciChartSurface.chartModifiers}
     * @param args The {@link ModifierMouseArgs} to route
     * @remarks Event routing stops if any event marks {@link ModifierMouseArgs.handled} as true. To override this,
     * the user must set {@link ChartModifierBase.receiveHandledEvents} = true.
     */
    modifierMouseEnter(args) {
        this.chartModifiers.forEach(cm => {
            if (cm.canReceiveMouseEvents && (!args.handled || cm.receiveHandledEvents)) {
                if (args.isMaster || (!args.isMaster && cm.modifierGroup === args.modifierGroup)) {
                    cm.modifierMouseEnter(args);
                }
            }
        });
        if (args.isMaster) {
            this.chartModifierGroups.forEach(modifierGroup => {
                this.sciChartSurface.otherSurfaces.forEach(scs => {
                    const args2 = ModifierMouseArgs_1.ModifierMouseArgs.copy(args, modifierGroup, this.sciChartSurface.seriesViewRect, scs.seriesViewRect);
                    scs.mouseManager.modifierMouseEnter(args2);
                });
            });
        }
    }
    get chartModifiers() {
        return this.sciChartSurface.chartModifiers.asArray();
    }
    get chartModifierGroups() {
        const arr = this.chartModifiers.filter(cm => cm.modifierGroup !== undefined).map(el => el.modifierGroup);
        return array_1.getUniqueValues(arr);
    }
}
exports.MouseManager = MouseManager;
